\part{Introduction}



PHP\footnote{PHP：Hypertext Preprocessor，递归命名。}（Hypertext Preprocessor，超文本预处理器）是一种开源的通用计算机脚本语言，尤其适用于网络开发并可嵌入HTML中使用，现在大多数的Web主机都提供 PHP 的支持，而且使用PHP完全是免费的。


PHP针对大多数HTTP服务器都提供了相应的模块，而且PHP 支持 CGI 标准，因而使得 PHP 能够作为 CGI 处理器来工作。

作为一种免费的，并且使用广泛的创建动态交互性站点的强有力的服务器端脚本语言，而且PHP开始注重程序运行性能和自身代码的模块性，因此对于ASP、ASP.NET等竞争者来说，PHP 无疑是另一种高效率的选项。




PHP最初由Rasmus Lerdorf在1995年开始开发，现在PHP的标准由PHP Group和开放源代码社区维护。PHP以PHP License作为许可协议，不过因为这个协议限制了PHP名称的使用，所以和开放源代码许可协议GPL不兼容。

PHP 文件的文件后缀是``.php"、``.php3" 或 ``.phtml"，其中``.php"是 PHP 的默认扩展名，所有以 .php 结尾的文件都将由 PHP 来处理。在支持PHP的服务器上，只需要建立 .php 文件，并把它们放置到Web目录中，服务器将自动解析这些文件，不用编译任何东西，也不用安装任何其它的工具，仅仅只需把这些使用了 PHP 的文件想象成简单的 HTML 文件，其中只不过多了一种新的标识符，在这里可以做各种各样的事情。

PHP的主要目标是允许网络开发人员快速编写动态页面，其语法借鉴了C、Java和Perl等流行计算机语言的特点，易于一般程序员学习。使用 PHP 的一大好处是它对于初学者来说极其简单，同时也给专业的程序员提供了各种高级的特性，而且尽管 PHP 的开发是以服务端脚本为目的，但事实上其功能远不局限与此，PHP也被用于其他很多领域。


\zihao{6}



\begin{longtable}{|m{16pt}|m{20pt}|m{35pt}|m{300pt}|}

%head
\multicolumn{4}{r}{}
\tabularnewline\hline
主要\newline 版本	&次要\newline 版本	&发布日期	&说明
\endhead
%endhead

%firsthead
\caption{PHP版本历程}\\
\hline
主要\newline 版本	&次要\newline 版本	&发布日期	&说明
\endfirsthead
%endfirsthead

%foot
\multicolumn{4}{r}{}
\endfoot
%

%lastfoot
\endlastfoot
%endlastfoot

\hline
1.0		&1.0.0	&1995-06-08	&正式名称为``Personal Home Page Tools (PHP Tools)"，第一次使用了``PHP"的名字。\\
\hline
2.0		&2.0.0	&1996-04-16	&针对PHP 1.0的改进版，速度更快、体积更小，更容易产生动态网页。\\
\hline
3.0		&3.0.0	&1998-06-06	&开发方式改成多人共同参与。Zeev Suraski和Andi Gutmans为了这个版本重写了剖析引擎。\\
\hline
\multirow{7}{40pt}{4.0}		&4.0.0	&2000-05-22	&改成以Zend引擎作为语法分析器，具有两阶段剖析/标签剖析系统等先进功能。\\ \cline{2-4}

		&4.1.0	&2001-12-10	&加入``超全局变量"（superglobals）功能，包含了\$\_GET、\$\_POST、\$\_SESSION等。\\  \cline{2-4}

		&4.2.0	&2002-04-22	&默认取消register\_globals功能。从网络接收的数据将不会设置成全局变量，增加程序安全性。\\ \cline{2-4}

		&4.3.0	&2002-12-27	&加入命令行可执行文件，称为CLI。\\ \cline{2-4}

		&4.4.0	&2005-07-11	&Added man pages for phpize and php-config scripts.\\ \cline{2-4}

		&4.4.8	&2008-01-03	&一些安全性的增强。曾可能为PHP 4的最后版本。若有必要，提供安全性更新到2008-08-08。\\ \cline{2-4}

		&4.4.9	&2008-08-07	&更多安全性增强和问题修补。PHP 4.4系列的最后版本。\\ \cline{2-4}
\hline
\multirow{18}{40pt}{5.0}		&5.0.0	&2004-07-13	&Zend Engine II with a new object model.\\ \cline{2-4}

		&5.1.0	&2005-11-24	&Performance improvements with introduction of compiler variables in re-engineered PHP Engine.\\ \cline{2-4}

		&5.2.0	&2006-11-02	&默认打开``过滤"的扩展。\\ \cline{2-4}

		&5.2.8	&2008-12-08	&emergent bug fix。\\ \cline{2-4}

		&5.2.9	&2009-02-26	&解决了5.2.*的超过了50多个错误和多个安全问题，增加了稳定性。\\ \cline{2-4}

		&5.2.10&2009-06-18	&这个版本修正了大量的bug和安全漏洞，并升级了时区数据库。\\ \cline{2-4}

		&5.2.17&2011-01-06	&修正了一个浮点数转化的Bug。\\ \cline{2-4}

		&5.3.0	&2009-06-30	&支持命名空间;\newline 使用XMLReader和XMLWriter增强XML支持;\newline 支持SOAP,延迟静态绑定，跳转标签（有限的goto）, 闭包，Native PHP archives。\\ \cline{2-4}

		&5.3.3	&2010-07-22	&使用命名空间的类中，与类同名的成员函数不再作为构造函数。\\ \cline{2-4}

		&5.3.6	&2011-03-17	&修正一系列Bug。\\ \cline{2-4}

		&5.3.10&2012-02-02	&修正了Stefan Esser报告的任意远程代码执行漏洞，CVE-2012-0830。\\ \cline{2-4}

		&5.4.0	&2012-03-01	&支持Trait、简短数组表达式。\newline 移除了register\_globals, safe\_mode, allow\_call\_time\_pass\_reference, session\_register(), session\_unregister(), magic\_quotes以及session\_is\_registered()。\newline 加入了内建的Web服务器。\newline 增强了性能，减小内存使用量。\\ \cline{2-4}
\hline
6.0		&6.0.0	&	&支持Unicode;移除ereg扩展；\newline 内置Alternative PHP Cache；\newline 移除mime\_magic和重写fileinfo()以更好地支持MIME。\newline 部分PHP 6特性已加入至PHP 5.3.0（命名空间，延迟静态绑定，lambda函数，闭包，goto）和5.4.0（traits，闭包重绑定）中。\\ 
\hline
\end{longtable}



\zihao{5}



相比ASP，PHP可以在多数的服务器和操作系统上运行，而且PHP支持大多数的Web服务器，现在云计算平台（Google App Engine、Amazon EC2和Microsoft Azure等）都提供了对PHP的支持。

另外，PHP的扩展性使其除了可以向最终用户提供数据库、协议和API的基础结构之外，还允许开发者自己加入并提交新的模块。



PHP的应用范围相当广泛，尤其是在网页程序的开发上，PHP 文件可包含文本、HTML 标签以及脚本，但是PHP的用途并不局限于输出 HTML。PHP 还能被用来动态输出图像、PDF 文件甚至 Flash 动画（使用 libswf 和 Ming）。PHP还能够非常简便的输出文本，例如 XHTML 以及任何其它形式的 XML 文件，PHP 能够自动生成这些文件，然后通过在服务端开辟出一块动态内容的缓存从而直接把它们打印出来，或者将它们存储到文件系统中。







PHP 具有极其有效的文本处理特性，包括 Perl 兼容正则表达式（PCRE）以及许多扩展和工具可用于解析和访问 XML 文档。PHP 将所有的 XML 功能标准化于坚实的 libxml2 扩展，并且还增加了 SimpleXML，XMLReader 以及 XMLWriter 支持以扩充其功能。另外，PHP还有很多其它有趣的扩展库，以及一些附加的 PECL 扩展。






使用 PHP，除了可以自由地选择操作系统和Web服务器之外，还可以在开发时选择使用过程和面向对象，或者两者混合的方式来开发。尽管 PHP 4 不支持 OOP 所有的标准，但很多代码仓库和大型的应用程序（包括 PEAR 库）仅使用 OOP 代码来开发。后来PHP 5 弥补了 PHP 4 的这一弱点，引入了完全的对象模型。

PHP支持很大范围的数据库，使用任何针对某数据库的扩展（例如 mysql）编写数据库支持的网页非常简单，或者使用抽象层如 PDO，或者通过 ODBC 扩展连接到任何支持 ODBC 标准的数据库。其它一些数据库也可能会用 cURL 或者 sockets，例如 CouchDB。



PHP 还支持利用诸如 LDAP、IMAP、SNMP、NNTP、POP3、HTTP、COM（Windows 环境）等不计其数的协议的服务，还可以开放原始网络端口，使得任何其它的协议能够协同工作。PHP 支持和所有Web开发语言之间的 WDDX 复杂数据交换。关于相互连接，PHP 已经支持了对 Java 对象的即时连接，并且可以透明地将其用作 PHP 对象。









\chapter{History}




PHP最初是Rasmus Lerdorf为了要维护个人网页，而用C语言开发的一些用以取代原先使用Perl封装的CGI工具程序集。这些工具程序用来显示Rasmus Lerdorf的个人履历以及统计网页流量。他将这些程序和一些窗体解释器集成起来，称为PHP/FI，其中FI可以和数据库连接，从而让PHP可以产生简单的动态网页程序。

Rasmus Lerdorf在1995年6月8日将PHP/FI公开发布，希望可以通过社区来加速程序开发与查找错误。这个发布的版本命名为PHP 2，已经有今日PHP的一些雏型，像是类似Perl的变量命名方式、窗体处理功能、以及嵌入到HTML中运行的能力。程序语法上也类似Perl，有较多的限制，不过更简单、更有弹性。

1997年，Zeev Suraski和Andi Gutmans不满足于PHP在大型项目中的表现，从而重写了PHP的语法分析器，这成为了PHP 3的基础，而PHP也在这个时候改称为PHP: Hypertext Preprocessor。

1997年11月，开发团队发布了PHP/FI 2，随后就开始PHP 3的开放测试，并于1998年6月正式发布PHP 3。

Zeev Suraski和Andi Gutmans在PHP 3发布后开始改写PHP的核心，这个在1999年发布的语法分析器称为Zend Engine，他们也在以色列的Ramat Gan成立了Zend Technologies来管理PHP的开发。

2000年5月22日，以Zend Engine 1.0为基础的PHP 4正式发布，增加了数组操作函数、完整的会话机制、对输出缓存的支持等。

2004年7月13日发布的PHP 5使用了第二代的Zend Engine，而且PHP5包含了许多新特色，比如强化的面向对象功能、引入PDO以及许多性能上的增强。



从2008年开始，PHP 5成为了PHP唯一维护中的稳定版本，PHP 4已经不会继续更新，以鼓励用户迁移到PHP 5。

PHP 6的开发也正在进行中，主要的改进有移除\texttt{register\_globals}、magic quotes和Safe mode的功能。

与此同时，PHP 7的开发也正在进行中，主要的改进有PHPNG、JIT引擎、抽象语法树编译、异步编程。

现在PHP的标准由PHP Group和开放源代码社区维护，并且以PHP License作为许可协议，限制PHP名称的使用，因此和开放源代码许可协议GPL并不兼容。




要查看当前PHP信息，可以通过网页或者命令行，其中通过网页可以直观的显示。

\begin{lstlisting}[language=PHP]
<?php
	phpinfo();
?>
\end{lstlisting}

或者在命令行中输入如下的命令：

\begin{lstlisting}[language=bash]
php -i
//or
php -r 'phpinfo();'
\end{lstlisting}

调用函数 \texttt{phpinfo()}可以得到很多有关当前系统的有用信息，例如预定义变量、已经加载的 PHP 模块和配置信息。为了移除敏感信息，比如AUTH\_USER和AUTH\_PASSWORD，可以修改代码如下：

\begin{lstlisting}[language=PHP]
<?php
  // start output buffering
  ob_start();
  
  // send phpinfo content
  phpinfo();
  
  // get phpinfo content
  $html = ob_get_contents();
  
  // flush the output buffer
  ob_end_clean();
  
  // remove auth data
  if(isset($_SERVER['AUTH_USER']))
    $html = str_replace($_SERVER['AUTH_USER'], '<i>no value</i>',$html);
  if(isset($_SERVER['AUTH_PASSWORD']))
    $html = str_replace($_SERVER['AUTH_PASSWORD'], '<i>no value</i>', $html);
  echo $html;
?>
\end{lstlisting}

为了比较上述两种方法的异同，可以在一个页面中同时运行这两个测试页面：

\begin{lstlisting}[language=HTML]
<html>
  <frameset cols="50%,50%">
    <frame src="phptest.php">
    <frame src="phpinfo.php">
  </frameset>
</html>
\end{lstlisting}



















\chapter{Compatibility}


在兼容性方面，PHP有可能影响到老版本的代码的最重要的两点改动分别是：

\begin{compactitem}
\item 取消了旧的 \texttt{\$HTTP\_*\_VARS}数组（在函数或者方法中原本是全局变量）。

\end{compactitem}

PHP 4.1.0 版本引入了如下超全局数组变量：

\begin{compactitem}
\item \texttt{\$\_GET}
\item \texttt{\$\_POST}
\item \texttt{\$\_COOKIE}
\item \texttt{\$\_SERVER}
\item \texttt{\$\_FILES}
\item \texttt{\$\_ENV}
\item \texttt{\$\_REQUEST}
\item \texttt{\$\_SESSION}
\end{compactitem}

老的 \texttt{\$HTTP\_*\_VARS}数组，诸如 \texttt{\$HTTP\_POST\_VARS}等，从 PHP 3 就已经开始使用，它们仍然存在。


自 PHP 5.0.0 起, 用 \texttt{register\_long\_arrays}设置选项可禁用 长类型的 PHP 预定义变量数组。


\begin{compactitem}
\item 外部变量不再被默认注册为全局变量。也就是说，从 PHP 4.2.0 版开始，php.ini 中的设置选项 \texttt{register\_globals}默认值变成了\texttt{off}。

\end{compactitem}

建议用以上提到的超全局数组变量来访问这些值。但可能老的脚本、书籍以及教程都可能建立在该设置为\texttt{on} 的基础上。

如果该选项被设置为\texttt{on}，则可以在 \url{http://www.example.com/foo.php?id=42}中直接使用变量 \texttt{\$id}。但不管被设置为 \texttt{on}还是\texttt{off}，\texttt{\$\_GET['id']}一直有效。







\chapter{Syntax}


\section{Constructs}


The PHP syntax and semantics are the format (syntax) and the related meanings (semantics) of the text and symbols in the PHP programming language. They form a set of rules that define how a PHP program can be written and interpreted. PHP is a procedural and object-oriented language for coding webpage markup text to be transformed into HTML format.


Each PHP statement is terminated by semicolon ("\texttt{;}"). The PHP markup can display text by using "\texttt{echo}" with variables named by dollar-prefix "\texttt{\$}" on case-sensitive names (\texttt{\$}xx, \texttt{\$}xX, \texttt{\$}NewX, etc.). The assignment operator is "\texttt{=}". The markup can be modularized into functions (or methods) defined with keyword "\textcolor{Blue}{\texttt{function}}" within optional classes named by "\texttt{class} xx". The control structures include: \texttt{if}, \texttt{while}, \texttt{for}, \texttt{foreach}, \texttt{switch}. Grouping of text can be specified by curly braces ("\texttt{\{...\}}"), but some control structures can use colon syntax with end keywords, such as in statement below:

\begin{lstlisting}[language=PHP]
if ($x==0) : 
  echo "zero"; 
endif;
\end{lstlisting}


The following Hello world program is written in PHP code embedded in an HTML document:

\begin{lstlisting}[language=PHP]
<!DOCTYPE html>
<html>
<meta charset="utf-8">
<head>
  <title>PHP Test</title>
</head>
<body>
	<?php
	 echo 'Hello World';
	?>
</body>
</html>
\end{lstlisting}




However as PHP does not need to be embedded in HTML, or used with a web server, the simplest version of a Hello World program can be written like this:

\begin{lstlisting}[language=PHP]
<?='Hello world.'; ?>
\end{lstlisting}

\section{Delimiters}



The PHP interpreter only executes PHP code within its delimiters(the trigger symbols). Anything outside its delimiters is not processed by PHP (although non-PHP text is still subject to control structures described in PHP code) . The most common delimiters are \texttt{<?php} to open and \texttt{?>} to close PHP sections.  Other delimiters, \texttt{<script language="php">} and \texttt{</script>} delimiters are also available, as are the shortened forms \texttt{<?} or \texttt{<?=} (which is used to echo back a string or variable) and \texttt{?>} as well as ASP-style short forms \texttt{<\%} or \texttt{<\%=} and \texttt{\%>}, so these two forms are the most portable. While short delimiters are used, they make script files less portable as support for them can be disabled in the PHP configuration, and so they are discouraged. The purpose of all these delimiters is to separate PHP code from non-PHP code, including HTML.



The first form of delimiters, \texttt{<?php} and \texttt{?>}, in XHTML and other XML documents, creates correctly formed XML "processing instructions". This means that the resulting mixture of PHP code and other markup in the server-side file is itself well-formed XML.

Therefore, in either of these two cases, the resulting mixture of PHP and other markup is well-formed, and so probably valid, as XML and XHTML on the server before PHP processing. This may be helpful if the source code documents ever need to be processed in other ways during the life of the software.

The purpose of these delimiters is to separate PHP code from non-PHP code (notably HTML). Everything outside the delimiters is ignored by the PHP parser and is passed through as output.



\section{Variables}

变量和常量可以理解为程序中的基本数据存储单元，可以存储不同类型的数据，而且PHP的变量和常量的数据类型由程序的上下文决定。

变量是程序运行时用于保存信息或数据的临时“仓库”，可以改变或删除变量。




\section{Structures}




In terms of keywords and language syntax, PHP is similar to most high level languages that follow the C style syntax. PHP offers an alternative syntax using colons rather than the standard curly-brace syntax (of "\texttt{\{...\}}"). This syntax affects the following control structures: \texttt{\textcolor{Blue}{if}} conditions, \texttt{\textcolor{Blue}{for}} and \texttt{\textcolor{Blue}{while}} loops, and function returns are similar in syntax to languages such as \texttt{C}, \texttt{C++}, \texttt{C\#}, \texttt{Java} and \texttt{Perl}.

The syntax varies only slightly from the curly-brace syntax. In each case the opening brace (\texttt{\{}) is replaced with a colon (\texttt{:}) and the close brace is replaced with \texttt{endif;}, \texttt{endwhile;}, \texttt{endfor;}, \texttt{endforeach;}, or \texttt{endswitch;}, respectively. Mixing syntax styles within the same control block is not supported. An example of the syntax for an \texttt{if/elseif} statement is as follows:

\begin{lstlisting}[language=PHP]
if (condition) :
     // code here
elseif (condition) :
     // code here
else :
     // code here
endif;
\end{lstlisting}






PHP的语法参考了Perl、C语言，而且可以集成在HTML之中，以下是一个简单的Hello World代码：

\begin{lstlisting}[language=PHP]
<!DOCTYPE html>
<meta charset="utf-8">
<html>
<head>
  <title>PHP Test</title>
</head>
<body>
	<?php
	 echo 'Hello World';
	?>
</body>
</html>
\end{lstlisting}

PHP解析引擎只解析<?php到?>之间的代码，不包含在<?php到?>之间的内容会直接提交，所以可以用以下的方式来将PHP代码嵌入在HTML之中：

\begin{lstlisting}[language=PHP]
 <?php
   //-PHP代码
 ?>
 html内容
 <?php
   //-PHP代码
 ?>
\end{lstlisting}

在HTML中嵌入PHP时，比如需要单独输出某个变量，除了正常采用echo语句外，可以直接采用\verb|<?=$title ?>|

在判断语句中的HTML代码并不会被直接提交：


\begin{lstlisting}[language=PHP]
<?php
  if (false) {
 ?>
 HTML Code
 <?php
  }
?>
\end{lstlisting}

PHP可以用三种注解的形式：C与C++所使用的“/*...*/”与“//”，和Perl的“\#”。

\begin{lstlisting}[language=PHP]
 <?php
 /* 多行注释的第一行
 多行注释的另一行 */
 
 // 单行注释
 
 # 单行注释
 ?>
\end{lstlisting}


下面的示例说明了PHP的变量、常量、控制流程、函数、程序标记和注释等基本元素。



\begin{lstlisting}[language=PHP]
<html>
<head><title>Test</title></head>
<body>
<?php
define("MAX_LINE_NUM",4);
$title="<h1>Hello,php</h1>\n";
echo $title;

echo "<pre>\n";
for($i=1;$i<MAX_LINE_NUM;$i++){
    echo print_star($i);
    echo "\n";
}
echo "</pre>\n";

function print_star($num){
    return str_repeat("*",$num);
}

?>
</body>
</html>
\end{lstlisting}

在对函数或类的定义进行注释说明时，应该包含功能说明、参数列表和返回值等信息，也可以加入应用范例。



\chapter{Data types}

PHP主要有四种标量类型，标量可以认为是数据结构中最基本的单元，只能存储一个数据。

\begin{compactitem}
\item 整型（integer）
\item 浮点型（float）
\item 布尔型（boolean）
\item 字符串（string）
\end{compactitem}

在定义字符串数据类型时，单引号和双引号在功能上有明显的区别。

\begin{compactitem}
\item 双引号字符串支持变量的解析和转义字符。
\item 单引号字符串不支持变量解析以及转义字符，如果单引号字符串中包含“\texttt{'}”，那么需要在前面加一个“\textbackslash ”进行转义。
\end{compactitem}

单引号在定义简单的字符串时是更加高效的处理方式，双引号则需要花费额外的开销来处理字符串的转义和变量的解析，因此在没有特别需求时可以使用单引号。

另外，PHP还引入了定界符<\/<\/<来定义字符串，不过字符串必须包含在一组定界标识符中，而且定界结束符必须顶格书写。

\begin{lstlisting}[language=PHP]
<?php
$string=<<<EOD
	Are you ok?
EOD;

echo <<< EOT
	$string
	I'm ok.
EOT;
?>
\end{lstlisting}

定界符“<\/<\/<”后面紧跟的就是定界标识符，同样可以由字母、数字或下划线组成，并且不能以数字开始。

定界符中的字符串可以被解析，可以使用转义字符，但是不必转义引号，定界符可以用于定义或输出大量的文本的情况。

PHP支持的两种复合类型分别是数组（array）和对象（object），相对于标量只能存放一个数据，数组可以存放任何类型的多个数据，可以是标量数据、数组、对象、资源以及其他语法结构等。

数组中的每一个数据称为一个元素，每个元素包括索引（键名）和值两部分。

\begin{compactitem}
\item 元素的索引只能由数字或字符串组成，使用整型数字表示索引时类似于C语言的数组“下标”。
\item 元素的值可以是多种类型。
\end{compactitem}

PHP提供了多种方法来构造一个数组，其中最简单的是使用数组函数array()，而且在定义数组时可以省略索引。

\begin{lstlisting}[language=PHP]
<?php
$key = 7;
$my_stuff = array(
	1,
	'abc',
	'book'=>'PHP',
	13=>'number',
	"Children's Day"=>'1st June',
	$ky=>'a dynamic day',
	'what is the key here',  // 14=>'what is the key here'
);
?>
\end{lstlisting}

省略的索引值将按当前下标最大索引值加1计算，因此如果数组中当前的最大索引值为负数，那么下一个索引值变为0。

数组允许分别对元素赋值，如果有同名元素，那么只保留最后一次的定义，而且所有整数字符的键都被看作是整数。



对象是一种高级的数据类型，任何事物都可以看作是对象，每一个对象都是由一组属性值和一组方法（或称操作）构成，其中属性表明对象的一种状态，方法通常用来获取或改变对象的属性。




PHP支持的两种特殊类型分别是NULL和资源类型，其中NULL类型表示“空”、“没有”、“不存在”或“未被初始化”等概念，它只有一个值（即NULL）。

NULL和False可以表达相同的概念，但是二者有着本质的区别。实际上，任何一种类型的数据，如果没有初始化或者被清空，都可以被认为是NULL。

\begin{compactitem}
\item 布尔型变量可以转换为整数：True转化为1，False转换为0。

\item 布尔型变量可以转换为字符串：True转化为字符“1”，False转换为字符“0”。

\end{compactitem}

NULL转换为整型后的值为0，转换为字符串后的值为空字符“”。



资源是由专门的函数建立和使用的，资源本身是一种特殊的数据类型，可以被用户创建、使用和释放。

PHP实现了自动垃圾回收机制来释放不再需要的资源，一般发生在PHP脚本运行结束之后。

按照封装的层次，用户无法获知某个资源的细节，通常包含打开文件、数据库连接、图形画布区域等特殊句柄等。





PHP中，变量以“\$”后接变量名称来表示，而且变量名称区分大小写。

有效的变量名称应以字母或下划线开头，后可以接任意数目的字母、数字或下划线，PHP也支持使用多字节文字作为变量名。

PHP解释器在解析变量时，将会尽可能多地取得“\$”后面的字符来组成一个合法的变量名，可以使用花括号把变量名括起来以明确表示一个变量。




\section{String}

PHP提供了针对字符串和数组的完善的支持，并且PHP还提供了自己独特的功能扩展。

\subsection{curl}

PHP利用curl库可以对URL地址进行解码或编码，不需要自己手动实现。


\subsection{pspell}

PHP利用aspell库（\url{http://aspell.net}）可以支持pspell扩展，从而实现单词拼写检查和建议。

\subsection{pcre}

PHP实用PCRE来实现对正则表达式的支持。




\section{Array}



PHP通过serialize()和unserialize()等函数，可以将数组、对象等数据进行序列化编码，从而方便其在数据库或会话周期中的存储。


\subsection{wddx}

PHP利用WDDX（Web分布式数据格式）可以进行数据串行化，从而在应用环境中交换更为复杂的数据结构。




\chapter{Functions}

PHP函数提供了各种不同的功能，例如文件处理、FTP、字符串处理等，而且这些函数的使用方法和C语言相近（例如printf）。

PHP的函数库系统除了提供了大量的内置函数之外，还允许用户通过扩展来引入自己的函数。例如，用户可以通过下面的代码来定义自己的函数myFunction()。


\begin{lstlisting}[language=PHP]
function myFunction() { // declares a function, this is named myFunction
 return 'John Doe'; // returns the value 'John Doe'
}
 
echo 'My name is ' . myFunction() . '!'; //outputs the text concatenated with the return value of myFunction.
// myFunction is called as a result of this syntax.
// The result of the output will be 'My name is John Doe!'
\end{lstlisting}

在Zend引擎的支持和优化下，现在PHP可以通过不同的扩展模块来支持各种各样的Web应用（例如网络爬虫等）。

In PHP 5.2 and earlier, functions are not first-class functions and can only be referenced by their name, directly or dynamically by a variable containing the name of the function. User-defined functions can be created at any time without being prototyped. 

Functions can be defined inside code blocks, permitting a run-time decision as to whether or not a function should be defined. Function calls must use parentheses, with the exception of zero argument class constructor functions called with the PHP \textcolor{Blue}{\texttt{new}} operator, where parentheses are optional. 

An example function definition is the following:

\begin{lstlisting}[language=PHP]
<?php
function hello(){
  echo "Hello World!\n";
}
 
hello();
?>
\end{lstlisting}

Prior to version 5.3, PHP supports quasi-anonymous functions through the \textcolor{Blue}{\texttt{create\_function()}} function, although they are not true anonymous functions because anonymous functions are nameless, but functions can only be referenced by name, or indirectly through a variable \textcolor{Blue}{\texttt{\$function\_name();}}, in PHP. As of version 5.3, PHP supports true anonymous functions.


Function calls may be made via variables, where the value of a variable contains the name of the function to call. This is illustrated in the following example:

\begin{lstlisting}[language=PHP]
<?php
function hello(){
  return 'Hello';
}
function world(){
  return "World!";
}
 
$function1 = 'hello';
$function2 = 'world';
 
echo $function1() . ' ' . $function2();
?>
\end{lstlisting}

PHP does not support named parameters or parameter skipping. Some core PHP developers have publicly expressed disappointment with this decision. Others have suggested workarounds for this limitation.

PHP gained support for closures in PHP 5.3. True anonymous functions are supported using the following syntax:


\begin{lstlisting}[language=PHP]
function getAdder($x) {
 return function($y) use ($x) {
  return $x + $y;
 };
}
 
$adder = getAdder(8);
echo $adder(2); // prints "10"
\end{lstlisting}


Here, the  \textcolor{Blue}{\texttt{getAdder()}} function creates a closure using the parameter  \textcolor{Blue}{\texttt{\$x}} (the keyword use imports a variable from the lexical context), which takes an additional argument  \textcolor{Blue}{\texttt{\$y}} and returns it to the caller. Such a function is a first class object, meaning that it can be stored in a variable, passed as a parameter to other functions, etc. For more details see \href{http://wiki.php.net/rfc/closures}{Lambda functions and closures RFC}.


The goto flow control statement is used as follows:

\begin{lstlisting}[language=PHP]
function lock() {
 $file = fopen('file.txt', 'r+');
 retry:
 if (!flock($file, LOCK_EX | LOCK_NB)) {
  goto retry;
 }
 fwrite($file, 'Success!');
 fclose($file);
}
\end{lstlisting}


When \textcolor{Blue}{\texttt{flock()}} is called, PHP opens a file and tries to lock it. The target label \textcolor{Blue}{\texttt{retry:}} defines the point to which execution should return if \textcolor{Blue}{\texttt{flock()}} is unsuccessful and goto retry; is called. The \textcolor{Blue}{\texttt{goto}} statement is restricted and requires that the target label be in the same file and context.

The goto statement has been supported since PHP 5.3.




\chapter{Objects}


Basic object-oriented programming functionality was added in PHP 3 and improved in PHP 4. Object handling was completely rewritten for PHP 5, expanding the feature set and enhancing performance. 

In previous versions of PHP, objects were handled like value types(or primitive types). The drawback of this method was that the whole object was copied when a variable was assigned or passed as a parameter to a method. In the new approach, objects are referenced by handle, and not by value. 

PHP 5 introduced private and protected member variables and methods, along with \texttt{abstract classes}, \texttt{final classes}, \texttt{abstract methods}, and \texttt{final methods}. It also introduced a standard way of declaring \texttt{constructors} and \texttt{destructors}, similar to that of other object-oriented languages such as C++, and a standard exception handling model. 

Furthermore, PHP 5 added interfaces and allowed for multiple interfaces to be implemented. There are special interfaces that allow objects to interact with the runtime system. Objects implementing ArrayAccess can be used with array syntax and objects implementing Iterator or IteratorAggregate can be used with the \textcolor{Blue}{\texttt{foreach}} language construct. 

The static method and class variable features in Zend Engine 2 do not work the way some would expect. There is no virtual table feature in the engine, so static variables are bound with a name instead of a reference at compile time.


This example shows how to define a class, \texttt{foo}, that inherits from class \texttt{bar}. The function \texttt{mystaticfunc} is a public static function that can be called with \texttt{foo::mystaticfunc();}.


\begin{lstlisting}[language=PHP]
class foo extends bar{
  function __construct(){
   $doo = "wah dee dee";
  }
  public static function mystaticfunc(){
   $dee = "dee dee dum";
  }
}
\end{lstlisting}


If the developer creates a copy of an object using the reserved word \textcolor{Blue}{\texttt{clone}}, the Zend engine will check if a \textcolor{Blue}{\texttt{\_\_clone()}} method has been defined or not. If not, it will call a default \textcolor{Blue}{\texttt{\_\_clone()}} which will copy the object's properties. If a \textcolor{Blue}{\texttt{\_\_clone()}} method is defined, then it will be responsible for setting the necessary properties in the created object. For convenience, the engine will supply a function that imports the properties of the source object, so that the programmer can start with a by-value replica of the source object and only override properties that need to be changed.

The following is a basic example of object-oriented programming in PHP:

\begin{lstlisting}[language=PHP]
<!DOCTYPE html>
<html>
  <head>
    <title>testobject</title>
  </head>
  <body>
    <?php
      class Person{
        public $firstName;
        public $lastName;
        
        public function __construct($firstName,$lastName= ''){
          $this->firstName = $firstName;
          $this->lastName = $lastName;
        }
        
        public function greet(){
          return "Hello, my name is " . $this->firstName . " " . $this->lastName . ".";
        }
        
        public static function staticGreet($firstName,$lastName){
          return "Hello, my name is " . $firstName . " " . $lastName . "."; 
        }
      }
      
      $he = new Person('Jim','Green');
      $she = new Person('Meimei','Han');
      $other = new Person('LiPing');

      echo $he->greet();
      echo '<br />';
      echo $she->greet();
      echo '<br />';
      echo $other->greet();
      echo '<br />';
      echo Person::staticGreet('LiPing');
    ?>
  </body>
</html>
\end{lstlisting}

The visibility of PHP properties and methods is defined using the keywords \textcolor{Blue}{\texttt{public}}, \textcolor{Blue}{\texttt{private}}, and \textcolor{Blue}{\texttt{protected}}. The default is public, if only \textcolor{Blue}{\texttt{var}} is used; \textcolor{Blue}{\texttt{var}} is a synonym for public. Items declared \textcolor{Blue}{\texttt{public}} can be accessed everywhere. \textcolor{Blue}{\texttt{protected}} limits access to inherited classes (and to the class that defines the item). \textcolor{Blue}{\texttt{private}} limits visibility only to the class that defines the item. Objects of the same type have access to each other's private and protected members even though they are not the same instance. PHP's member visibility features have sometimes been described as "highly useful." However, they have also sometimes been described as "at best irrelevant and at worst positively harmful."

\chapter{Filesystem}




文件系统是操作系统的重要组成部分，可以将其理解为数据存储的基本单元。


\section{Directory}


PHP提供的文件和目录函数等可以对本地文件系统进行直接操作，例如创建、读取和删除文件或目录，也可以对文件系统的所有者权限、用户组等信息进行查询和修改等。

在php.ini中激活“allow\_url\_open”选项后，可以使用PHP的fopen()或fwrite()等函数对远程文件进行操作。

\begin{compactitem}
\item 读取或下载远程Web服务器的文件；
\item 登录远程FTP服务器进行数据上传和下载；
\end{compactitem}

\section{Journal}


用户使用PHP的syslog()函数还可以实现对分布式日志的管理和维护等。


\section{File}


除了可以针对HTML和文本文件进行处理之外，PHP还可以对符合特定格式的文件进行快速处理。

\begin{compactitem}
\item CVS：逗号分隔的文件；
\item INI：配置文件；
\item XML
\end{compactitem}

另外，PHP也可以通过zlib来读取ZIP文件等。

在文件输出方面，PHP支持输出XHTML、XML、PDF、Flash和图形文件等。

\begin{compactitem}
\item PDF：PDFLib库
\item Flash：LibSWF或Ming库
\item 图像：GD库
\end{compactitem}

在Windows系统中，PHP通过Printer扩展可以在服务器端开辟动态缓存空间来直接打印文件。



\chapter{Protocol}

PHP支持FTP、LDAP、IMAP、SNMP、NNTP、POP3、HTTP和COM等通信协议。

另外，PHP还可以开放原始网络端口来使得任何其他的协议能够协同工作。

PHP支持和所有Web开发语言之间的WDDX复杂数据交换，而且PHP支持对Java对象的使用，这样可以将它们自由地用作PH对象。







\chapter{Development}

\section{Module}


PHP允许开发者使用C语言开发新的功能模块，并且可以编译为PHP核心模块，这样就可以在运行时动态加载。

从本质上来说，PHP的核心功能（例如字符串和数组处理）也是作为核心扩展来实现的，而且PECL提供了大量的第三方功能扩展。



\section{PEAR}


PEAR（PHP Extension and Application Repository）由Stig S. Bakken于2000年在PHP开发者会议上提出，目的是实做可以重复使用的库来提供PHP社区使用。

PEAR库从PHP4开始投入开发，其目标为：

\begin{compactitem}
\item 提供有架构的代码。
\item 提供社区可重复使用的库。
\item 创建PHP编码风格标准。
\end{compactitem}

PEAR库是PHP面向对象的应用和实践的最好例证，成熟的PEAR库包括：

\begin{table}[!ht]
\centering
\caption{PEAR计划}
\label{php_pear}
\rowcolors{1}{White}{Lavender}
\begin{tabular}{llll}
Authentication	&File Formats		&Mail			&Semantic Web\\
Benchmarking	&File System		&Math			&Streams\\
Caching			&Gtk Components	&Networking	&Structures\\
Configuration	&Gtk2 Components	&Numbers		&System\\
Console			&HTML				&Payment		&Text\\
Database		&HTTP				&PEAR			&Tools and Utilities\\
Date \& Time	&Images			&PHP			&Validate\\
Encryption		&Internationalization&Processing	&Web Services\\
Event			&Logging			&Science		&XML\\
\end{tabular}
\end{table}



\section{PECL}



除了内置的函数之外，PHP也提供了很多扩展库（extension），例如数据库连接函数、数据压缩函数、图形处理等，从PECL（PHP Extension Community Library）可以获取更多的函数库。




从PHP5开始引入了对全新的PECL模块的支持，而且PHP5支持面向对象的全部机制，并且保留了向下的兼容性。




PHP 扩展库通常称为“php\_*.dll”（其中星号代表具体某扩展的名字），PHP 发行包中包括了大多数开发者最常用到的扩展库，这些被称为“核心”扩展库。不过呢，如果用户所需要的功能并没有被任何核心扩展提供，那还是有可能在 PECL 中找到。PHP Extension Community Library（PECL，PHP 扩展社区库）是个 PHP 扩展的储存室，提供了对于所有已知扩展的下载及开发途径的指南。

PECL是通过PEAR 打包系统来的 PHP 扩展库仓库，要使用共享扩展库，必须经过编译，安装，然后加载。注意，当编译 PHP 模块时，拥有各种工具（autoconf，automake，libtool 等）很重要。

如果用户开发了一个自己使用的扩展，可以考虑将其发布到 PECL 中以便于其他有相同需求的用户使用。一个很好的副作用是可以得到其他用户的反馈，感谢，错误报告甚至修正/更新。不过在向 PECL 发布扩展之前先了解\url{http://pecl.php.net/package-new.php}。



以下指南中假定 /your/phpsrcdir/ 是 PHP 源程序的路径，extname 是 PECL 扩展库的名字。自己根据实际情况调整。此外还假定用户熟悉pear 命令，PEAR 手册里 pear 命令的信息同样适用于 pecl。

以下说明的方法提供了怎样编译和安装扩展库的各种指导，但并不会自动加载它们。可以通过将其包括在 php.ini 中用 \texttt{extension PHP}指令加载，或者用\texttt{dl()}函数。

下载 PECL 扩展库有几种方法，如：

\begin{compactitem}
\item \texttt{pecl download extname}

PECL 网站中列出的 PECL 扩展库的发行版本可以用 pear 命令来下载和安装，也可以指明具体的修正版。



\item \texttt{pecl install extname}

PECL 使建立共享 PHP 扩展库更容易。用pecl命令会自动下载扩展代码， 所以在这种情况下不需要再次下载。

\begin{lstlisting}[language=bash]
$ pecl install extname
\end{lstlisting}

这将下载 extname 的源代码，编译之，并将 \texttt{extname.so}安装到 extension\_dir 中。然后 \texttt{extname.so}就可以通过 php.ini 加载\footnote{在 php.ini 中激活扩展之后，需要重新启动 web 服务以使更改生效。}。

默认情况下，pecl 命令不会安装标记为 alpha 或 beta 状态的包。如果没有 stable 包可用，也可以用以下命令安装一个 beta 包：

\begin{lstlisting}[language=bash]
$ pecl install extname-beta
\end{lstlisting}

也可以用此命令安装一个指定的版本：

\begin{lstlisting}[language=bash]
$ pecl install extname-0.1
\end{lstlisting}

有时候不能用 pecl 安装命令。这可能是因为在防火墙后面，或者是因为想要安装的扩展库还没有 PECL 兼容的包，例如 SVN 中尚未发布的扩展库。如果要编译这种扩展库，可以用更底层的编译工具来手工进行编译。

phpize 命令是用来准备 PHP 扩展库的编译环境的。下面例子中，扩展库的源程序位于 extname 目录中：

\begin{lstlisting}[language=bash]
$ cd extname
$ phpize
$ ./configure
$ make
# make install
\end{lstlisting}

成功的安装将创建\texttt{extname.so}并放置于 PHP 的扩展库目录中。需要调整 php.ini，加入\texttt{extension=extname.so}这一行之后才能使用此扩展库。

如果系统中没有 phpize 命令并且使用了预编译的包（例如 RPM），那要安装 PHP 包相应的开发版本，此版本通常包含了 phpize 命令以及相应的用于编译 PHP 及其扩展库的头文件，通过\texttt{phpize --help}命令可以显示此命令用法。

php-config 是一个简单的命令行脚本用于获取所安装的 PHP 配置的信息。在编译扩展时，如果安装有多个 PHP 版本，可以在配置时用 \texttt{--with-php-config}选项来指定使用哪一个版本编译，该选项指定了相对应的 php-config 脚本的路径。

php-config 脚本在命令行所能使用的选项可以通过 \texttt{-h} 选项来显示：

\begin{lstlisting}[language=bash]
Usage: /usr/local/bin/php-config [OPTION]
Options:
  --prefix            [...]
  --includes          [...]
  --ldflags           [...]
  --libs              [...]
  --extension-dir     [...]
  --include-dir       [...]
  --php-binary        [...]
  --php-sapis         [...]
  --configure-options [...]
  --version           [...]
  --vernum            [...]
\end{lstlisting}

\begin{table}[htbp]
\centering
\caption{php-config 脚本命令行选项}
\label{PHP_commandline}
\rowcolors{1}{White}{Lavender}
\begin{tabular}{ll}
\hline
选项					&说明\\
\texttt{--prefix}			&PHP 所安装的路径前缀，例如 \texttt{/usr/local}\\
\texttt{--includes}		&列出用 \texttt{-I} 选项包含的所有文件\\
\texttt{--ldflags}		&PHP 编译时所使用的 \texttt{LD} 标志\\
\texttt{--libs}			&PHP 编译时所附加的库\\
\texttt{--extension-dir}	&扩展库的默认路径\\
\texttt{--include-dir}	&头文件的默认路径前缀\\
\texttt{--php-binary}	&PHP CLI 或者 CGI 可执行文件的完整路径\\
\texttt{--php-sapis}		&列出所有可用的 SAPI 模块\\
\texttt{--configure-options}	&重现当前 PHP 在编译时的配置选项\\
\texttt{--version}		&PHP 版本号\\
\texttt{--vernum}		&PHP 版本号，以整数表示\\
\end{tabular}
\end{table}

\item PECL

\href{http://pecl.php.net/}{PECL}网站包括有 PHP 开发组提供的不同扩展库的信息，包括：新记录，版本说明，需求，以及其它信息。



\item SVN

大多数 PECL 扩展库也在 SVN 中，见\url{http://svn.php.net/viewvc/pecl/}。要直接从 SVN 中下载，用以下命令：

\begin{lstlisting}[language=bash]
$ svn checkout http://svn.php.net/repository/pecl/extname/trunk extname
\end{lstlisting}

\item Windows 下载

在Windows系统下，PECL 扩展库位于“PHP{\textbackslash}ext”目录中（在 PHP 4 中位于“PHP{\textbackslash}extensions”目录中）。目前 PHP 项目没有为 Windows 下 PECL 扩展编译二进制文件，所有扩展都由 PHP 小组定期自动编译。如果在 PHP 发行包和 PCEL 中都没有某 DLL 文件，那可能需要自己编译之后才能使用该扩展。

在 Windows 上有两种加载 PHP 扩展的方式：把扩展编译进 PHP，或者加载 DLL，其中加载预编译的扩展是更简单更被推荐的方式。最常见的方式是在 php.ini 配置文件里包含一个 PHP 扩展，其实很多扩展已经在 php.ini 里了，仅需要移除分号来激活它们。

\begin{lstlisting}[language=bash]
;extension=php_extname.dll
extension=php_extname.dll
\end{lstlisting}

要加载某扩展时，需要在系统中有其相对应的“.dll”文件，但是用户常常会发现每个 DLL 都有好几个版本：

\begin{compactitem}
\item 不同的版本号（至少前两个数字要一致）
\item 不同的线程安全性设定
\item 不同的处理器体系（x86，x64，...)
\item 不同的排错设定
\item 其它
\end{compactitem}

用户的扩展设定应该与所使用的 PHP 可执行文件的设定都保持一致，有些Web服务器就会搞混，因为其并不一定使用和 PHP 可执行文件处于同一目录下的 php.ini 文件。要搞清楚具体使用了哪一个 php.ini 文件，在 phpinfo() 的输出中查看：


\begin{lstlisting}[language=bash]
Configuration File (php.ini) Path  C:\WINDOWS
Loaded Configuration File   C:\Program Files\PHP\5.2\php.ini
\end{lstlisting}

激活一个扩展后，保存 php.ini 文件并重启动 web 服务器，然后用 phpinfo() 再次查看确定，此时新的扩展应该有其自己的一节。

或者在命令行运行：

\begin{lstlisting}[language=bash]
drive:\\path\to\php\executable\php.exe -i
\end{lstlisting}

如果某扩展并未在 phpinfo() 中显示，应该查看日志以确定问题出在哪里。

\begin{compactitem}
\item 如果是在命令行使用 PHP（CLI），扩展加载出错信息会直接在屏幕显示。
\item 如果在Web服务器中使用 PHP，则日志文件的位置与格式各不相同。
\end{compactitem}

最常见的问题是 DLL 文件的位置，php.ini 中“extension\_dir”设定的值，以及编译时的设置不匹配。如果问题出在编译时设置不匹配，那可能所下载的 DLL 文件不对。可以尝试重新下载一个设置匹配的扩展。

阅读所使用的Web服务器之文档以确定日志文件的位置，这与 PHP 本身并无关系。此外， phpinfo() 可以起到很大帮助。



\end{compactitem}


有时可能需要将扩展库静态编译到 PHP 中。这需要将扩展库源程序放入 \texttt{php-src/ext/} 目录中去并告诉 PHP 编译系统来生成其配置脚本。


\begin{lstlisting}[language=bash]
$ cd /your/phpsrcdir/ext
$ pecl download extname
$ gzip -d < extname.tgz | tar -xvf -
$ mv extname-x.x.x extname
\end{lstlisting}

这将产生以下目录：

\begin{lstlisting}[language=bash]
/your/phpsrcdir/ext/extname
\end{lstlisting}

此时强制 PHP 重新生成配置脚本\footnote{要运行“buildconf”脚本，需要 autoconf 2.13 和 automake 1.4+（更新版本的 autoconf 也许能工作，但不被支持）。}，然后正常编译 PHP：

\begin{lstlisting}[language=bash]
$ cd /your/phpsrcdir 
$ rm configure
$ ./buildconf --force
$ ./configure --help
$ ./configure --with-extname --enable-someotherext --with-foobar
$ make
$ make install
\end{lstlisting}


是否用 \texttt{--enable-extname}或 \texttt{--with-extname}取决于扩展库。通常不需要外部库文件的扩展库使用\texttt{--enable}。要确认的话，在 \texttt{buildconf} 之后运行：

\begin{lstlisting}[language=bash]
$ ./configure --help | grep extname
\end{lstlisting}

\chapter{Installation}

There are two primary ways for adding support for PHP to a web server. For many web servers PHP has a direct module interface called Server Application Programming Interface (SAPI). These web servers include Apache HTTP Server, Microsoft IIS, Netscape (now defunct) and iPlanet. Some other web servers support the Internet Server Application Programming Interface (ISAPI), Microsoft's web server module interface (OmniHTTPd for example). If PHP has no module support for a web server, it can always be used as a Common Gateway Interface (CGI) or FastCGI processor. That way, web server is configured to use the CGI executable of PHP to process all requests to PHP files.


PHP-FPM (FastCGI Process Manager) is an alternative FastCGI implementation for PHP, bundled with the official PHP distribution since version 5.3.3. When compared to the older FastCGI implementation, it contains some additional features, mostly useful for heavily loaded web servers.

When using PHP for command-line scripting, a PHP command-line interface (CLI) executable is needed. PHP supports a CLI SAPI as of PHP 4.3.0. The main focus of this SAPI is developing shell applications using PHP. There are quite a few differences between the CLI SAPI and other SAPIs, although they do share many of the same behaviors.

PHP can also be used for writing desktop graphical user interface (GUI) applications, by using the PHP-GTK extension. PHP-GTK is not included in the official PHP distribution, and as an extension it can be used only with PHP versions 5.1.0 and newer. The most common way of installing PHP-GTK is compiling it from the source code.


When PHP is installed and used in cloud environments, software development kits (SDKs) are provided for using cloud-specific features. For example:


\begin{compactitem}
\item Amazon Web Services provides the AWS SDK for PHP
\item Windows Azure can be used with the Windows Azure SDK for PHP.
\end{compactitem}

Numerous configuration options are supported, affecting both core PHP features and extensions. Configuration file php.ini is searched for in different locations, depending on the way PHP is used. Configuration file is split into various sections, while some of the configuration options can be also set within the web server configuration.


在安装PHP之前，首先需要知道想用 PHP 来做什么，如果需要自己配置服务器和 PHP，一般有两个方法可以将 PHP 连接到服务器上。

PHP向Apache和IIS等Web服务器提供了一个直接的模块接口SAPI，其中IIS服务器支持微软的ISAPI，可以极大地提高IIS的性能。

ISAPI是驻留在Web服务器中的代码，而且和Apache模块的原理类似，ISAPI在首次调用时就会被载入内存，这样在以后的使用中就不会启动新的进程。



如果 PHP 不能作为模块支持 Web 服务器，总是可以将其作为 CGI 或 FastCGI 处理器来使用。这意味着可以使用 PHP 的 CGI 可执行程序来处理所有服务器上的 PHP 文件请求。

如果需要通过PHP 命令行脚本完成诸如在离线状态下，根据传递给脚本的参数，自动生成一些图片，或处理一些文本文件等的工作，那一定需要命令行可执行程序（CLI）。如果是这种情况，不需要服务器和浏览器。


\section{UNIX}

在 Unix 平台下安装 PHP时可以使用配置和编译过程，或是使用各种预编译的包。

如果用户需要与标准配置不同的功能（例如安全服务器，或者不同的数据库驱动扩展模块），可能需要编译 PHP 和/或Web服务器。

为了直接从 Git 源文件或者自己修改过的包进行编译，可能需要某些辅助工具。

\begin{compactitem}
\item autoconf：2.13+（PHP < 5.4.0），2.59+（PHP >= 5.4.0）
\item automake：1.4+
\item libtool：1.4.x+（除了 1.4.2）
\item re2c：版本 0.13.4 或更高
\item flex：版本 2.5.4（PHP <= 5.2）
\item bison：版本 1.28（建议），1.35 或 1.75
\end{compactitem}

Apache初始的配置和安装过程由configure 脚本中的一系列命令行选项控制，可以通过 \texttt{./configure --help}命令了解Apache所有可用的编译选项及简短解释。

在配置好Apache后，下一步就可以使用make命令来编译模块和/或可执行文件。


\begin{lstlisting}[language=bash]
# cd /src
# gzip -d httpd-2.4.12.tar.gz
# tar xvf httpd-2.4.12.tar
# cd httpd-2.4.12
# ./configure --help
\end{lstlisting}

一般情况下，可以直接使用Aapche的默认配置来进行编译。例如，这里将允许Apache加载DSO（Dynamic Shared Object）模块：


\begin{lstlisting}[language=bash]
# ./configure --enable-dso
# make
# make install
# /usr/local/apache2/bin/apachectl start
\end{lstlisting}


为了继续安装PHP和配置Apache，可以暂时停止Apahce服务。


\begin{lstlisting}[language=bash]
# /usr/local/apache2/bin/apachectl stop
\end{lstlisting}


在编译安装PHP之前，首先需要释放PHP的官方压缩包，然后进行PHP的配置。

\begin{lstlisting}[language=bash]
# cd /src
# gzip -d php-5.6.10.tar.gz
# tar xvf php-5.6.10.tar
\end{lstlisting}

Apache和PHP都被设计为模块化结构，因此可以配合各种不同的功能模块来进行工作，并且获得更多的扩展功能。

在编译PHP时可以手动配置编译选项来控制对应模块的使用，而且编译选项指定的模块必须事先已经安装，否则配置脚本将会报错。例如，下面的示例中中说明了编译PHP时的一些常见选项：

\begin{compactitem}
\item \texttt{--prefix}指定PHP的安装目录；
\item \texttt{--with-apxs2}用于提供对Apache2的动态共享模块的支持。
\end{compactitem}


\begin{lstlisting}[language=bash]
# cd php-5.6.10
# ./configure --prefix=/usr/local/php \
--with-apxs2=/usr/local/apache2/bin/apxs \
--with-zlib-dir=/usr/local/zlib2 \
--with-mysql=/usr/local/mysql \
--with-pgsql=/usr/local/pgsql \
\end{lstlisting}

在配置脚本检测通过后，就可以进行编译和安装，同样也可以重复上述步骤来改变编译选项。

\begin{lstlisting}[language=bash]
# make
# make install
\end{lstlisting}

在编译并安装PHP之后，接下来将建立配置php.ini，从而可以进一步修改PHP的选项。

默认情况下，配置阶段在/usr/local/lib目录下建立php.ini，因此可以使用configure命令的\texttt{--with-config-file-path=/path}选项来手动指定。

\begin{lstlisting}[language=bash]
# cp php.ini-production /usr/local/lib/php.ini
\end{lstlisting}


在Apache的httpd.conf中可以配置PHP，从而确保Apache可以调用PHP模块和解析PHP脚本文件。

\begin{lstlisting}[language=bash]
# cat >> httpd.conf
## 载入PHP5模块
LoadModule php5_module modules/libphp5.so
## 载入PHP4模块
LoadModule php4_module modules/libphp4.so

## 添加.php扩展名并进行解析
AddType application/x-httpd-php .php

## 添加.phps扩展来显示高亮的PHP源文件
AddType application/x-httpd-php-source .phps
\end{lstlisting}

在Windows操作系统中安装MySQL等数据库时，为了保持目录结构一致，同样也可以安装到c:\textbackslash usr\textbackslash local\textbackslash mysql，并且使用相应的配置工具来管理数据库服务。

在MySQL配置工具中，可以了解当前系统的运行状况，并提供系统环境、启动检测、服务器参数、配置文件、错误文件、系统变量、服务器进程、数据库和表结构以及综合报告等信息。

用户可以通过MySQL的配置文件my.ini对MySQL数据库服务器进行手动配置，并且在配置完毕后重启MySQL服务使其生效。

\begin{lstlisting}[language=bash]
#This file was made using the WinMySQLAdmin Tool

[mysqld]
port=3306
basedir=c:/usr/local/mysql
#bind-address=192.168.1.10
datadir=c:/usr/local/mysql/data
#tmpdir=
#set-variable=key_buffer=16M

[WinMySQLAdmin]
Server=c:/usr/local/mysql/bin/mysql-nt.exe
user=root
password=p@ss
\end{lstlisting}

在UNIX/Linux操作系统中安装MySQL时，可以考虑使用RPM自动安装包，或者从二进制文件进行安装，不需要自己手动编译，只需要将安全文件包释放到MySQL目录中。

为了提高MySQL的灵活性，在安装之前可以为其建立对应的用户和用户组。



\begin{lstlisting}[language=bash]
# addgroup mysql
# adduser -g mysql mysql
# cd src/
# gunzip < mysql-5.7.6-linux-glibc2.5-x86_64.tar.gz | tar xvf -
# ln -s mysql-5.7.6-linux-glibc2.5-x86_64 mysql
\end{lstlisting}

在MySQL的安装目录中包括程序文件和子目录等，而且必须将MySQL主目录添加到环境变量PATH中。

另外，在MySQL的子目录scripts中包含一个数据库初始化脚本，可以用来进行数据库初始化。

在使用root身份执行数据库初始化脚本mysql\_install\_db时，应该显式地使用“\texttt{--user}”指定MySQL的访问用户帐号。


\begin{lstlisting}[language=bash]
# cd mysql
# ./scripts/mysql_install_db --user=mysql
\end{lstlisting}

除此之外，还需要让root用户和mysql用户对MySQL目录获得适当的权限。

\begin{lstlisting}[language=bash]
# chown -R root /usr/local/mysql
# chown -R root /user/local/mysql/bin
# chown -R mysql /usr/local/mysql
# chgrp -R mysql /usr/local/mysql
\end{lstlisting}

在完成对MySQL的安装和设置后，可以启动MySQL数据库服务。

\begin{lstlisting}[language=bash]
# /usr/local/mysql/bin/mysql_safe --user=mysql &
\end{lstlisting}

为了在操作系统启动时自动启动MySQL服务，可以将“support/mysql.server”文件复制到系统的启动目录中。

\begin{lstlisting}[language=bash]

\end{lstlisting}




\begin{lstlisting}[language=bash]

\end{lstlisting}




\begin{lstlisting}[language=bash]

\end{lstlisting}




\section{Mac OSX}

Mac OS X有内建支持的 PHP，编译安装类似于 Unix 系统下的安装，也可以使用预编译和打包的 PHP 版本来安装标准配置的 PHP。

如果需要不同的功能集（比如安全服务器或不同的数据库驱动程序），可能需要自己编译 PHP 和/或Web服务器。

在默认的Web服务器中启用 PHP时，只需将 Apache 配置文件 \texttt{httpd.conf}中的若干配置指令前面的注释符号去掉，这样CGI或CLI 默认都可以使用（可以很容易的被终端程序使用）。


在搭建本地 PHP 开发环境时，标准的安装类型为 mod\_php，接下来在Apache Web服务器中启用 PHP时 包含以下的步骤：

\begin{compactenum}
\item 找到并打开Apache的配置文件。

默认情况下，这个配置文件的位置\footnote{在Mac OS X 10.5之前的版本中捆绑的是旧版本的 PHP 和 Apache。因此在旧的计算机中 Apache 配置文件的位置可能是 \texttt{/etc/httpd/httpd.conf}。}是： \texttt{/private/etc/apache2/httpd.conf}。 

\item 使用文本的编辑器取消注释。

\begin{lstlisting}[language=bash]
# LoadModule php5_module libexec/httpd/libphp5.so
...
# AddModule mod_php5.c
\end{lstlisting}

\item 确保将所需要的文件扩展名解析为 PHP。

确保将所需要的文件扩展名解析为 PHP（例如.php、.html 以及 .inc），否则不能正常运行。

自 Mac Panther开始，将以下的配置写入 httpd.conf后，只要PHP被启用就可以将.php文件自动解析为 PHP脚本。

\begin{lstlisting}[language=bash]
<IfModule mod_php5.c>
    # If php is turned on, we respect .php and .phps files.
    AddType application/x-httpd-php .php
    AddType application/x-httpd-php-source .phps

    # Since most users will want index.php to work we
    # also automatically enable index.php
    <IfModule mod_dir.c>
        DirectoryIndex index.html index.php
    </IfModule>
</IfModule>
\end{lstlisting}

\item 确保 DirectoryIndex 加载了所需的默认索引文件。

通常情况下，在httpd.conf中将DirectoryIndex设置为index.php 和 index.html，可以根据实际情况进行相应的调整。

\item 设置 php.ini 的位置或者使用默认的位置。

Mac OS X 上通常默认的位置是 \texttt{/usr/local/php/php.ini}，如果没有使用 php.ini，PHP 将使用所有的默认值。

\item 定位或者设置 DocumentRoot。

DocumentRoot是网站所有文件的根目录，该目录中的文件由Web服务器提供服务，从而使得 PHP 文件将在输出到浏览器之前解析为 PHP 脚本。

通常情况下，Web服务器的默认的路径是 /Library/WebServer/Documents，可以根据需要在 httpd.conf中设置为任何其他目录。

另外，用户自己的缺省 DocumentRoot 是 /Users/yourusername/Sites。

\item 创建\texttt{phpinfo()}文件。

phpinfo() 将会显示PHP的相关系统信息。例如，可以在 DocumentRoot 下创建一个 PHP 文件，其代码如下：

\indent \indent \verb|<?php phpinfo(); ?>|

\item 重启 Apache，然后从浏览器访问phpinfo文件。

要重启Apache，可以在 shell 中执行 \texttt{sudo apachectl graceful}，也可以停止/启动 OS X 系统首选项中的“Personal Web Server”选项。

默认情况下，从浏览器访问本地文件的 URL 一般类似于\texttt{http://localhost/info.php}，或者使用\verb|http://localhost/~yourusername/info.php|来访问用户自己 DocumentRoot 中的文件。


\end{compactenum}

CLI（或者旧版本中的 CGI）一般文件名为 php ，其路径可能是 /usr/bin/php。

用户可以打开一个终端并执行 \texttt{php -v}来检查当前运行的 PHP 的版本，在脚本中调用 phpinfo()也会显示相关的信息。



\section{Windows}



在安装PHP之前需要确保系统中已经安装好HTTP（Web）服务器，并确认其正常工作，而且不同的PHP版本的目录结构可能是不同的。


\begin{table}[htbp]
\centering
\caption{PHP5和PHP4的文件对应关系}

\begin{tabular}{|l|l|l|}
\hline
PHP5 & PHP4 &备注\\
\hline
php5ts.dll & php4ts.dll & 核心动态库\\
\hline
ext/php\_*.dll & extensions/php\_.*dll & PHP的扩展库文件\\
\hline
*.dll & dlls/*.dll & 其他扩展文件\\
\hline
php5apache.dll & sapi/php4apache.dll & Apache1.3.x模块\\
\hline
php5apache2.dll & sapi/php4apache2.dll & Apache 2.0.x模块\\
\hline
php5isapi.dll & sapi/php4isapi.dll & ISAPI模块，支持IIS\\
\hline
php.exe、php-win.exe& cli/php.exe& CLI可执行文件\\
\hline
php-cgi.exe & php.exe & CGI可执行文件\\
\hline
\end{tabular}
\end{table}




\subsection{Compile}

如果有开发环境（例如 Microsoft Visual Studio），那么也可以编译PHP的源程序来进行安装。

\begin{compactitem}
\item PHP 5.5.22/5.6.6使用Microsoft VC11编译，不支持Windows XP；
\item PHP 5.4.38使用Microsoft VC9 编译，支持Windows XP。
\end{compactitem}

为了和Linux下的PHP安装目录匹配，可以将PHP的安装目录指定为c:\textbackslash usr\textbackslash local\textbackslash php，同时也需要将PHP的安装目录加入系统的Path环境变量中。

\begin{lstlisting}[language=bash]
Windows  c:\usr\local\php
UNIX/Linux  /usr/local/php
\end{lstlisting}



在Windows系统下安装好PHP之后，可能还需要加载各种扩展库以实现更多的功能。

另外，虽然互联网上还有一些多合一的安装程序，但是它们没有一个是被PHP官方认可的，因此从\url{http://www.php.net/downloads.php}下载官方Windows 安装包是系统安全和优化的最好选择，然后就可以为IIS、PWS或Xitami安装CGI版本的PHP，并配置好Web服务器。

\subsection{Install}


PHP官方安装程序支持两种安装类型（标准和高级），并且安装向导在安装过程中会收集足够的信息来设置 php.ini 文件，然后配置好Web服务器来使用 PHP。


\begin{compactitem}
\item 标准：使用合理的默认配置进行安装；
\item 高级：在配置中询问相关问题。
\end{compactitem}

一般情况下，在PHP安装完成后会提示重新启动系统，并重启服务器，或直接开始使用 PHP。

\subsection{Manual}


虽然 Windows 安装程序是让 PHP 工作的最容易的方法，但是它有很多限制。例如，它不支持自动安装 PHP 扩展，因此使用安装程序安装 PHP 不是最佳方式，而且PHP官方安装程序不包含任何外部的 PHP 扩展（PHP\_*.dll）。如果需要，可以在 Windows ZIP 包和 PECL中找到。

旧版本的PHP安装程序不能自动配置 Apache，因此需要手动进行配置，而且使用Windows安装程序来安装的PHP不是安全的。

如果需要一个安全的 PHP 设置，最好使用手动方式安装，并手动设置好每个选项，这样就可以将PHP用于在线的生产服务器中。

PHP的Windows安装程序是用 Wix 工具包（\url{http://wix.sourceforge.net/}）基于 MSI 建立的，使用这种方式安装PHP时，首先会提示选择要配置的Web服务器，以及所需的任何配置细节，然后它将安装并配置 PHP 和所有内置以及 PECL 扩展库，并且配置相关的Web服务器（例如 IIS、Apache以及 Xitami）。

在安装并激活相关特性和扩展时，每个项目的下拉菜单中需要选择“Will be installed on local hard drive”来激活安装该单个项目。

如果选择“Entire feature will be installed on local hard drive”，将会安装所有该项目的子项（例如对“PDO”选择了此选项，则会安装所有的 PDO 驱动）\footnote{事实上，并不推荐安装所有的扩展库，因为其中许多库还需要 PHP 之外的支持才能正常工作。不过，在安装好之后，可以从控制面板的程序和功能里可以调出更改模式来激活或关闭某扩展和功能。}。

在接下来设定 Windows 使用的 PHP 和 php.ini 文件时，可以配置特定的Web服务器使用 PHP，也可以通过手工配置来支持其他的Web服务器。


新版本PHP的安装程序支持无声模式，有助于系统管理员更容易发布 PHP。例如，可以使用下面的命令来使用无声模式：

\begin{lstlisting}[language=bash]
msiexec.exe /i php-VERSION-win32-install.msi /q
\end{lstlisting}

在不同的服务器环境中，可以根据实际需要将安装目录作为命令行参数传递给安装程序，例如下面的命令将PHP安装到 c:{\textbackslash}php：

\begin{lstlisting}[language=bash]
msiexec.exe /i php-VERSION-win32-install.msi /q INSTALLDIR=c:\php
\end{lstlisting}

另外，可以用同样的语法指定 Apache 配置目录（APACHEDIR）、Sambar 服务器目录（SAMBARDIR）以及 Xitami 服务器目录（XITAMIDIR），而且还可以指定安装哪些特性。例如，下面的命令说明要安装 mysqli 扩展和 CGI 可执行程序：

\begin{lstlisting}[language=bash]
msiexec.exe /i php-VERSION-win32-install.msi /q ADDLOCAL=cgi,ext_php_mysqli
\end{lstlisting}


在Windows中，可安装的PHP特性列表如下：

\begin{compactitem}
\item MainExecutable - php.exe可执行文件（默认已包含）
\item ScriptExecutable - php-win.exe可执行文件
\item ext\_php\_* - 扩展库（例如MySQL 是 ext\_php\_mysql）
\item apache13 - Apache 1.3 模块
\item apache20 - Apache 2.0 模块
\item apache22 - Apache 2.2 模块
\item apacheCGI - Apache CGI 可执行文件
\item iis4ISAPI - IIS ISAPI 模块
\item iis4CGI - IIS CGI 可执行文件
\item iis4FastCGI - IIS CGI 可执行文件
\item NSAPI - Sun/iPlanet/Netscape 服务器模块
\item netserve - NetServe Web 服务器之 CGI 可执行文件
\item Xitami - Xitami CGI 可执行文件
\item Sambar - Sambar 服务器 ISAPI 模块
\item CGI - php-cgi.exe 可执行文件
\item PEAR - PEAR 安装程序
\item Manual - CHM 格式的 PHP 手册
\end{compactitem}

\subsection{Update}


如果要升级 PHP，可以正常使用图形模式或者从命令行运行安装程序，可以看到安装程序会读取当前安装的选项，移除旧的安装，并用同样选项重新安装 PHP，因此建议用这种方式更新PHP而不是手工替换安装目录下的文件。


\subsection{Extend}


在 Windows 下安装好PHP 和Web 服务器之后，可能想要安装一些扩展库来获得更多功能。

PHP扩展库的 DLL 文件都具有 \texttt{php\_} 前缀，可以通过修改 php.ini 来选择当 PHP 启动时加载哪些扩展库，也可以在脚本中通过使用\texttt{dl()}来动态加载。



很多扩展库都内置于 Windows 版的 PHP 之中，这意味着要加载这些扩展库，额外的 DLL 文件和 extension 配置指令都不需要。

Windows 下的 PHP 扩展库列表列出了需要或曾经需要额外 PHP DLL 文件的扩展库，而且PHP 搜索扩展库的默认位置在不同的PHP版本中是不同的。

\begin{compactitem}
\item PHP 4 中是 drive:{\textbackslash}php4{\textbackslash}extensions；
\item PHP 5 中是 drive:{\textbackslash}php5。
\end{compactitem}

在php.ini文件\footnote{如果运行服务器模块版的 PHP，在修改了 php.ini 之后别忘了重新启动 web 服务器以使其改动生效。}可以根据用户自己的 PHP 设置来修改扩展目录。 


\begin{compactitem}
\item 修改 extension\_dir 设置以指向用户放置扩展库的目录或者说放置 php\_*.dll 文件的位置。

\begin{lstlisting}[language=bash]
extension_dir = drive:\php\extensions
\end{lstlisting}

\item 启用指定的扩展库，需要去掉php.ini中该行\texttt{extension=php\_*.dll}前的注释符号（;）。

\begin{lstlisting}[language=bash]
// 将这一行
;extension=php_bz2.dll

// 改成这样
extension=php_bz2.dll
\end{lstlisting}

\item 有些扩展库需要额外的 DLL 才能工作。

对于Oracle（php\_oci8.dll）等所需要的 DLL 没有绑定在发行包里的情况，可以将绑定的 DLL 从 drive:{\textbackslash}php{\textbackslash}dlls 拷贝到主目录 drive:{\textbackslash}php中，并且需要将 drive:{\textbackslash}php 放到系统路径 PATH 中去。

\item 某些 DLL 没有绑定在 PHP 发行包中，例如PECL提供的PHP 扩展库需要单独下载。
\end{compactitem}

下表说明了哪些扩展库需要额外的 DLL。

\zihao{6}

\begin{longtable}{|m{60pt}|m{130pt}|m{200pt}|}
%head
\multicolumn{3}{r}{}
\tabularnewline\hline
扩展库	&说明	&注解
\endhead
%endhead

%firsthead
\caption{PHP 扩展库}\\
\hline
扩展库	&说明	&注解
\endfirsthead
%endfirsthead

%foot
\multicolumn{3}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot
\hline
php\_bz2.dll				&bzip2 压缩函数		&无\\
\hline
php\_calendar.dll		&Calendar 日历转换函数	&自 PHP 4.0.3 起内置\\
\hline
php\_crack.dll			&Crack 密码破解函数	&无\\
\hline
php\_ctype.dll			&ctype 家族函数		&自 PHP 4.3.0 起内置\\
\hline
php\_curl.dll				&CURL，客户端 URL 库函数	&需要：libeay32.dll，ssleay32.dll（已附带）\\
\hline
php\_dba.dll				&DBA：数据库（dbm 风格）抽象层函数	&无\\
\hline
php\_dbase.dll			&dBase 函数	&无\\
\hline
php\_dbx.dll				&dbx 函数	 	&\\
\hline
php\_domxml.dll			&PHP 4 DOM XML 函数	&PHP <= 4.2.0 需要：libxml2.dll（已附带），PHP >= 4.3.0 需要：iconv.dll（已附带）\\
\hline
php\_dotnet.dll			&.NET 函数	&PHP <= 4.1.1\\
\hline
php\_exif.dll				&EXIF 函数	&需要 php\_mbstring.dll。并且在 php.ini 中，php\_exif.dll 必须在 php\_mbstring.dll 之后加载\\
\hline
php\_fbsql.dll			&FrontBase 函数	&PHP <= 4.2.0\\
\hline
php\_fdf.dll				&FDF：表单数据格式化函数	&需要：fdftk.dll（已附带）\\
\hline
php\_filepro.dll			&filePro 函数	&只读访问\\
\hline
php\_ftp.dll				&FTP 函数	&自 PHP 4.0.3 起内置\\
\hline
php\_gd.dll				&GD 库图像函数	&在 PHP 4.3.2 中移除。此外注意在 GD1 中不能用真彩色函数，用 php\_gd2.dll替代。\\
\hline
php\_gd2.dll				&GD 库图像函数	&GD2\\
\hline
php\_gettext.dll			&Gettext 函数	&PHP <= 4.2.0 需要 gnu\_gettext.dll（已附带），PHP >= 4.2.3 需要 libintl-1.dll， iconv.dll（已附带）\\
\hline
php\_hyperwave.dll		&HyperWave 函数	&无\\
\hline
php\_iconv.dll			&ICONV 字符集转换	&需要：iconv-1.3.dll（已附带），PHP >=4.2.1 需要 iconv.dll\\
\hline
php\_ifx.dll				&Informix 函数	&需要：Informix 库\\
\hline
php\_iisfunc.dll			&IIS 管理函数库	&无\\
\hline
php\_imap.dll			&IMAP，POP3 和 NNTP 函数	&无\\
\hline
php\_ingres.dll			&Ingres II 函数	&需要：Ingres II 库\\
\hline
php\_interbase.dll		&InterBase 函数	&需要：gds32.dll（已附带）\\
\hline
php\_java.dll				&Java 函数	&PHP <= 4.0.6 需要：jvm.dll（已附带）\\
\hline
php\_ldap.dll			&LDAP 函数	&PHP <= 4.2.0 需要 libsasl.dll（已附带），PHP >= 4.3.0 需要 libeay32.dll，ssleay32.dll（已附带）\\
\hline
php\_mbstring.dll		& Multi-Byte String 多字节字符串函数	&无\\
\hline
php\_mcrypt.dll			& Mcrypt 加密函数	&需要：libmcrypt.dll\\
\hline
php\_mhash.dll			& Mhash 函数	&PHP >= 4.3.0 需要：libmhash.dll（已附带）\\
\hline
php\_mime\_magic.dll		& Mimetype 函数	&需要：magic.mime（已附带）\\
\hline
php\_ming.dll			& Ming 函数（Flash）	&无\\
\hline
php\_msql.dll			&mSQL 函数	&需要：msql.dll（已附带）\\
\hline
php\_mssql.dll			& MSSQL 函数	&需要：ntwdblib.dll（已附带）\\
\hline
php\_mysql.dll			& MySQL 函数	&PHP >= 5.0.0 需要 libmysql.dll（已附带）\\
\hline
php\_mysqli.dll			& MySQLi 函数	&PHP >= 5.0.0 需要 libmysql.dll（PHP <= 5.0.2 中是 libmysqli.dll）（已附带）\\
\hline
php\_oci8.dll			&Oracle 8 函数	&需要：Oracle 8.1+ 客户端库\\
\hline
php\_openssl.dll			&OpenSSL 函数	&需要：libeay32.dll（已附带）\\
\hline
php\_overload.dll		&PHP 4 对象过载函数	&自 PHP 4.3.0 起内置，自 PHP 5.0.0 起移除\\
\hline
php\_pdf.dll				&PDF 函数	&无\\
\hline
php\_pgsql.dll			&PostgreSQL 函数	&无\\
\hline
php\_printer.dll			&Printer 打印机函数	&无\\
\hline
php\_shmop.dll			&Shared Memory 共享内存函数	&无\\
\hline
php\_snmp.dll			&SNMP 函数	&仅用于 Windows NT！\\
\hline
php\_soap.dll			&SOAP 函数	&PHP >= 5.0.0\\
\hline
php\_sockets.dll			&Socket 函数	&无\\
\hline
php\_sybase\_ct.dll		&Sybase 函数	&需要：Sybase 客户端库\\
\hline
php\_tidy.dll				&Tidy 函数	&PHP >= 5.0.0\\
\hline
php\_tokenizer.dll		&Tokenizer 函数	&自 PHP 4.3.0 起内置\\
\hline
php\_w32api.dll			&W32api 函数	&无\\
\hline
php\_xmlrpc.dll			&XML-RPC 函数	&PHP >= 4.2.1 需要 iconv.dll（已附带）\\
\hline
php\_xslt.dll				&XSLT 函数	&PHP <= 4.2.0 需要 sablot.dll，expat.dll（已附带）。PHP >= 4.2.1 需要 sablot.dll，expat.dll，iconv.dll（已附带）。\\
\hline
php\_yaz.dll				&YAZ 函数	&需要：yaz.dll（已附带）\\
\hline
php\_zip.dll				&Zip 文件函数	&只读访问\\
\hline
php\_zlib.dll				&ZLib 压缩函数	&自 PHP 4.3.0 起内置\\
\hline
\end{longtable}

\zihao{5}





\subsection{Config}

Apache支持以CGI或Apache模块的方式运行PHP，它们是基于对Apache不同的配置方案来完成的。

对Apache服务器的配置主要是通过修改httpd.conf来实现的。例如，如果需要以CGI方式运行PHP5，那么需要向httpd.conf中添加如下的代码：

\begin{lstlisting}[language=bash]
# 设置PHP目录的别名
ScriptAlias /php/ "c:/usr/local/php/''

# 关联特定的扩展名，以解析PHP文件
AddType application/x-httpd-php .php

# 设置使用PHP5执行CGI脚本的程序
Action application/x-httpd-php "/php/php-cgi.exe"
\end{lstlisting}

对于PHP4，则需要在httpd.conf中添加下面的代码：


\begin{lstlisting}[language=bash]
ScripteAlias /php/ "c:/usr/local/php/"
AddType application/x-httpd-php .php

# 设置使用PHP4执行CGI脚本的顺序
Action application/x-httpd-ph "/php/php.exe"
\end{lstlisting}

如果以Apache模块的方式来运行PHP5，则需要在httpd.conf中添加下面的代码：


\begin{lstlisting}[language=bash]
# 载入PHP5模块
LoadModule php5_module "c:/usr/local/php/php5apache2.dll"
AddType application/x-httpd-php .php

# 配置php.ini的路径
PHPIniDir "c:/usr/local/php"
\end{lstlisting}


如果Apache模块的方式来运行PHP4，则需要将php4apache2.dll从sapi目录中拷贝到PHP安装目录下，并且在httpd.conf中添加下面的代码：

\begin{lstlisting}[language=bash]
# 载入PHP4模块
LoadModule php4_module "c:/usr/local/php/php4apache2.dll"
AddType application/x-httpd-php .php

# 配置php.ini的路径
PHPIniDir "c:/usr/local/php"
\end{lstlisting}

默认情况下，Apache提供的Web虚拟目录为Apache安装目录下的htdocs目录。

为了测试PHP在Apache服务器中运行是否正常，可以在Web虚拟目录（即htdocs）中创建下面的测试文件，并且在浏览器中通过\url{http://localhost/phpinfo.php}进行访问。



\begin{lstlisting}[language=bash]
<?php
phpinfo();
?>
\end{lstlisting}

IIS支持以CGI或ISAPI模块的方式集成PHP。


\begin{compactitem}
\item 如果以CGI方式集成PHP，可以将PHP映射到CGI执行程序（例如php-cgi.exe）。
\item 如果以ISAPI方式集成PHP，可以将PHP映射到ISAPI模块（例如php5isapi.dll）。
\end{compactitem}

另外，如果用户需要使用PHP的HTTP认证功能，则需要在ISAPI筛选器中设置PHP的筛选器（例如php5isapi.dll）。

\subsection{Regedit}


在Windows服务器上进行设置时也可以通过注册表来对PHP进行配置。

为了保护注册表安全，可以使用注册表文件的方式来向注册表中添加新内容。例如，下面的注册表文件可以用来以ISAPI方式配置IIS服务器：


\begin{lstlisting}[language=bash]
Windows Registry Editor Version 5.0
[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\w3svc\parameters\Script Map]
".php"="c:\\usr\\local\\php\\php5isapi.dll"
\end{lstlisting}

如果以CGI方式配置PHP，则需要使用下面的注册表文件：




\begin{lstlisting}[language=bash]
Windows Registry Editor Version 5.0
[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\w3svc\parameters\Script Map]
".php"="c:\\usr\\local\\php\\php-cgi.exe"
\end{lstlisting}

在对IIS进行设置后，需要重启IIS服务器来使修改生效。




\begin{lstlisting}[language=bash]

\end{lstlisting}




\begin{lstlisting}[language=bash]

\end{lstlisting}





\begin{lstlisting}[language=bash]

\end{lstlisting}





\begin{lstlisting}[language=bash]

\end{lstlisting}





\begin{lstlisting}[language=bash]

\end{lstlisting}




\begin{lstlisting}[language=bash]

\end{lstlisting}





\begin{lstlisting}[language=bash]

\end{lstlisting}


\chapter{Accelerator}


\section{Overview}



通常情况下，PHP都是解释执行的，不过也可以通过特定的工具（例如加速器）来将PHP代码编译为中间字节码来获得更好的性能。


在Web应用系统中，加速器本身是一个加快访问速度的代理服务器，使用硬件或软件来实现。

Web加速器可以安装在客户端、移动设备以及ISP服务器上，并且对数据进行压缩等操作后传输给用户。

PHP加速器可以被设计为PHP扩展来增强性能，而且大多数PHP加速器都是将PHP程序和模块编译为可直接执行的opcode/bytecode并缓存，这样在需要调用 PHP 来处理客户端请求可以直接读取来加快处理速度。





\subsection{eAccelerator}



为了更进一步提高性能，可以将opcode/bytecode载入内存缓冲区，这样就可以从内存直接执行，从而减小在运行时从硬盘读取和从内存拷贝的限制。




例如，从 Turck MMCache 衍生的 eAccelerator 可以将 PHP 程序、PHP 核心和相关库函数预先编译后缓存在共享内存中，在需要时可以被重复使用，从而实现加速 PHP 程序的目的。


\begin{lstlisting}[language=bash]
# tar -jxvf eaccelerator.tar.gz
# cd
eaccelerator
# phpize
# ./configure--enable-eaccelerator=shared --with-php-config=/usr/bin/php-config
# make
# make install
\end{lstlisting}


默认情况下，新编译安装的模块位于/usr/lib64/php/modules/中。

为了预先加载扩展 PHP 模块，可以在/etc/ld.so.conf.d/中创建 ls.so.conf 文件，并新增如下配置:



\begin{lstlisting}[language=bash]
# vim /etc/ld.so.conf.d/ld.so.conf
/usr/lib64/php/modules
# ldconfig
\end{lstlisting}

eAccelerator 根据当前版本的 PHP 核心进行编译，因此在更新 PHP 后需要手动更新eAccelerator，并且每次都要在/etc/php.ini 中添加eAccelerator的配置信息，或者在/etc/php.d/中创建 eAccelerator的配置文件。




\begin{lstlisting}[language=bash]
;;;;;;;;;;;;;;;;;;;;;
; http://eaccelerator.net/
; date:
;;;;;;;;;;;;;;;;;;;;;
extension="eaccelerator.so''
eaccelerator.shm_size="16''
eaccelerator.cache_dir="/tmp/eaccelerator"
eaccelerator.enable="1''
eaccelerator.optimizer="1''
eaccelerator.check_mtime="1''
eaccelerator.debug="0"
eaccelerator.filter=""
eaccelerator.shm_max="0"
eaccelerator.shm_ttl="0"
eaccelerator.shm_prune_period="0''
eaccelerator.shm_only="0"
eaccelerator.compress="1''
eaccelerator.compress_level="9"
\end{lstlisting}


如果要检查 eAccelerator 模块的运行状态，可以使用 phpinfo()函数或 php -i 进行查询。

对于存放 eAccelerator 的临时文件的目录要注意设置适当的权限，并且在重启服务器才能使用 eAccelerator。



\begin{lstlisting}[language=bash]
# mkdir /tmp/eaccelerator
# chmod 777 /tmp/eaccelerator
# apachectl restart
\end{lstlisting}


除了可以把将 PHP 编译产生的 bytecode 暂存在共享内存内重复使用来提高执行效率，Alternative PHP Cache（APC）还可以对中间码进行优化来和所有版本的 PHP 协同使用。



\begin{lstlisting}[language=bash]
# pecl install APC
downloading APC-3.1.13.tgz ...
Starting to download APC-3.1.13.tgz （171，591 bytes）
....done: 171,591 bytes
55 source files, building
running: phpize
Configuring for:
PHP Api Version: 20121113
Zend Module Api No: 20121212
Zend Extension Api No: 220121212
Enable internal debugging in APC [no] : yes
Enable per request file info about files used from the APC cache [no] : yes
Enable spin locks （EXPERIMENTAL） [no] : yes
Enable memory protection （EXPERIMENTAL） [no] : yes
Enable pthread mutexes （default） [no] : yes
Enable pthread read/write locks （EXPERIMENTAL） [yes] : yes
...
\end{lstlisting}

由 Lighttpd 计划提供的 XCache 解决了其他 opcacher 存在的问题（比如可以支持新的 PHP 版本），并且在 Linux 下可以支撑高负载状况，另外还支持 ThreadSafe/Windows。






\section{Encoder}



默认情况下，PHP源代码是可以从服务器上直接读取的，这样虽然可以提高PHP的弹性，但是也相对会造成安全危机和性能下降等问题。

PHP编码器可以对PHP代码进行编码来保护PHP源代码不被读取，也可以提升运行的性能，因此使用PHP编码器（例如Zend提供的脚本优化器）将PHP程序编译成字节码（byte code），然后再通过服务器上安装对应的程序来运行PHP脚本。


除了通过编码器加速之外，PHP还可以通过动态的高速缓存机制来提升速度。





\section{Engine}

模板引擎让PHP应用程序可以实现逻辑和使用界面上的分离，让程序开发更容易进行。例如，Smarty是使用PHP实现的模板系统，可以简化PHP应用程序的开发过程，其核心模板引擎可以通过标签来创建Web组件。


不过模板引擎存在性能方面的争议，因为PHP本身就是一个模板引擎，使用模板引擎反而变成“重新发明了轮子”。

模板引擎最主要的好处就是让不懂PHP代码的人也可以参与使用界面的开发，因为模板引擎的语言远比PHP简单。例如，MVC模式就是对模板引擎的最好应用，从而可以让PHP编程人员可以和HTML前端程序员分工合作。



\section{Compiler}



Facebook在2010年发布的HipHop编译器可以把PHP源代码编译成C++来提高速度，并且降低CPU的负载。






\section{FastCGI}


在某些服务器条件下可能不支持以Apache服务器模块的方式运行PHP，因此必须考虑使用CGI或FastCGI的方式。


FastCGI（Fast Common Gateway Interface）是早期通用网关接口（CGI）的增强版本，可以让交互程序与 Web 服务器通信。

FastCGI 致力于减少网页服务器与 CGI 程序之间交互的开销，从而使服务器可以同时处理更多的网页请求。

CGI 程序运行在独立的进程中，并对每个 Web 请求建立一个进程，虽然这种方法非常容易实现，但效率很差且难以扩展，在处理大量请求时，进程的大量建立和消亡使操作系统性能大大下降，另外地址空间无法共享也限制了资源重用。

与 CGI 为每个请求创建一个新的进程不同，FastCGI 使用持续的进程来处理一连串的请求，而且这些进程由 FastCGI 服务器管理（而不是 Web 服务器）。例如，Apache HTTP Server 通过 mod_fcgid 模块实现了 FastCGI。

当接收到一个请求时，Web 服务器把环境变量和页面请求通过一个 socket（比如FastCGI 进程与 Web 服务器都位于本地）或者一个 TCP connection（FastCGI 进程在远端的 Server Farm）传递给 FastCGI 进程。

\section{PHP-FPM}

FPM (FastCGI 进程管理器) 是一个可选的 PHP FastCGI 实现，并且附加了一些（主要是）对高负载网站很有用的特性。

PHP-FPM（FastCGI进程管理器）用于替换 PHP FastCGI 的大部分附加功能，对于高负载网站是非常有用的。

具体说来，FPM的功能包括：

\begin{compactitem}
\item 支持平滑停止/启动的高级进程管理功能；

\item 可以工作于不同的 uid/gid/chroot 环境下，并监听不同的端口和使用不同的 php.ini 配置文件（可取代 safe\_mode 的设置）；

\item stdout 和 stderr 日志记录;

\item 在发生意外情况的时候能够重新启动并缓存被破坏的 opcode;

\item 文件上传优化支持;

\item ``慢日志" - 记录脚本（不仅记录文件名，还记录 PHP backtrace 信息，可以使用 ptrace或者类似工具读取和分析远程进程的运行数据）运行所导致的异常缓慢;

\item \texttt{fastcgi\_finish\_request()} - 特殊功能：用于在请求完成和刷新数据后，继续在后台执行耗时的工作（录入视频转换、统计处理等）；

\item 动态/静态子进程产生；

\item 基本 SAPI 运行状态信息（类似Apache的 mod\_status）；

\item 基于 php.ini 的配置文件。

\end{compactitem}

编译 PHP 时需要 \texttt{--enable-fpm} 配置选项来激活 FPM 支持。以下为 FPM 编译的具体配置参数（全部为可选参数）：

\begin{compactitem}
\item \texttt{--with-fpm-user} - 设置 FPM 运行的用户身份（默认 - nobody）

\item \texttt{--with-fpm-group} - 设置 FPM 运行时的用户组（默认 - nobody）

\item \texttt{--with-fpm-systemd} - 启用 systemd 集成 (默认 - no)

\item \texttt{--with-fpm-acl}- 使用POSIX 访问控制列表 (默认 - no) 5.6.5版本起有效
\end{compactitem}

FPM 配置文件为 php-fpm.conf，其语法类似 php.ini 。


\begin{compactitem}
\item php-fpm.conf 全局配置段

\begin{compactitem}
\item \texttt{pid string}

PID文件的位置。默认为空。

\item \texttt{error\_log string}

错误日志的位置。默认安装路径 \texttt{\#INSTALL\_PREFIX\#/log/php-fpm.log}。

\item \texttt{log\_level string}

错误级别。可用级别为：\texttt{alert}（必须立即处理），\texttt{error}（错误情况），\texttt{warning}（警告情况），\texttt{notice}（一般重要信息），\texttt{debug}（调试信息）。默认：\texttt{notice}。

\item \texttt{emergency\_restart\_threshold int}

如果子进程在 \texttt{emergency\_restart\_interval} 设定的时间内收到该参数设定次数的 \texttt{SIGSEGV} 或者 \texttt{SIGBUS}退出信息号，则FPM会重新启动。0 表示“关闭该功能”。默认值：0（关闭）。

\item \texttt{emergency\_restart\_interval mixed}

\texttt{emergency\_restart\_interval}用于设定平滑重启的间隔时间。这么做有助于解决加速器中共享内存的使用问题。可用单位：s（秒），m（分），h（小时）或者 d（天）。默认单位：s（秒）。默认值：0（关闭）。

\item \texttt{process\_control\_timeout mixed}

设置子进程接受主进程复用信号的超时时间。可用单位：s（秒），m（分），h（小时）或者 d（天）。默认单位：s（秒）。默认值：0（关闭）。

\item \texttt{daemonize boolean}

设置 FPM 在后台运行。设置“no”将 FPM 保持在前台运行用于调试。默认值：yes。

\end{compactitem}

\item 运行配置区段

在FPM中，可以使用不同的设置来运行多个进程池。 这些设置可以针对每个进程池单独设置。

\begin{compactitem}
\item \texttt{listen string}

设置接受 FastCGI 请求的地址。可用格式为：\texttt{'ip:port'}，\texttt{'port'}，\texttt{'/path/to/unix/socket'}。每个进程池都需要设置。

\item \texttt{listen.backlog int}
设置 \texttt{listen(2)}的半连接队列长度。“-1”表示无限制。默认值：-1。

\item \texttt{listen.allowed\_clients string}

设置允许连接到 FastCGI 的服务器 IPV4 地址。等同于 PHP FastCGI (5.2.2+) 中的 \texttt{FCGI\_WEB\_SERVER\_ADDRS}环境变量。仅对 TCP 监听起作用。每个地址是用逗号分隔，如果没有设置或者为空，则允许任何服务器请求连接。默认值：\texttt{any}。

\item \texttt{listen.owner string}

如果使用，表示设置 Unix 套接字的权限。在Linux中，读写权限必须设置，以便用于 WEB 服务器连接。在很多 BSD 派生的系统中可以忽略权限允许自由连接。默认值：运行所使用的用户和组，权限为 0666。

\item \texttt{listen.group string}

参见 \texttt{listen.owner}。

\item \texttt{listen.mode string}

参见 \texttt{listen.owner}。

\item \texttt{user string}

FPM 进程运行的Unix用户。必须设置。

\item \texttt{group string}

FPM 进程运行的 Unix 用户组。如果没有设置，则默认用户的组被使用。

\item \texttt{pm string}

设置进程管理器如何管理子进程。可用值：\texttt{static}，\texttt{ondemand}，\texttt{dynamic}。必须设置。

\begin{compactitem}
\item \texttt{static} - 子进程的数量是固定的（\texttt{pm.max\_children}）。
\item \texttt{ondemand} - 进程在有需求时才产生（当请求时，与 \texttt{dynamic}相反，\texttt{pm.start\_servers}在服务启动时即启动。
\item \texttt{dynamic} - 子进程的数量在下面配置的基础上动态设置：\texttt{pm.max\_children}，\texttt{pm.start\_servers}，\texttt{pm.min\_spare\_servers}，\texttt{pm.max\_spare\_servers}。
\end{compactitem}


\item \texttt{pm.max\_children int}

\texttt{pm}设置为\texttt{static}时表示创建的子进程的数量，\texttt{pm}设置为\texttt{dynamic}时表示最大可创建的子进程的数量。必须设置。

该选项设置可以同时提供服务的请求数限制。类似 Apache 的 \texttt{mpm\_prefork}中 \texttt{MaxClients}的设置和普通PHP FastCGI中的 \texttt{PHP\_FCGI\_CHILDREN}环境变量。

\item \texttt{pm.start\_servers in}

设置启动时创建的子进程数目。仅在\texttt{pm}设置为\texttt{dynamic}时使用。默认值：\texttt{min\_spare\_servers + (max\_spare\_servers - min\_spare\_servers) / 2}。

\item \texttt{pm.min\_spare\_servers int}

设置空闲服务进程的最低数目。仅在\texttt{pm}设置为\texttt{dynamic}时使用。必须设置。

\item \texttt{pm.max\_spare\_servers int}

设置空闲服务进程的最大数目。仅在\texttt{pm}设置为\texttt{dynamic}时使用。必须设置。

\item \texttt{pm.max\_requests int}

设置每个子进程重生之前服务的请求数。对于可能存在内存泄漏的第三方模块来说是非常有用的。如果设置为 '0' 则一直接受请求，等同于 \texttt{PHP\_FCGI\_MAX\_REQUESTS}环境变量。默认值：0。

\item \texttt{pm.status\_path string}

FPM 状态页面的网址。如果没有设置，则无法访问状态页面，默认值：无。

\item \texttt{ping.path string}

FPM 监控页面的 ping 网址。如果没有设置，则无法访问 ping 页面。该页面用于外部检测 FPM 是否存活并且可以响应请求。请注意必须以斜线开头（/）。

\item \texttt{ping.response string}

用于定义 ping 请求的返回响应。返回为 HTTP 200 的 text/plain 格式文本。默认值：\texttt{pong}。

\item \texttt{request\_terminate\_timeout mixed}

设置单个请求的超时中止时间。该选项可能会对 php.ini 设置中的 \texttt{'max\_execution\_time'}因为某些特殊原因没有中止运行的脚本有用。设置为 \texttt{'0'} 表示 \texttt{'Off'}。可用单位：s（秒），m（分），h（小时）或者 d（天）。默认单位：s（秒）。默认值：0（关闭）。

\item \texttt{request\_slowlog\_timeout mixed}

当一个请求该设置的超时时间后，就会将对应的 PHP 调用堆栈信息完整写入到慢日志中。设置为 \texttt{'0'}表示 \texttt{'Off'}。可用单位：s（秒），m（分），h（小时）或者 d（天）。默认单位：s（秒）。默认值：0（关闭）。

\item \texttt{slowlog string}

慢请求的记录日志。默认值：\texttt{\#INSTALL\_PREFIX\#/log/php-fpm.log.slow}。

\item \texttt{rlimit\_files int}

设置文件打开描述符的 rlimit 限制。默认值：系统定义值。

\item \texttt{rlimit\_core int}

设置核心 \texttt{rlimit}最大限制值。可用值：\texttt{'unlimited'}，0 或者正整数。默认值：系统定义值。

\item \texttt{chroot string}

启动时的 Chroot 目录。所定义的目录需要是绝对路径。如果没有设置，则 chroot 不被使用。

\item \texttt{chdir string}

设置启动目录，启动时会自动 Chdir 到该目录。所定义的目录需要是绝对路径。默认值：当前目录，或者根目录（chroot时）。

\item \texttt{catch\_workers\_output boolean}

重定向运行过程中的 \texttt{stdout}和\texttt{stderr}到主要的错误日志文件中。如果没有设置，\texttt{stdout}和\texttt{stderr}将会根据 FastCGI 的规则被重定向到\texttt{/dev/null}。默认值：无。

\end{compactitem}

\end{compactitem}

还可以在为一个运行池传递附加的环境变量，或者更新 PHP 的配置值。可以在 php-fpm.conf 中如下面的配置参数来做到：

\begin{lstlisting}[language=bash]
env[HOSTNAME] = $HOSTNAME
       env[PATH] = /usr/local/bin:/usr/bin:/bin
       env[TMP] = /tmp
       env[TMPDIR] = /tmp
       env[TEMP] = /tmp

       php_admin_value[sendmail_path] = /usr/sbin/sendmail -t -i -f www@my.domain.com
       php_flag[display_errors] = off
       php_admin_value[error_log] = /var/log/fpm-php.www.log
       php_admin_flag[log_errors] = on
       php_admin_value[memory_limit] = 32M
\end{lstlisting}

PHP配置值通过 \texttt{php\_value}或者\texttt{php\_flag}设置，并且会覆盖以前的值。注意\texttt{disable\_functions}或者\texttt{disable\_classes}在 php.ini 之中定义的值不会被覆盖掉，但是会将新的设置附加在原有值的后面。

使用 \texttt{php\_admin\_value}或者\texttt{php\_admin\_flag}定义的值，不能被 PHP 代码中的 \texttt{ini\_set()}覆盖。

自PHP 5.3.3 起，也可以通过Web服务器设置 PHP 的设定。在 nginx.conf 中设定 PHP的示例如下：

\begin{lstlisting}[language=bash]
set $php_value "pcre.backtrack_limit=424242";
set $php_value "$php_value \n pcre.recursion_limit=99999";
fastcgi_param  PHP_VALUE $php_value;

fastcgi_param  PHP_ADMIN_VALUE "open_basedir=/var/www/htdocs";
\end{lstlisting}

由于这些设定是以 FastCGI 标头传递给 php-fpm，php-fpm 不应绑定到外部网可以访问的地址上，否则任何人都能修改 PHP 的配置选项了。



\section{WSGI}

WSGI（Python Web Server Gateway Interface）是为 Python 语言定义的 Web 服务器和Web 应用程序或框架之间的一种简单而通用的接口，现在许多其它语言中也出现了类似接口。

一般而言，Web 应用框架的选择将限制可用的 Web 服务器的选择，反之亦然。

最初，Python 应用程序通常是为 CGI、FastCGI、mod_python，或者特定 Web 服务器的自定义的 API 接口而设计的。

基于现存的 CGI 标准而设计的 WSGI 可以作为 Web 服务器与 Web 应用程序或应用框架之间的一种低级别的接口来方便可移植 Web 应用开发。具体来说，WSGI 可以划分两个部分，分别为“服务器”（或“网关”）和“应用程序”（或“应用框架”）。

在处理一个 WSGI 请求时，服务器会为应用程序提供环境信息及一个回调函数（Callback Function）。当应用程序完成处理请求后，通过前述的回调函数将结果回传给服务器。

WSGI 中间件同时实现了 API 的两方，因此可以在 WSGI 服务和 WSGI 应用之间起调和作用，因此从 WSGI 服务器的角度来说，中间件扮演应用程序，而从应用程序的角度来说，中间件扮演服务器。

WSGI“中间件”组件可以执行以下功能:

\begin{compactitem}
\item 重写环境变量后，根据目标 URL 将请求消息路由到不同的应用对象。
\item 允许在一个进程中同时运行多个应用程序或应用框架。
\item 负载均衡和远程处理，通过在网络上转发请求和响应消息。
\item 进行内容后处理（例如应用 XSLT 样式表）。
\end{compactitem}

下面是用 Python 语言写的一个符合 WSGI 的“Hello World”应用程序示例。



\begin{lstlisting}[language=bash]
def app（environ, start_response）:
	start_response（'200 OK', [（'Content-Type', 'text/plain'）]）
	yield "Hello world!\n"
\end{lstlisting}


\begin{compactitem}
\item 第一行定义了一个名为 app 的 callable 并接受两个参数（environ 和 start_response），其中 environ 是一个字典包含了 CGI 中的环境变量，start_response 也是一个 callable，并接受两个必须的参数——status（HTTP 状态）和 response_headers（响应消息的头）。
\item 第二行调用了 start_response，状态指定为“200 OK”，消息头指定为内容类型是“text/plain”。
\item 第三行将响应消息的消息体返回。

\end{compactitem}

下面是一个调用一个程序并获取它的应答消息的例子。

\begin{lstlisting}[language=bash]
def call_application（app, environ）:
	body = []
	status_headers = [None, None]
	def start_response（status, headers）:
		status_headers[:] = [status, headers]
		return body.append
	app_iter = app（environ, start_response）
	try:
		for item in app_iter:
			body.append（item）
	finally:
		if hasattr（app_iter, 'close'）:
		app_iter.close（）
	return status_headers[0], status_headers[1], ''.join（body）
status, headers, body = call_application（app, {...environ...}）
\end{lstlisting}










\chapter{Runtime}




\section{php.ini}



PHP的配置文件php.ini包含PHP运行时所需要的相关参数，并且在重启Web服务器后才能使新的php.ini设置生效。

\begin{compactitem}
\item 首先，php.ini在 PHP 启动时被读取。
\item 其次，CGI 和 CLI 版本的PHP在每次调用时都会读取php.ini。
\end{compactitem}

php.ini使用Windows的INI文件的书写风格，使用“;”作为注释。

另外，如果某些选项允许有多个值，那么应该使用系统列表分隔符（在Windows下是分号“;”，在UNIX下是冒号“:”）。

对于Apache服务器模块版本的 PHP，仅在Web服务器启动时读取一次\footnote{Apache服务器在启动时会把目录转到根目录，这将导致 PHP 尝试在根目录下读取 php.ini。}，在 php.ini 中可以使用环境变量。



php.ini 的搜索路径如下（按顺序）：

\begin{compactitem}
\item SAPI 模块所指定的位置（Apache 2 中的 PHPIniDir 指令，CGI 和 CLI 中的 \texttt{-c} 命令行选项，NSAPI 中的 \texttt{php\_ini}参数，THTTPD 中的 \texttt{PHP\_INI\_PATH}环境变量）。
\item PHPRC 环境变量。在 PHP 5.2.0 之前，其顺序在以下提及的注册表键值之后。
\item 自 PHP 5.2.0 起，可以为不同版本的 PHP 指定不同的 php.ini 文件位置。将以下面的顺序检查注册表目录：\texttt{[HKEY\_LOCAL\_MACHINE{\textbackslash}SOFTWARE{\textbackslash}PHP{\textbackslash}x.y.z]}，\texttt{[HKEY\_LOCAL\_MACHINE{\textbackslash}SOFTWARE{\textbackslash}PHP{\textbackslash}x.y]} 和 \texttt{[HKEY\_LOCAL\_MACHINE{\textbackslash}SOFTWARE{\textbackslash}PHP{\textbackslash}x]}，其中的 x，y 和 z 指的是 PHP 主版本号，次版本号和发行批次。如果在其中任何目录下的 IniFilePath 有键值，则第一个值将被用作 php.ini 的位置（仅适用于Windows）。
\item \texttt{[HKEY\_LOCAL\_MACHINE{\textbackslash}SOFTWARE{\textbackslash}PHP]} 内 IniFilePath 的值（Windows 注册表位置）。
\item 当前工作目录（对于 CLI）。
\item Web服务器目录（对于 SAPI 模块）或 PHP 所在目录（Windows 下其它情况）。
\item Windows 目录（\texttt{C:{\textbackslash}Windows}或 \texttt{C:{\textbackslash}Winnt}），或 \texttt{--with-config-file-path}编译时选项指定的位置。
\end{compactitem}

\section{php-SAPI.ini}


如果存在 php-SAPI.ini（SAPI 是当前所用的 SAPI 名称，因此实际文件名为 php-cli.ini 或 php-apache.ini 等），则会用它替代 php.ini，SAPI 的名称可以用 \texttt{php\_sapi\_name()}来测定。


由扩展库处理的 php.ini 指令的文档由扩展库提供，但是并非所有的 PHP 指令都有文档说明。

要得到自己的 PHP 版本中的配置指令完整列表，可以阅读 php.ini 文件，也可以从 Git 得到的最新版 php.ini。



\begin{lstlisting}[language=bash]
; any text on a line after an unquoted semicolon (;) is ignored
[php] ; section markers (text within square brackets) are also ignored
; Boolean values can be set to either:
;    true, on, yes
; or false, off, no, none
register_globals = off
track_errors = yes

; you can enclose strings in double-quotes
include_path = ".:/usr/local/lib/php"

; backslashes are treated the same as any other character
include_path = ".;c:\php\lib"
\end{lstlisting}

自 PHP 5.1.0 起，有可能在 .ini 文件内引用已存在的 .ini 变量，例如\texttt{open\_basedir = \$\{open\_basedir\} ":/new/dir"}。


自 PHP 5.3.0 起，PHP 支持基于每个目录的 .htaccess 风格的 INI 文件，不过仅被 CGI/FastCGI SAPI支持，并且导致PECL的htscanner扩展作废。如果使用 Apache，使用.htaccess 文件有同样效果。

除了主 php.ini 之外，PHP 还会在每个目录下扫描 INI 文件，从被执行的 PHP 文件所在目录开始一直上升到Web根目录（\texttt{\$\_SERVER['DOCUMENT\_ROOT']} 所指定的）。如果被执行的 PHP 文件在Web根目录之外，则只扫描该目录。

在 .user.ini 风格的 INI 文件中，只有具有 \texttt{PHP\_INI\_PERDIR}和 \texttt{PHP\_INI\_USER}模式的 INI 设置可被识别，其中\texttt{user\_ini.filename} 和 \texttt{user\_ini.cache\_ttl} 控制着用户 INI 文件的使用。

\begin{compactitem}
\item \texttt{user\_ini.filename}设定了 PHP 会在每个目录下搜寻的文件名，如果设定为空字符串则 PHP 不会搜寻，默认值是 .user.ini。

\item \texttt{user\_ini.cache\_ttl}控制着重新读取用户 INI 文件的间隔时间，默认是 300 秒（5 分钟）。

\end{compactitem}

这些模式决定着一个 PHP 的指令在何时何地，是否能够被设定，而且每个指令都有其所属的模式。

\begin{compactitem}
\item 有些指令可以在 PHP 脚本中用 \texttt{ini\_set()} 来设定；
\item 有些指令只能在 php.ini 或 httpd.conf 中进行设定。
\end{compactitem}

例如，\texttt{output\_buffering}指令是属于 \texttt{PHP\_INI\_PERDIR}，因而就不能用 \texttt{ini\_set()}来设定，但是 \texttt{display\_errors}指令是属于 \texttt{PHP\_INI\_ALL}，因而可以在任何地方被设定，包括 \texttt{ini\_set()}。



\begin{table}[htbp]
\centering
\caption{PHP\_INI\_* 模式的定义}
\label{php_ini_*}
\rowcolors{1}{White}{Lavender}
\begin{tabular}{m{80pt}m{280pt}}
\hline
模式							&含义\\
\texttt{PHP\_INI\_USER}	 &可在用户脚本（例如 \texttt{ini\_set()}）或 Windows 注册表（自 PHP 5.3 起）以及 .user.ini 中设定\\
\texttt{PHP\_INI\_PERDIR}	&可在 php.ini，.htaccess 或 httpd.conf 中设定\\
\texttt{PHP\_INI\_SYSTEM}	&可在 php.ini 或 httpd.conf 中设定\\
\texttt{PHP\_INI\_ALL}		&可在任何地方设定\\
\end{tabular}
\end{table}


\begin{compactitem}
\item PHP 运行于 Apache 模块方式

当使用 PHP 作为 Apache 模块时，也可以用 Apache 的配置文件（例如 httpd.conf）和 .htaccess 文件中的指令来修改 PHP 的配置设定，需要有“\texttt{AllowOverride Options}”或“\texttt{AllowOverride All}”权限才可以。

有几个 Apache 指令可以使用户在 Apache 配置文件内部修改 PHP 的配置，至于哪些指令属于\texttt{PHP\_INI\_ALL}，\texttt{PHP\_INI\_PERDIR}或 \texttt{PHP\_INI\_SYSTEM}中的哪一个，需要参考附录中的 php.ini 配置选项列表。

\begin{compactitem}
\item \texttt{php\_value name value}

设定指定的值。只能用于 \texttt{PHP\_INI\_ALL}或 \texttt{PHP\_INI\_PERDIR}类型的指令。要清除先前设定的值，把 value 设为 none。不要用 \texttt{php\_value}设定布尔值，应该用 \texttt{php\_flag}。

\item \texttt{php\_flag name on|off}

用来设定布尔值的配置指令。仅能用于 \texttt{PHP\_INI\_ALL}和 \texttt{PHP\_INI\_PERDIR}类型的指令。

\item \texttt{php\_admin\_value name value}

设定指定的指令的值。不能用于 .htaccess 文件。任何用 \texttt{php\_admin\_value}设定的指令都不能被 .htaccess 或 virtualhost 中的指令覆盖。要清除先前设定的值，把 value 设为 none。

\item \texttt{php\_admin\_flag name on|off}

用来设定布尔值的配置指令。不能用于 .htaccess 文件。任何用 \texttt{php\_admin\_flag}设定的指令都不能被 .htaccess 或 virtualhost 中的指令覆盖。
\end{compactitem}

\begin{lstlisting}[language=bash]
<IfModule mod_php5.c>
  php_value include_path ".:/usr/local/lib/php"
  php_admin_flag engine on
</IfModule>
<IfModule mod_php4.c>
  php_value include_path ".:/usr/local/lib/php"
  php_admin_flag engine on
</IfModule>
\end{lstlisting}

PHP 常量不存在于 PHP 之外。例如在 httpd.conf 中不能使用 PHP 常量如 \texttt{E\_ALL}或 \texttt{E\_NOTICE}来设定 \texttt{error\_reporting}指令，因为其无意义，实际等于 0。应该用相应的掩码值来替代。这些常量可以在 php.ini 中使用。

\item 通过 Windows 注册表修改 PHP 配置 

在 Windows 下运行 PHP 时，可以用 Windows 注册表以目录为单位来修改配置。

PHP配置值存放于注册表项 \texttt{HKLM{\textbackslash}SOFTWARE{\textbackslash}PHP{\textbackslash}Per Directory Values} 下面，子项对应于路径名。例如，对于目录 \texttt{c:{\textbackslash}inetpub{\textbackslash}wwwroot} 的配置值会存放于 \texttt{HKLM{\textbackslash}SOFTWARE{\textbackslash}PHP{\textbackslash}Per Directory Values{\textbackslash}c{\textbackslash}inetpub{\textbackslash}wwwroot} 项下面。其中的设定对于任何位于此目录及其任何子目录的脚本都有效。项中的值的名称是 PHP 配置指令的名字，值的数据是字符串格式的指令值。值中的 PHP 常量不被解析。不过只有可修改范围是 \texttt{PHP\_INI\_USER}的配置值可以用此方法设定，\texttt{PHP\_INI\_PERDIR} 的值就不行。

\item 其它接口下的 PHP

无论怎样运行 PHP，都可以在脚本中通过 \texttt{ini\_set()} 而在运行时修改某个值。如果对自己系统中的配置设定及其当前值的完整列表感兴趣，可以运行 \texttt{phpinfo()} 函数并查看其结果的页面。也可以在运行时用\texttt{ini\_get()}或 \texttt{get\_cfg\_var()}取得个别配置指令的值。

\end{compactitem}


\section{directive}


当Web服务器使用CGI方式运行PHP时，可以开启cgi.force\_redirect来增强系统安全性，但是在IIS和OmniHTTPD等服务器时必须关闭。

PHP超全局变量的解析顺序可以通过variabls\_order进行设定，默认设定为EGPCS，依次为\$\_ENV、\$\_GET、\$\_POST、\$\_COOKIE和\$\_SERVER。

基于安全的考虑，默认将register\_globals设置为Off来禁止将\$\_ENV、\$\_GET、\$\_POST、\$\_COOKIE和\$\_SERVER变量同时设置为全局变量\$GLOBALS的引用。

为了查找文件，可以使用include\_path来指定一组目录以用于require或include，以及fopen\_with\_path()函数。

\begin{lstlisting}[language=bash]
## UNIX
include_path=".:/usr/local/php/pear"
## Windows
include_path=".;c:/usr/local/php/pear"
\end{lstlisting}

PHP的扩展库可以使用extension\_dir进行指定，通常是PHP安装目录下的ext目录。

为了指定PHP启动时加载的扩展库，可以使用extension进行指定。例如：

\begin{lstlisting}[language=bash]
# UNIX/Linux
extension=curl.so
extension=ftp.so
# Windows
extension=php_curl.dll
extension=php_ftp.dll
\end{lstlisting}




\chapter{Framework}

PHP框架可以使项目得到更快更简单的部署和更加敏捷的开发效率，因此在实际生产中框架的使用已非常普遍，例如PHP官方的框架为Zend framework。













\chapter{Security}


\section{Thread Safe}

Windows版的PHP从版本5.2.1开始有Thread Safe（线程安全）和None Thread Safe（NTS，非线程安全）之分，这两者不同在于何处\cite{thread_safe}？到底应该用哪种？这里做一个简单的介绍。

从2000年10月20日发布的第一 个Windows版的PHP3.0.17开始的都是线程安全的版本。与Linux/Unix系统是采用多进程的工作方式不同的是，Windows系统的是多线程的工作方式。如果在IIS下以CGI方式运行PHP会非常慢，这是由于CGI模式是建立在多进程的基础之上的，而非多线程。

一般情况下，在Windows平台上需要把PHP配置成以ISAPI的方式来运行，ISAPI是多线程的方式，这样就快多了。



不过，仍然存在一个问题，那就是很多常用的PHP扩展是以Linux/Unix的多进程思想来开发的，这些扩展在ISAPI的方式运行时就会出错并拖垮IIS，因此在IIS下CGI模式才是PHP运行的最安全方式。

CGI模式的不足就是对于每个HTTP请求都需要重新加载和卸载整个PHP环境，其资源消耗是巨大的。

为了兼顾IIS下PHP的效率和安全，微软给出了FastCGI的解决方案，从而可以让PHP的进程重复利用而不是每一个新的请求就新建一个进程，同时FastCGI也可以允许几个进程同时执行，这样既解决了CGI进程模式消耗太大的问题，又利用了CGI进程模式不存在线程安全问题的优势。

综合来说，如果使用ISAPI的方式来运行PHP就必须用Thread Safe（线程安全）的版本，否则用FastCGI模式运行PHP的话就没有必要用线程安全检查，None Thread Safe（NTS，非线程安全）的版本能够更好的提高效率。



\section{Windows Version}

If you are using PHP with Apache 1 or Apache2 from apache.org you need to use the VC6 versions of PHP

If you are using PHP with IIS you should use the VC9 versions of PHP

VC6 Versions are compiled with the legacy Visual Studio 6 compiler

VC9 Versions are compiled with the Visual Studio 2008 compiler and have improvements in performance and stability. The VC9 versions require you to have the Microsoft 2008 C++ Runtime (x86) or the Microsoft 2008 C++ Runtime (x64) installed

Do NOT use VC9 version with apache.org binaries

VC9 versions of Apache can be fetched at Apache Lounge. We use their binaries to build the Apache SAPIs.


\section{Safe Mode}

php.ini中的safe\_mode设置是否打开安全模式，不过PHP默认不会运行在安全模式下。

在安全模式下，可以通过safe\_mode\_exec\_dir设置具有系统程序执行功能的目录，而且exec()、system()或popen()等函数只能调用执行该目录下的系统程序。

在安全模式下，safe\_mode\_include\_dir可以设置严格限制进行文件包含的目录，如果一个PHP程序使用include或require包含该目录（及子目录）中的另一个文件时，必须保证彼此具有相同的UID或GID。

无论是否打开安全模式，pen\_basedir都可以设置能够进行的文件操作的目录或文件的前缀，可以使用系统分隔符（“;”或“:”）添加多个列表。

当一个脚本试图使用fopen()或gzopen()打开一个文件时，那么该文家的位置将被检查，而且这个限制是前缀，不是目录名。

如果基于安全原因需要禁用某些函数/类时，可以使用disable\_functions/disable\_classes，并且接受逗号分隔的函数/类名列表作为参数，不受安全模式的影响。










\bibliographystyle{plainnat}
\bibliography{phpnotes}
\setcitestyle{numbers}














































































