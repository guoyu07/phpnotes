\part{Class and Objects}


自 PHP 5 起完全重写了对象模型以得到更佳性能和更多特性。这是自 PHP 4 以来的最大变化。PHP 5 具有完整的对象模型。

PHP 5 中的新特性包括访问控制，抽象类和 final 类与方法，附加的魔术方法，接口，对象复制和类型约束。

PHP 对待对象的方式与引用和句柄相同，即每个变量都持有对象的引用，而不是整个对象的拷贝。


\chapter{Introduction}

\section{class}


每个类的定义都以关键字 class 开头，后面跟着类名，后面跟着一对花括号，里面包含有类的属性与方法的定义。

类名可以是任何非 PHP 保留字的合法标签。一个合法类名以字母或下划线开头，后面跟着若干字母，数字或下划线。以正则表达式表示为：\colorbox{lightgray}{\texttt{[a-zA-Z\_\textbackslash x7f-\textbackslash xff][a-zA-Z0-9\_\textbackslash x7f-\textbackslash xff]*}}。

一个类可以包含有属于自己的常量，变量（称为“属性”）以及函数（称为“方法”）。

\begin{lstlisting}[language=PHP]
<?php
class SimpleClass
{
    // property declaration
    public $var = 'a default value';

    // method declaration
    public function displayVar() {
        echo $this->var;
    }
}
?>
\end{lstlisting}

当一个方法在类定义内部被调用时，有一个可用的伪变量 \$this。\$this 是一个到主叫对象的引用（通常是该方法所从属的对象，但如果是从第二个对象静态调用时也可能是另一个对象）。




\begin{lstlisting}[language=PHP]
<?php
class A
{
    function foo()
    {
        if (isset($this)) {
            echo '$this is defined (';
            echo get_class($this);
            echo ")\n";
        } else {
            echo "\$this is not defined.\n";
        }
    }
}

class B
{
    function bar()
    {
        // Note: the next line will issue a warning if E_STRICT is enabled.
        A::foo();
    }
}

$a = new A();
$a->foo();

// Note: the next line will issue a warning if E_STRICT is enabled.
A::foo();
$b = new B();
$b->bar();

// Note: the next line will issue a warning if E_STRICT is enabled.
B::bar();
?>
\end{lstlisting}

以上例程会输出：

\begin{verbatim}
$this is defined (A)
$this is not defined.
$this is defined (B)
$this is not defined.
\end{verbatim}


\section{new}

要创建一个类的实例，必须使用 new 关键字。当创建新对象时该对象总是被赋值，除非该对象定义了构造函数并且在出错时抛出了一个异常。类应在被实例化之前定义（某些情况下则必须这样）。

如果在 new 之后跟着的是一个包含有类名的字符串，则该类的一个实例被创建。如果该类属于一个名字空间，则必须使用其完整名称。



\begin{lstlisting}[language=PHP]
<?php
$instance = new SimpleClass();

// 也可以这样做：
$className = 'Foo';
$instance = new $className(); // Foo()
?>
\end{lstlisting}

在类定义内部，可以用 new self 和 new parent 创建新对象。

当把一个对象已经创建的实例赋给一个新变量时，新变量会访问同一个实例，就和用该对象赋值一样。此行为和给函数传递入实例时一样。


\begin{lstlisting}[language=PHP]
<?php

$instance = new SimpleClass();

$assigned   =  $instance;
$reference  =& $instance;

$instance->var = '$assigned will have this value';

$instance = null; // $instance and $reference become null

var_dump($instance);
var_dump($reference);
var_dump($assigned);
?>
\end{lstlisting}

以上例程会输出：

\begin{verbatim}
NULL
NULL
object(SimpleClass)#1 (1) {
   ["var"]=>
     string(30) "$assigned will have this value"
}
\end{verbatim}

可以用克隆给一个已创建的对象建立一个新实例。

PHP 5.3.0 引进了两个新方法来创建一个对象的实例：





\begin{lstlisting}[language=PHP]
<?php
class Test
{
    static public function getNew()
    {
        return new static;
    }
}

class Child extends Test
{}

$obj1 = new Test();
$obj2 = new $obj1;
var_dump($obj1 !== $obj2);

$obj3 = Test::getNew();
var_dump($obj3 instanceof Test);

$obj4 = Child::getNew();
var_dump($obj4 instanceof Child);
?>
\end{lstlisting}

以上例程会输出：

\begin{verbatim}
bool(true)
bool(true)
bool(true)
\end{verbatim}


\section{extends}

一个类可以在声明中用 extends 关键字继承另一个类的方法和属性。PHP不支持多重继承，一个类只能继承一个基类。

被继承的方法和属性可以通过用同样的名字重新声明被覆盖。但是如果父类定义方法时使用了 final，则该方法不可被覆盖。可以通过 parent:: 来访问被覆盖的方法或属性。

当覆盖方法时，参数必须保持一致否则 PHP 将发出 E\_STRICT 级别的错误信息。但构造函数例外，构造函数可在被覆盖时使用不同的参数。


\begin{lstlisting}[language=PHP]
<?php
class ExtendClass extends SimpleClass
{
    // Redefine the parent method
    function displayVar()
    {
        echo "Extending class\n";
        parent::displayVar();
    }
}

$extended = new ExtendClass();
$extended->displayVar();
?>
\end{lstlisting}

以上例程会输出：

\begin{verbatim}
Extending class
a default value
\end{verbatim}


\section{::class}

自 PHP 5.5 起，关键词 class 也可用于类名的解析。使用 ClassName::class 你可以获取一个字符串，包含了类 ClassName 的完全限定名称。这对使用了 命名空间 的类尤其有用。


\begin{lstlisting}[language=PHP]
<?php
namespace NS {
    class ClassName {
    }
    
    echo ClassName::class;
}
?>
\end{lstlisting}

以上例程会输出：

\begin{verbatim}
NS\ClassName
\end{verbatim}

\chapter{PHP Class Attributes}

类的变量成员叫做“属性”，或者叫“字段”、“特征”。属性声明\footnote{为了向后兼容 PHP 4，PHP 5 声明属性依然可以直接使用关键字 var 来替代（或者附加于）public，protected 或 private，但是已不再需要 var 了。在 PHP 5.0 到 5.1.3，var 会被认为是废弃的，而且抛出 E\_STRICT 警告，但是 5.1.3 之后就不再认为是废弃，也不会抛出警告。如果直接使用 var 声明属性，而没有用 public，protected 或 private 之一，PHP 5 会将其视为 public。}是由关键字 public，protected 或者 private 开头，然后跟一个普通的变量声明来组成。

属性中的变量可以初始化，但是初始化的值必须是常数，这里的常数是指 PHP 脚本在编译阶段时就可以得到其值，而不依赖于运行时的信息才能求值。

\begin{lstlisting}[language=PHP]
<?php
class SimpleClass
{
   // 错误的属性声明
   public $var1 = 'hello ' . 'world';
   public $var2 = <<<EOD
hello world
EOD;
   public $var3 = 1+2;
   public $var4 = self::myStaticMethod();
   public $var5 = $myVar;

   // 正确的属性声明
   public $var6 = myConstant;
   public $var7 = array(true, false);

   //在 PHP 5.3.0 及之后，下面的声明也正确
   public $var8 = <<<'EOD'
hello world
EOD;
}
?>
\end{lstlisting}

跟 heredocs 不同，nowdocs 可在任何静态数据上下文中使用，包括属性声明。

\begin{lstlisting}[language=PHP]
<?php
class foo {
   // 自 5.3.0 起
   public $bar = <<<'EOT'
bar
EOT;
}
?>
\end{lstlisting}


在类的成员方法里面，可以用 ->（对象运算符）：\$this->property（其中 property 是该属性名）这种方式来访问非静态属性。静态属性则是用 ::（双冒号）：self::\$property 来访问。

当一个方法在类定义内部被调用时，有一个可用的伪变量 \$this。\$this 是一个到主叫对象的引用（通常是该方法所从属的对象，但如果是从第二个对象静态调用时也可能是另一个对象）。






\chapter{PHP Class Constants}


可以把在类中始终保持不变的值定义为常量，而且在定义和使用常量的时候不需要使用 \$ 符号。

常量的值必须是一个定值，不能是变量、类属性或数学运算的结果或函数调用。

接口（interface）中也可以定义常量。

自 PHP 5.3.0 起，可以用一个变量来动态调用类。但该变量的值不能为关键字（如 self，parent 或 static）。





\begin{lstlisting}[language=PHP]
<?php
class MyClass
{
    const constant = 'constant value';

    function showConstant() {
        echo  self::constant . "\n";
    }
}

echo MyClass::constant . "\n";

$classname = "MyClass";
echo $classname::constant . "\n"; // 自 5.3.0 起

$class = new MyClass();
$class->showConstant();

echo $class::constant."\n"; // 自 PHP 5.3.0 起
?>
\end{lstlisting}

和 heredoc 不同，nowdoc 可以用在任何静态数据中。





\begin{lstlisting}[language=PHP]
<?php
class foo {
    // 自 PHP 5.3.0 起
    const bar = <<<'EOT'
bar
EOT;
}
?>
\end{lstlisting}


\chapter{Autoloading Classes}

很多开发者写面向对象的应用程序时对每个类的定义建立一个 PHP 源文件。一个很大的烦恼是不得不在每个脚本开头写一个长长的包含文件列表（每个类一个文件）。

在 PHP 5 中，不再需要这样了。可以定义一个 \_\_autoload() 函数\footnote{spl\_autoload\_register() 提供了一种更加灵活的方式来实现类的自动加载。因此，不再建议使用 \_\_autoload() 函数，在以后的版本中它可能被弃用。}，它会在试图使用尚未被定义的类时自动调用。通过调用此函数，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类，只是自动加载不可用于 PHP 的 CLI 交互模式。

在 5.3.0 版之前，\_\_autoload 函数抛出的异常不能被 catch 语句块捕获并会导致一个致命错误。从 5.3.0+ 之后，\_\_autoload 函数抛出的异常可以被 catch 语句块捕获，但需要遵循一个条件。如果抛出的是一个自定义异常，那么必须存在相应的自定义异常类。\_\_autoload 函数可以递归的自动加载自定义异常类。

本例尝试分别从 MyClass1.php 和 MyClass2.php 文件中加载 MyClass1 和 MyClass2 类。

\begin{lstlisting}[language=PHP]
<?php
function __autoload($class_name) {
    require_once $class_name . '.php';
}

$obj  = new MyClass1();
$obj2 = new MyClass2();
?>
\end{lstlisting}


本例尝试加载接口 ITest。


\begin{lstlisting}[language=PHP]
<?php

function __autoload($name) {
    var_dump($name);
}

class Foo implements ITest {
}

/*
string(5) "ITest"

Fatal error: Interface 'ITest' not found in ...
*/
?>
\end{lstlisting}

本例抛出一个异常并在 try/catch 语句块中演示。




\begin{lstlisting}[language=PHP]
<?php
function __autoload($name) {
    echo "Want to load $name.\n";
    throw new Exception("Unable to load $name.");
}

try {
    $obj = new NonLoadableClass();
} catch (Exception $e) {
    echo $e->getMessage(), "\n";
}
?>
\end{lstlisting}

以上例程会输出：

\begin{verbatim}
Want to load NonLoadableClass.
Unable to load NonLoadableClass.
\end{verbatim}

本例将一个异常抛给不存在的自定义异常处理函数。

\begin{lstlisting}[language=PHP]
<?php
function __autoload($name) {
    echo "Want to load $name.\n";
    throw new MissingException("Unable to load $name.");
}

try {
    $obj = new NonLoadableClass();
} catch (Exception $e) {
    echo $e->getMessage(), "\n";
}
?>
\end{lstlisting}

以上例程会输出：

\begin{verbatim}
Want to load NonLoadableClass.
Want to load MissingException.

Fatal error: Class 'MissingException' not found in testMissingException.php on line 4
\end{verbatim}

\chapter{Constructors and Destructors}


\section{Constructors}


\begin{lstlisting}[language=PHP]
void __construct ([ mixed $args [, $... ]] )
\end{lstlisting}

PHP 5 允行开发者在一个类中定义一个方法作为构造函数。具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。

如果子类中定义了构造函数则不会隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用 parent::\_\_construct()。如果子类没有定义构造函数则会如同一个普通的类方法一样从父类继承（假如没有被定义为 private 的话）。


\begin{lstlisting}[language=PHP]
<?php
class BaseClass {
   function __construct() {
       print "In BaseClass constructor\n";
   }
}

class SubClass extends BaseClass {
   function __construct() {
       parent::__construct();
       print "In SubClass constructor\n";
   }
}

class OtherSubClass extends BaseClass {
    // inherits BaseClass's constructor
}

// In BaseClass constructor
$obj = new BaseClass();

// In BaseClass constructor
// In SubClass constructor
$obj = new SubClass();

// In BaseClass constructor
$obj = new OtherSubClass();
?>
\end{lstlisting}


为了实现向后兼容性，如果 PHP 5 在类中找不到 \_\_construct() 函数并且也没有从父类继承一个的话，它就会尝试寻找旧式的构造函数，也就是和类同名的函数。因此唯一会产生兼容性问题的情况是：类中已有一个名为 \_\_construct() 的方法却被用于其它用途时。

与其它方法不同，当 \_\_construct() 被与父类 \_\_construct() 具有不同参数的方法覆盖时，PHP 不会产生一个 E\_STRICT 错误信息。

自 PHP 5.3.3 起，在命名空间中，与类名同名的方法不再作为构造函数。这一改变不影响不在命名空间中的类。

\begin{lstlisting}[language=PHP]
<?php
namespace Foo;
class Bar {
    public function Bar() {
        // treated as constructor in PHP 5.3.0-5.3.2
        // treated as regular method as of PHP 5.3.3
    }
}
?>
\end{lstlisting}



\section{Destructors}









\begin{lstlisting}[language=PHP]
void __destruct ( void )
\end{lstlisting}

PHP 5 引入了析构函数的概念，这类似于其它面向对象的语言，如 C++。析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。


\begin{lstlisting}[language=PHP]
<?php
class MyDestructableClass {
   function __construct() {
       print "In constructor\n";
       $this->name = "MyDestructableClass";
   }

   function __destruct() {
       print "Destroying " . $this->name . "\n";
   }
}

$obj = new MyDestructableClass();
?>
\end{lstlisting}


和构造函数一样，父类的析构函数不会被引擎暗中调用。要执行父类的析构函数，必须在子类的析构函数体中显式调用 parent::\_\_destruct()。此外也和构造函数一样，子类如果自己没有定义析构函数则会继承父类的。

析构函数即使在使用 exit() 终止脚本运行时也会被调用。在析构函数中调用 exit() 将会中止其余关闭操作的运行。

试图在析构函数（在脚本终止时被调用）中抛出一个异常会导致致命错误。

析构函数在脚本关闭时调用，此时所有的 HTTP 头信息已经发出。脚本关闭时的工作目录有可能和在 SAPI（如 apache）中时不同。


\chapter{Visibility}

对属性或方法的访问控制，是通过在前面添加关键字 public（公有），protected（受保护）或 private（私有）来实现的。被定义为公有的类成员可以在任何地方被访问。被定义为受保护的类成员则可以被其自身以及其子类和父类访问。被定义为私有的类成员则只能被其定义所在的类访问。

\section{Property Visibility}


类属性必须定义为公有，受保护，私有之一。如果用 var 定义，则被视为公有。

\begin{lstlisting}[language=PHP]
<?php
/**
 * Define MyClass
 */
class MyClass
{
    public $public = 'Public';
    protected $protected = 'Protected';
    private $private = 'Private';

    function printHello()
    {
        echo $this->public;
        echo $this->protected;
        echo $this->private;
    }
}

$obj = new MyClass();
echo $obj->public; // 这行能被正常执行
echo $obj->protected; // 这行会产生一个致命错误
echo $obj->private; // 这行也会产生一个致命错误
$obj->printHello(); // 输出 Public、Protected 和 Private


/**
 * Define MyClass2
 */
class MyClass2 extends MyClass
{
    // 可以对 public 和 protected 进行重定义，但 private 而不能
    protected $protected = 'Protected2';

    function printHello()
    {
        echo $this->public;
        echo $this->protected;
        echo $this->private;
    }
}

$obj2 = new MyClass2();
echo $obj2->public; // 这行能被正常执行
echo $obj2->private; // 未定义 private
echo $obj2->protected; // 这行会产生一个致命错误
$obj2->printHello(); // 输出 Public、Protected2 和 Undefined

?>
\end{lstlisting}


为了兼容性考虑，在 PHP 4 中使用 var 关键字对变量进行定义的方法在 PHP 5 中仍然有效（只是作为 public 关键字的一个别名）。在 PHP 5.1.3 之前的版本，该语法会产生一个 E\_STRICT 警告。


\section{Method Visibility}

类中的方法可以被定义为公有，私有或受保护。如果没有设置这些关键字，则该方法默认为公有。


\begin{lstlisting}[language=PHP]
<?php
/**
 * Define MyClass
 */
class MyClass
{
    // 声明一个公有的构造函数
    public function __construct() { }

    // 声明一个公有的方法
    public function MyPublic() { }

    // 声明一个受保护的方法
    protected function MyProtected() { }

    // 声明一个私有的方法
    private function MyPrivate() { }

    // 此方法为公有
    function Foo()
    {
        $this->MyPublic();
        $this->MyProtected();
        $this->MyPrivate();
    }
}

$myclass = new MyClass;
$myclass->MyPublic(); // 这行能被正常执行
$myclass->MyProtected(); // 这行会产生一个致命错误
$myclass->MyPrivate(); // 这行会产生一个致命错误
$myclass->Foo(); // 公有，受保护，私有都可以执行


/**
 * Define MyClass2
 */
class MyClass2 extends MyClass
{
    // 此方法为公有
    function Foo2()
    {
        $this->MyPublic();
        $this->MyProtected();
        $this->MyPrivate(); // 这行会产生一个致命错误
    }
}

$myclass2 = new MyClass2;
$myclass2->MyPublic(); // 这行能被正常执行
$myclass2->Foo2(); // 公有的和受保护的都可执行，但私有的不行

class Bar 
{
    public function test() {
        $this->testPrivate();
        $this->testPublic();
    }

    public function testPublic() {
        echo "Bar::testPublic\n";
    }
    
    private function testPrivate() {
        echo "Bar::testPrivate\n";
    }
}

class Foo extends Bar 
{
    public function testPublic() {
        echo "Foo::testPublic\n";
    }
    
    private function testPrivate() {
        echo "Foo::testPrivate\n";
    }
}

$myFoo = new foo();
$myFoo->test(); // Bar::testPrivate 
                // Foo::testPublic
?>
\end{lstlisting}



\section{Object Visibility}

同一个类的对象即使不是同一个实例也可以互相访问对方的私有与受保护成员。这是由于在这些对象的内部具体实现的细节都是已知的。

\begin{lstlisting}[language=PHP]
<?php
class Test
{
    private $foo;

    public function __construct($foo)
    {
        $this->foo = $foo;
    }

    private function bar()
    {
        echo 'Accessed the private method.';
    }

    public function baz(Test $other)
    {
        // We can change the private property:
        $other->foo = 'hello';
        var_dump($other->foo);

        // We can also call the private method:
        $other->bar();
    }
}

$test = new Test('test');

$test->baz(new Test('other'));
?>
\end{lstlisting}

以上例程会输出：

\begin{verbatim}
string(5) "hello"
Accessed the private method.
\end{verbatim}


\chapter{Inheritance}

继承已为大家所熟知的一个程序设计特性，PHP 的对象模型也使用了继承。继承将会影响到类与类，对象与对象之间的关系。

比如，当扩展一个类，子类就会继承父类所有公有的和受保护的方法。除非子类覆盖了父类的方法，被继承的方法都会保留其原有功能。

继承对于功能的设计和抽象是非常有用的，而且对于类似的对象增加新功能就无须重新再写这些公用的功能。




\begin{lstlisting}[language=PHP]
<?php

class foo
{
    public function printItem($string) 
    {
        echo 'Foo: ' . $string . PHP_EOL;
    }
    
    public function printPHP()
    {
        echo 'PHP is great.' . PHP_EOL;
    }
}

class bar extends foo
{
    public function printItem($string)
    {
        echo 'Bar: ' . $string . PHP_EOL;
    }
}

$foo = new foo();
$bar = new bar();
$foo->printItem('baz'); // Output: 'Foo: baz'
$foo->printPHP();       // Output: 'PHP is great' 
$bar->printItem('baz'); // Output: 'Bar: baz'
$bar->printPHP();       // Output: 'PHP is great'

?>
\end{lstlisting}


除非使用了自动加载，否则一个类必须在使用之前被定义。如果一个类扩展了另一个，则父类必须在子类之前被声明。此规则适用于类继承其它类与接口。


\chapter{Scope Resolution Operator (::)}

范围解析操作符（也可称作 Paamayim Nekudotayim）或者更简单地说是一对冒号，可以用于访问静态成员，类常量，还可以用于覆盖类中的属性和方法。

当在类定义之外引用到这些项目时，要使用类名。

自 PHP 5.3.0 起，可以通过变量来引用类，该变量的值不能是关键字（如 self，parent 和 static）。

把 Paamayim Nekudotayim 选作双冒号操作符的名字似乎有些奇怪。然而，这是 Zend 开发小组在写 Zend Engine 0.5（被用于 PHP 3 中）时所作出的决定。事实上这个词在希伯莱文就是双冒号的意思。

\begin{lstlisting}[language=PHP]
<?php
class MyClass {
    const CONST_VALUE = 'A constant value';
}

$classname = 'MyClass';
echo $classname::CONST_VALUE; // 自 PHP 5.3.0 起

echo MyClass::CONST_VALUE;
?>
\end{lstlisting}

self，parent 和 static 这三个特殊的关键字是用于在类定义的内部对其属性或方法进行访问的。


\begin{lstlisting}[language=PHP]
<?php
class OtherClass extends MyClass
{
    public static $my_static = 'static var';

    public static function doubleColon() {
        echo parent::CONST_VALUE . "\n";
        echo self::$my_static . "\n";
    }
}

$classname = 'OtherClass';
echo $classname::doubleColon(); // 自 PHP 5.3.0 起

OtherClass::doubleColon();
?>
\end{lstlisting}


当一个子类覆盖其父类中的方法时，PHP 不会调用父类中已被覆盖的方法，是否调用父类的方法取决于子类。这种机制也作用于构造函数和析构函数，重载以及魔术方法。

\begin{lstlisting}[language=PHP]
<?php
class MyClass
{
    protected function myFunc() {
        echo "MyClass::myFunc()\n";
    }
}

class OtherClass extends MyClass
{
    // 覆盖了父类的定义
    public function myFunc()
    {
        // 但还是可以调用父类中被覆盖的方法
        parent::myFunc();
        echo "OtherClass::myFunc()\n";
    }
}

$class = new OtherClass();
$class->myFunc();
?>
\end{lstlisting}


\chapter{Static Keyword}

static 关键字可以用来定义静态方法和属性。static 也可用于定义静态变量以及后期静态绑定。

声明类属性或方法为静态，就可以不实例化类而直接访问。静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。

为了兼容 PHP 4，如果没有指定访问控制，属性和方法默认为公有。

由于静态方法不需要通过对象即可调用，所以伪变量 \$this 在静态方法中不可用。

静态属性不可以由对象通过 -\/> 操作符来访问。

用静态方式调用一个非静态方法会导致一个 E\_STRICT 级别的错误。

就像其它所有的 PHP 静态变量一样，静态属性只能被初始化为文字或常量，不能使用表达式。所以可以把静态属性初始化为整数或数组，但不能初始化为另一个变量或函数返回值，也不能指向一个对象。

自 PHP 5.3.0 起，可以用一个变量来动态调用类。但该变量的值不能为关键字 self，parent 或 static。


\begin{lstlisting}[language=PHP]
<?php
class Foo
{
    public static $my_static = 'foo';

    public function staticValue() {
        return self::$my_static;
    }
}

class Bar extends Foo
{
    public function fooStatic() {
        return parent::$my_static;
    }
}


print Foo::$my_static . "\n";

$foo = new Foo();
print $foo->staticValue() . "\n";
print $foo->my_static . "\n";      // Undefined "Property" my_static 

print $foo::$my_static . "\n";
$classname = 'Foo';
print $classname::$my_static . "\n"; // As of PHP 5.3.0

print Bar::$my_static . "\n";
$bar = new Bar();
print $bar->fooStatic() . "\n";
?>
   </programlisting>
  </example>

  <example>
   <title>静态方法示例</title>
    <programlisting role="php">
<![CDATA[
<?php
class Foo {
    public static function aStaticMethod() {
        // ...
    }
}

Foo::aStaticMethod();
$classname = 'Foo';
$classname::aStaticMethod(); // 自 PHP 5.3.0 起
?>
\end{lstlisting}


\chapter{Class Abstraction}

PHP 5 支持抽象类和抽象方法。定义为抽象的类不能被实例化。任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。

继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；另外，这些方法的访问控制必须和父类中一样（或者更为宽松）。例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。此外方法的调用方式必须匹配，即类型和所需参数数量必须一致。例如，子类定义了一个可选参数，而父类抽象方法的声明里没有，则两者的声明并无冲突。 这也适用于 PHP 5.4 起的构造函数。在 PHP 5.4 之前的构造函数声明可以不一样的。

%%\begin{example}[!ht]
\begin{lstlisting}[language=PHP]
<?php
abstract class AbstractClass
{
 // 强制要求子类定义这些方法
    abstract protected function getValue();
    abstract protected function prefixValue($prefix);

    // 普通方法（非抽象方法）
    public function printOut() {
        print $this->getValue() . "\n";
    }
}

class ConcreteClass1 extends AbstractClass
{
    protected function getValue() {
        return "ConcreteClass1";
    }

    public function prefixValue($prefix) {
        return "{$prefix}ConcreteClass1";
    }
}

class ConcreteClass2 extends AbstractClass
{
    public function getValue() {
        return "ConcreteClass2";
    }

    public function prefixValue($prefix) {
        return "{$prefix}ConcreteClass2";
    }
}

$class1 = new ConcreteClass1;
$class1->printOut();
echo $class1->prefixValue('FOO_') ."\n";

$class2 = new ConcreteClass2;
$class2->printOut();
echo $class2->prefixValue('FOO_') ."\n";
?>
\end{lstlisting}
%%\caption{抽象类示例}
%%\end{example}

以上例程会输出：

\begin{verbatim}
ConcreteClass1
FOO_ConcreteClass1
ConcreteClass2
FOO_ConcreteClass2
\end{verbatim}


\begin{lstlisting}[language=PHP]
<?php
abstract class AbstractClass
{
    // 我们的抽象方法仅需要定义需要的参数
    abstract protected function prefixName($name);

}

class ConcreteClass extends AbstractClass
{

    // 我们的子类可以定义父类签名中不存在的可选参数
    public function prefixName($name, $separator = ".") {
        if ($name == "Pacman") {
            $prefix = "Mr";
        } elseif ($name == "Pacwoman") {
            $prefix = "Mrs";
        } else {
            $prefix = "";
        }
        return "{$prefix}{$separator} {$name}";
    }
}

$class = new ConcreteClass;
echo $class->prefixName("Pacman"), "\n";
echo $class->prefixName("Pacwoman"), "\n";
?>
\end{lstlisting}


以上例程会输出：

\begin{verbatim}
Mr. Pacman
Mrs. Pacwoman
\end{verbatim}

老代码中如果没有自定义类或函数被命名为“abstract”，则应该能不加修改地正常运行。


\chapter{Interfaces}


使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。

接口是通过 interface 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的。

接口中定义的所有方法都必须是公有，这是接口的特性。

接口也可以继承，通过使用 extends 操作符。

\section{Implements}


要实现一个接口，使用 implements 操作符。类中必须实现接口中定义的所有方法，否则会报一个致命错误。类可以实现多个接口，用逗号来分隔多个接口的名称。

实现多个接口时，接口中的方法不能有重名。



类要实现接口，必须使用和接口中所定义的方法完全一致的方式。否则会导致致命错误。





\begin{lstlisting}[language=PHP]
<?php

// 声明一个'iTemplate'接口
interface iTemplate
{
    public function setVariable($name, $var);
    public function getHtml($template);
}


// 实现接口
// 下面的写法是正确的
class Template implements iTemplate
{
    private $vars = array();
  
    public function setVariable($name, $var)
    {
        $this->vars[$name] = $var;
    }
  
    public function getHtml($template)
    {
        foreach($this->vars as $name => $value) {
            $template = str_replace('{' . $name . '}', $value, $template);
        }
 
        return $template;
    }
}

// 下面的写法是错误的，会报错，因为没有实现 getHtml()：
// Fatal error: Class BadTemplate contains 1 abstract methods
// and must therefore be declared abstract (iTemplate::getHtml)
class BadTemplate implements iTemplate
{
    private $vars = array();
  
    public function setVariable($name, $var)
    {
        $this->vars[$name] = $var;
    }
}
?>
\end{lstlisting}



\begin{lstlisting}[language=PHP]
可扩充的接口
<?php
interface a
{
    public function foo();
}

interface b extends a
{
    public function baz(Baz $baz);
}

// 正确写法
class c implements b
{
    public function foo()
    {
    }

    public function baz(Baz $baz)
    {
    }
}

// 错误写法会导致一个致命错误
class d implements b
{
    public function foo()
    {
    }

    public function baz(Foo $foo)
    {
    }
}
?>
\end{lstlisting}




\begin{lstlisting}[language=PHP]
继承多个接口
<?php
interface a
{
    public function foo();
}

interface b
{
    public function bar();
}

interface c extends a, b
{
    public function baz();
}

class d implements c
{
    public function foo()
    {
    }

    public function bar()
    {
    }

    public function baz()
    {
    }
}
?>
\end{lstlisting}









\section{Constants}


接口中也可以定义常量。接口常量和类常量的使用完全相同，但是不能被子类或子接口所覆盖。







\begin{lstlisting}[language=PHP]
使用接口常量
<?php
interface a
{
    const b = 'Interface constant';
}

// 输出接口常量
echo a::b;

// 错误写法，因为常量不能被覆盖。接口常量的概念和类常量是一样的。
class b implements a
{
    const b = 'Class constant';
}
?>
\end{lstlisting}


接口加上类型约束，提供了一种很好的方式来确保某个对象包含有某些方法。


\chapter{Traits}


自 PHP 5.4.0 起，PHP 实现了代码复用的一个方法，称为 traits。

Traits 是一种为类似 PHP 的单继承语言而准备的代码复用机制。Trait 为了减少单继承语言的限制，使开发人员能够自由地在不同层次结构内独立的类中复用方法集。Traits 和类组合的语义是定义了一种方式来减少复杂性，避免传统多继承和混入类（Mixin）相关的典型问题。

Trait 和一个类相似，但仅仅旨在用细粒度和一致的方式来组合功能。Trait 不能通过它自身来实例化。它为传统继承增加了水平特性的组合；也就是说，应用类的成员不需要继承。

\begin{lstlisting}[language=PHP]
<?php
trait ezcReflectionReturnInfo {
    function getReturnType() { /*1*/ }
    function getReturnDescription() { /*2*/ }
}

class ezcReflectionMethod extends ReflectionMethod {
    use ezcReflectionReturnInfo;
    /* ... */
}

class ezcReflectionFunction extends ReflectionFunction {
    use ezcReflectionReturnInfo;
    /* ... */
}
?>
\end{lstlisting}


\section{Precedence}

从基类继承的成员被 trait 插入的成员所覆盖。优先顺序是来自当前类的成员覆盖了 trait 的方法，而 trait 则覆盖了被继承的方法。

从基类继承的成员被插入的 SayWorld Trait 中的 MyHelloWorld 方法所覆盖。其行为 MyHelloWorld 类中定义的方法一致。优先顺序是当前类中的方法会覆盖 trait 方法，而 trait 方法又覆盖了基类中的方法。

\begin{lstlisting}[language=PHP]
<?php
class Base {
    public function sayHello() {
        echo 'Hello ';
    }
}

trait SayWorld {
    public function sayHello() {
        parent::sayHello();
        echo 'World!';
    }
}

class MyHelloWorld extends Base {
    use SayWorld;
}

$o = new MyHelloWorld();
$o->sayHello();
?>
\end{lstlisting}


以上例程会输出：

\begin{verbatim}
Hello World!
\end{verbatim}

\begin{lstlisting}[language=PHP]
<?php
trait HelloWorld {
    public function sayHello() {
        echo 'Hello World!';
    }
}

class TheWorldIsNotEnough {
    use HelloWorld;
    public function sayHello() {
        echo 'Hello Universe!';
    }
}

$o = new TheWorldIsNotEnough();
$o->sayHello();
?>
\end{lstlisting}


以上例程会输出：

\begin{verbatim}
Hello Universe!
\end{verbatim}

\section{Multiple Traits}


通过逗号分隔，在 use 声明列出多个 trait，可以都插入到一个类中。

\begin{lstlisting}[language=PHP]
<?php
trait Hello {
    public function sayHello() {
        echo 'Hello ';
    }
}

trait World {
    public function sayWorld() {
        echo 'World';
    }
}

class MyHelloWorld {
    use Hello, World;
    public function sayExclamationMark() {
        echo '!';
    }
}

$o = new MyHelloWorld();
$o->sayHello();
$o->sayWorld();
$o->sayExclamationMark();
?>
\end{lstlisting}

以上例程会输出：

\begin{verbatim}
Hello World!
\end{verbatim}



\section{Conflict Resolution}

如果两个 trait 都插入了一个同名的方法，如果没有明确解决冲突将会产生一个致命错误。

为了解决多个 trait 在同一个类中的命名冲突，需要使用 insteadof 操作符来明确指定使用冲突方法中的哪一个。

以上方式仅允许排除掉其它方法，as 操作符可以将其中一个冲突的方法以另一个名称来引入。

在本例中 Talker 使用了 trait A 和 B。由于 A 和 B 有冲突的方法，其定义了使用 trait B 中的 smallTalk 以及 trait A 中的 bigTalk。

Aliased\_Talker 使用了 as 操作符来定义了 talk 来作为 B 的 bigTalk 的别名。

\begin{lstlisting}[language=PHP]
<?php
trait A {
    public function smallTalk() {
        echo 'a';
    }
    public function bigTalk() {
        echo 'A';
    }
}

trait B {
    public function smallTalk() {
        echo 'b';
    }
    public function bigTalk() {
        echo 'B';
    }
}

class Talker {
    use A, B {
        B::smallTalk insteadof A;
        A::bigTalk insteadof B;
    }
}

class Aliased_Talker {
    use A, B {
        B::smallTalk insteadof A;
        A::bigTalk insteadof B;
        B::bigTalk as talk;
    }
}
?>
\end{lstlisting}




\section{Method Visibility}

使用 as 语法还可以用来调整方法的访问控制。

\begin{lstlisting}[language=PHP]
<?php
trait HelloWorld {
    public function sayHello() {
        echo 'Hello World!';
    }
}

// 修改 sayHello 的访问控制
class MyClass1 {
    use HelloWorld { sayHello as protected; }
}

// 给方法一个改变了访问控制的别名
// 原版 sayHello 的访问控制则没有发生变化
class MyClass2 {
    use HelloWorld { sayHello as private myPrivateHello; }
}
?>
\end{lstlisting}




\section{Traits Composed from Traits}

正如类能够使用 trait 一样，其它 trait 也能够使用 trait。在 trait 定义时通过使用一个或多个 trait，它能够组合其它 trait 中的部分或全部成员。

\begin{lstlisting}[language=PHP]
<?php
trait Hello {
    public function sayHello() {
        echo 'Hello ';
    }
}

trait World {
    public function sayWorld() {
        echo 'World!';
    }
}

trait HelloWorld {
    use Hello, World;
}

class MyHelloWorld {
    use HelloWorld;
}

$o = new MyHelloWorld();
$o->sayHello();
$o->sayWorld();
?>
\end{lstlisting}

以上例程会输出：

\begin{verbatim}
Hello World!
\end{verbatim}




\section{Abstract Trait Members}



为了对使用的类施加强制要求，trait 支持抽象方法的使用。



\begin{lstlisting}[language=PHP]
通过抽象方法来进行强制要求
<?php
trait Hello {
    public function sayHelloWorld() {
        echo 'Hello'.$this->getWorld();
    }
    abstract public function getWorld();
}

class MyHelloWorld {
    private $world;
    use Hello;
    public function getWorld() {
        return $this->world;
    }
    public function setWorld($val) {
        $this->world = $val;
    }
}
?>
\end{lstlisting}






\section{Static Trait Members}

静态变量可以被 trait 的方法引用，但不能被 trait 定义。但是 trait 能够为使用的类定义静态方法。


\begin{lstlisting}[language=PHP]
静态变量
<?php
trait Counter {
    public function inc() {
        static $c = 0;
        $c = $c + 1;
        echo "$c\n";
    }
}

class C1 {
    use Counter;
}

class C2 {
    use Counter;
}

$o = new C1(); $o->inc(); // echo 1
$p = new C2(); $p->inc(); // echo 1
?>
\end{lstlisting}



\begin{lstlisting}[language=PHP]
静态方法
<?php
trait StaticExample {
    public static function doSomething() {
        return 'Doing something';
    }
}

class Example {
    use StaticExample;
}

Example::doSomething();
?>
\end{lstlisting}





\section{Trait Properties}

Trait 同样可以定义属性。

\begin{lstlisting}[language=PHP]
定义属性
<?php
trait PropertiesTrait {
    public $x = 1;
}

class PropertiesExample {
    use PropertiesTrait;
}

$example = new PropertiesExample;
$example->x;
?>
\end{lstlisting}

如果 trait 定义了一个属性，那类将不能定义同样名称的属性，否则会产生一个错误。如果该属性在类中的定义与在 trait 中的定义兼容（同样的可见性和初始值）则错误的级别是 E\_STRICT，否则是一个致命错误。

\begin{lstlisting}[language=PHP]
解决冲突
<?php
trait PropertiesTrait {
    public $same = true;
    public $different = false;
}

class PropertiesExample {
    use PropertiesTrait;
    public $same = true; // Strict Standards
    public $different = true; // 致命错误
}
?>
\end{lstlisting}

\chapter{Overloading}



PHP所提供的"重载"（overloading）\footnote{PHP中的"重载"与其它绝大多数面向对象语言不同。传统的"重载"是用于提供多个同名的类方法，但各方法的参数类型和个数不同。}是指动态地"创建"类属性和方法，并通过魔术方法（magic methods）来实现，这些魔术方法的参数都不能通过引用传递。

所有的重载方法都必须被声明为 public。

当调用当前环境下未定义或不可见的类属性或方法时，重载方法会被调用。"不可访问属性（inaccessible properties）"和"不可访问方法（inaccessible methods）"用来称呼这些未定义或不可见的类属性或方法。


\section{Property Overloading}


\begin{lstlisting}[language=PHP]
public void __set ( string $name , mixed $value )
public mixed __get ( string $name )
public bool __isset ( string $name )
public void __unset ( string $name )
\end{lstlisting}

在给不可访问属性赋值时，\_\_set() 会被调用。

读取不可访问属性的值时，\_\_get() 会被调用。

当对不可访问属性调用 isset() 或 empty() 时，\_\_isset()\footnote{自PHP 5.1.0起，新增\_\_isset() 魔术方法。} 会被调用。

当对不可访问属性调用 unset() 时，\_\_unset()\footnote{自PHP 5.1.0起，新增\_\_unset() 两个魔术方法。} 会被调用。

参数 \$name 是指要操作的变量名称。\_\_set() 方法的 \$value 参数指定了 \$name 变量的值。

属性重载只能在对象中进行。在静态方法中，这些魔术方法将不会被调用。所以这些方法都不能被 声明为 static。从 PHP 5.3.0 起, 将这些魔术方法定义为 static 会产生一个警告。

因为 PHP 处理赋值运算的方式，\_\_set() 的返回值将被忽略。类似的, 在下面这样的链式赋值中，\_\_get() 不会被调用：\verb|$a = $obj->b = 8; |


在除 isset() 外的其它语言结构中无法使用重载的属性，这意味着当对一个重载的属性使用 empty() 时，重载魔术方法将不会被调用。为避开此限制，必须将重载属性赋值到本地变量再使用 empty()。


\begin{lstlisting}[language=PHP]
使用 __get()，__set()，__isset() 和 __unset() 进行属性重载
<?php
class PropertyTest {
     /**  被重载的数据保存在此  */
    private $data = array();

 
     /**  重载不能被用在已经定义的属性  */
    public $declared = 1;

     /**  只有从类外部访问这个属性时，重载才会发生 */
    private $hidden = 2;

    public function __set($name, $value) 
    {
        echo "Setting '$name' to '$value'\n";
        $this->data[$name] = $value;
    }

    public function __get($name) 
    {
        echo "Getting '$name'\n";
        if (array_key_exists($name, $this->data)) {
            return $this->data[$name];
        }

        $trace = debug_backtrace();
        trigger_error(
            'Undefined property via __get(): ' . $name .
            ' in ' . $trace[0]['file'] .
            ' on line ' . $trace[0]['line'],
            E_USER_NOTICE);
        return null;
    }

    /**  PHP 5.1.0之后版本 */
    public function __isset($name) 
    {
        echo "Is '$name' set?\n";
        return isset($this->data[$name]);
    }

    /**  PHP 5.1.0之后版本 */
    public function __unset($name) 
    {
        echo "Unsetting '$name'\n";
        unset($this->data[$name]);
    }

    /**  非魔术方法  */
    public function getHidden() 
    {
        return $this->hidden;
    }
}


echo "<pre>\n";

$obj = new PropertyTest;

$obj->a = 1;
echo $obj->a . "\n\n";

var_dump(isset($obj->a));
unset($obj->a);
var_dump(isset($obj->a));
echo "\n";

echo $obj->declared . "\n\n";

echo "Let's experiment with the private property named 'hidden':\n";
echo "Privates are visible inside the class, so __get() not used...\n";
echo $obj->getHidden() . "\n";
echo "Privates not visible outside of class, so __get() is used...\n";
echo $obj->hidden . "\n";
?>
\end{lstlisting}

以上例程会输出：

\begin{verbatim}
Setting 'a' to '1'
Getting 'a'
1

Is 'a' set?
bool(true)
Unsetting 'a'
Is 'a' set?
bool(false)

1

Let's experiment with the private property named 'hidden':
Privates are visible inside the class, so __get() not used...
2
Privates not visible outside of class, so __get() is used...
Getting 'hidden'


Notice:  Undefined property via __get(): hidden in <file> on line 70 in <file> on line 29
\end{verbatim}



\section{Method Overloading}


\begin{lstlisting}[language=PHP]
public mixed __call ( string $name , array $arguments )
public static mixed __callStatic ( string $name , array $arguments )
\end{lstlisting}

在对象中调用一个不可访问方法时，\_\_call() 会被调用。

用静态方式中调用一个不可访问方法时，\_\_callStatic()\footnote{自PHP 5.3.0起，新增 \_\_callStatic()魔术方法。可见性未设置为 public 或未声明为 static 的时候会产生一个警告。} 会被调用。

\$name 参数是要调用的方法名称。\$arguments 参数是一个枚举数组，包含着要传递给方法 \$name 的参数。

\begin{lstlisting}[language=PHP]
使用 __call() 和 __callStatic() 对方法重载
<?php
class MethodTest 
{
    public function __call($name, $arguments) 
    {
        // 注意: $name 的值区分大小写
        echo "Calling object method '$name' "
             . implode(', ', $arguments). "\n";
    }

    /**  PHP 5.3.0之后版本  */
    public static function __callStatic($name, $arguments) 
    {
        // 注意: $name 的值区分大小写
        echo "Calling static method '$name' "
             . implode(', ', $arguments). "\n";
    }
}

$obj = new MethodTest;
$obj->runTest('in object context');

MethodTest::runTest('in static context');  // PHP 5.3.0之后版本
?>
\end{lstlisting}

以上例程会输出：

\begin{verbatim}
Calling object method 'runTest' in object context
Calling static method 'runTest' in static context
\end{verbatim}


\chapter{Object Iteration}


\section{Iterations}


PHP 5 提供了一种定义对象的方法使其可以通过单元列表来遍历，例如用 foreach 语句。默认情况下，所有可见属性都将被用于遍历。


\begin{lstlisting}[language=PHP]
<?php
class MyClass
{
    public $var1 = 'value 1';
    public $var2 = 'value 2';
    public $var3 = 'value 3';

    protected $protected = 'protected var';
    private   $private   = 'private var';

    function iterateVisible() {
       echo "MyClass::iterateVisible:\n";
       foreach($this as $key => $value) {
           print "$key => $value\n";
       }
    }
}

$class = new MyClass();

foreach($class as $key => $value) {
    print "$key => $value\n";
}
echo "\n";


$class->iterateVisible();

?>
\end{lstlisting}

以上例程会输出：

\begin{verbatim}
var1 => value 1
var2 => value 2
var3 => value 3

MyClass::iterateVisible:
var1 => value 1
var2 => value 2
var3 => value 3
protected => protected var
private => private var
\end{verbatim}

如上所示，foreach 遍历了所有其能够访问的可见属性。

更进一步，可以实现 Iterator 接口。可以让对象自行决定如何遍历以及每次遍历时那些值可用。

\begin{lstlisting}[language=PHP]
<?php
class MyIterator implements Iterator
{
    private $var = array();

    public function __construct($array)
    {
        if (is_array($array)) {
            $this->var = $array;
        }
    }

    public function rewind() {
        echo "rewinding\n";
        reset($this->var);
    }

    public function current() {
        $var = current($this->var);
        echo "current: $var\n";
        return $var;
    }

    public function key() {
        $var = key($this->var);
        echo "key: $var\n";
        return $var;
    }

    public function next() {
        $var = next($this->var);
        echo "next: $var\n";
        return $var;
    }

    public function valid() {
        $var = $this->current() !== false;
        echo "valid: {$var}\n";
        return $var;
    }
}

$values = array(1,2,3);
$it = new MyIterator($values);

foreach ($it as $a => $b) {
    print "$a: $b\n";
}
?>
\end{lstlisting}


以上例程会输出：

\begin{verbatim}
rewinding
current: 1
valid: 1
current: 1
key: 0
0: 1
next: 2
current: 2
valid: 1
current: 2
key: 1
1: 2
next: 3
current: 3
valid: 1
current: 3
key: 2
2: 3
next:
current:
valid:
\end{verbatim}

可以用 IteratorAggregate 接口以替代实现所有的 Iterator 方法。IteratorAggregate 只需要实现一个方法 IteratorAggregate::getIterator()，其应返回一个实现了 Iterator 的类的实例。

\begin{lstlisting}[language=PHP]
<?php
class MyCollection implements IteratorAggregate
{
    private $items = array();
    private $count = 0;

    // Required definition of interface IteratorAggregate
    public function getIterator() {
        return new MyIterator($this->items);
    }

    public function add($value) {
        $this->items[$this->count++] = $value;
    }
}

$coll = new MyCollection();
$coll->add('value 1');
$coll->add('value 2');
$coll->add('value 3');

foreach ($coll as $key => $val) {
    echo "key/value: [$key -> $val]\n\n";
}
?>
\end{lstlisting}

以上例程会输出：

\begin{verbatim}
rewinding
current: value 1
valid: 1
current: value 1
key: 0
key/value: [0 -> value 1]

next: value 2
current: value 2
valid: 1
current: value 2
key: 1
key/value: [1 -> value 2]

next: value 3
current: value 3
valid: 1
current: value 3
key: 2
key/value: [2 -> value 3]

next:
current:
valid:
\end{verbatim}

PHP 5.5 及以后版本的用户也可参考生成器，其提供了另一方法来定义 Iterators。


\section{Generators}



生成器提供了一种更容易的方法来实现简单的对象迭代，但没有实现一个具有 Iterator 接口的类所带来的性能开销和复杂性。

生成器允许你在 foreach 代码块中写代码来迭代一组数据而不需要在内存中创建一个数组, 那会使你的内存达到上限，或者会占据可观的处理时间。相反，你可以写一个生成器函数，就像一个普通的自定义函数一样, 和普通函数只返回一次不同的是, 生成器可以根据需要 yield 多次，以便生成需要迭代的值。

一个简单的例子就是使用生成器来重新实现 range() 函数。 标准的 range() 函数需要为其中的每一个返回值在内存中生成一个数组, 结果就是生成一个很大的数组。 比如，调用 range(0, 1000000) 将导致内存占用超过 100 MB。

做为一种替代方法, 我们可以实现一个 xrange() 生成器, 只需要足够的内存来创建 Iterator 对象并在内部跟踪生成器的当前状态，这样只需要不到1K字节的内存。

\begin{example}
将 range() 实现为生成器
\begin{lstlisting}[language=PHP]
<?php
function xrange($start, $limit, $step = 1) {
    if ($start < $limit) {
        if ($step <= 0) {
            throw new LogicException('Step must be +ve');
        }

        for ($i = $start; $i <= $limit; $i += $step) {
            yield $i;
        }
    } else {
        if ($step >= 0) {
            throw new LogicException('Step must be -ve');
        }

        for ($i = $start; $i >= $limit; $i += $step) {
            yield $i;
        }
    }
}

/* Note that both range() and xrange() result in the same
 * output below. */

echo 'Single digit odd numbers from range():  ';
foreach (range(1, 9, 2) as $number) {
    echo "$number ";
}
echo "\n";

echo 'Single digit odd numbers from xrange(): ';
foreach (xrange(1, 9, 2) as $number) {
    echo "$number ";
}
?>
\end{lstlisting}
\end{example}

以上例程会输出：

\begin{verbatim}
Single digit odd numbers from range():  1 3 5 7 9 
Single digit odd numbers from xrange(): 1 3 5 7 9 
\end{verbatim}


\section{Generator syntax}

A generator function looks just like a normal function, except that instead of returning a value, a generator yields as many values as it needs to.

When a generator function is called, it returns an object that can be iterated over. When you iterate over that object (for instance, via a foreach loop), PHP will call the generator function each time it needs a value, then saves the state of the generator when the generator yields a value so that it can be resumed when the next value is required.

Once there are no more values to be yielded, then the generator function can simply exit, and the calling code continues just as if an array has run out of values.

A generator cannot return a value: doing so will result in a compile error. An empty return statement is valid syntax within a generator and it will terminate the generator.


\section{yield keyword}


The heart of a generator function is the yield keyword. In its simplest form, a yield statement looks much like a return statement, except that instead of stopping execution of the function and returning, yield instead provides a value to the code looping over the generator and pauses execution of the generator function.


\begin{example}
A simple example of yielding values
\begin{lstlisting}[language=PHP]
<?php
function gen_one_to_three() {
    for ($i = 1; $i <= 3; $i++) {
        // Note that $i is preserved between yields.
        yield $i;
    }
}

$generator = gen_one_to_three();
foreach ($generator as $value) {
    echo "$value\n";
}
?>
\end{lstlisting}
\end{example}


以上例程会输出：

\begin{verbatim}
1
2
3
\end{verbatim}

Internally, sequential integer keys will be paired with the yielded values, just as with a non-associative array.

If you use yield in an expression context (for example, on the right hand side of an assignment), you must surround the yield statement with parentheses. For example, this is valid:

\begin{lstlisting}[language=PHP]
$data = (yield $value);
\end{lstlisting}

But this is not, and will result in a parse error:

\begin{lstlisting}[language=PHP]
$data = yield $value;
\end{lstlisting}

This syntax may be used in conjunction with the send() method on Generator objects.


\section{Yielding values with keys}


PHP also supports associative arrays, and generators are no different. In addition to yielding simple values, as shown above, you can also yield a key at the same time.

The syntax for yielding a key/value pair is very similar to that used to define an associative array, as shown below.



\begin{example}
Yielding a key/value pair
\begin{lstlisting}[language=PHP]
<?php
/* The input is semi-colon separated fields, with the first
 * field being an ID to use as a key. */

$input = <<<'EOF'
1;PHP;Likes dollar signs
2;Python;Likes whitespace
3;Ruby;Likes blocks
EOF;

function input_parser($input) {
    foreach (explode("\n", $input) as $line) {
        $fields = explode(';', $line);
        $id = array_shift($fields);

        yield $id => $fields;
    }
}

foreach (input_parser($input) as $id => $fields) {
    echo "$id:\n";
    echo "    $fields[0]\n";
    echo "    $fields[1]\n";
}
?>
\end{lstlisting}
\end{example}

以上例程会输出：

\begin{verbatim}
1:
    PHP
    Likes dollar signs
2:
    Python
    Likes whitespace
3:
    Ruby
    Likes blocks
\end{verbatim}

As with the simple value yields shown earlier, yielding a key/value pair in an expression context requires the yield statement to be parenthesised:

\begin{lstlisting}[language=PHP]
$data = (yield $key => $value);
\end{lstlisting}


\section{Yielding null values}

Yield can be called without an argument to yield a NULL value with an automatic key.


\begin{example}
Yielding NULLs
\begin{lstlisting}[language=PHP]
<?php
function gen_three_nulls() {
    foreach (range(1, 3) as $i) {
        yield;
    }
}

var_dump(iterator_to_array(gen_three_nulls()));
?>
\end{lstlisting}
\end{example}

以上例程会输出：

\begin{verbatim}
array(3) {
  [0]=>
  NULL
  [1]=>
  NULL
  [2]=>
  NULL
}
\end{verbatim}


\section{Yielding by reference}

Generator functions are able to yield values by reference as well as by value. This is done in the same way as returning references from functions: by prepending an ampersand to the function name.

\begin{example}
Yielding values by reference
\begin{lstlisting}[language=PHP]
<?php
function &gen_reference() {
    $value = 3;

    while ($value > 0) {
        yield $value;
    }
}

/* Note that we can change $number within the loop, and
 * because the generator is yielding references, $value
 * within gen_reference() changes. */
foreach (gen_reference() as &$number) {
    echo (--$number).'... ';
}
?>
\end{lstlisting}
\end{example}

以上例程会输出：

\begin{verbatim}
2... 1... 0... 
\end{verbatim}


\section{Generator objects}


When a generator function is called for the first time, an object of the internal Generator class is returned. This object implements the Iterator interface in much the same way as a forward-only iterator object would.

Most methods in the Generator class have the same semantics as the methods in the Iterator interface, but generator objects also have one additional method: send().

Generator objects cannot be instantiated via new.



\begin{example}
The Generator class
\begin{lstlisting}[language=PHP]
<?php
class Generator implements Iterator {
    public function rewind();          // Rewinds the iterator. If
                                       // iteration has already begun,
                                       // this will throw an exception.

    public function valid();           // Returns false if the
                                       // iterator has been closed.
                                       // Otherwise returns true.

    public function current();         // Returns the yielded value.

    public function key();             // Returns the yielded key.

    public function next();            // Resumes execution of the
                                       // generator.
    
    public function send($value);      // Sends the given value to the
                                       // generator as the result of
                                       // the yield expression and
                                       // resumes execution of the
                                       // generator.
}
?>
\end{lstlisting}
\end{example}


\section{Generator::send()}

Generator::send() allows values to be injected into generator functions while iterating over them. The injected value will be returned from the yield statement and can then be used like any other variable within the generator function.


\begin{example}
Using Generator::send() to inject values
\begin{lstlisting}[language=PHP]
<?php
function printer() {
    while (true) {
        $string = yield;
        echo $string;
    }
}

$printer = printer();
$printer->send('Hello world!');
?>
\end{lstlisting}
\end{example}

以上例程会输出：

\begin{verbatim}
Hello world!
\end{verbatim}


\section{Generators \& Iterator objects}

The primary advantage of generators is their simplicity. Much less boilerplate code has to be written compared to implementing an Iterator class, and the code is generally much more readable. For example, the following function and class are equivalent:


\begin{example}
Comparing generators with Iterator objects
\begin{lstlisting}[language=PHP]
<?php
function getLinesFromFile($fileName) {
    if (!$fileHandle = fopen($fileName, 'r')) {
        return;
    }
 
    while (false !== $line = fgets($fileHandle)) {
        yield $line;
    }
 
    fclose($fileHandle);
}

// versus...

class LineIterator implements Iterator {
    protected $fileHandle;
 
    protected $line;
    protected $i;
 
    public function __construct($fileName) {
        if (!$this->fileHandle = fopen($fileName, 'r')) {
            throw new RuntimeException('Couldn\'t open file "' . $fileName . '"');
        }
    }
 
    public function rewind() {
        fseek($this->fileHandle, 0);
        $this->line = fgets($this->fileHandle);
        $this->i = 0;
    }
 
    public function valid() {
        return false !== $this->line;
    }
 
    public function current() {
        return $this->line;
    }
 
    public function key() {
        return $this->i;
    }
 
    public function next() {
        if (false !== $this->line) {
            $this->line = fgets($this->fileHandle);
            $this->i++;
        }
    }
 
    public function __destruct() {
        fclose($this->fileHandle);
    }
}
?>
\end{lstlisting}
\end{example}

This flexibility does come at a cost, however: generators are forward-only iterators, and cannot be rewound once iteration has started. This also means that the same generator can't be iterated over multiple times: the generator will need to either be rebuilt by calling the generator function again, or cloned via the \textcolor{Blue}{\texttt{clone}} keyword.


\begin{example}

\begin{lstlisting}[language=PHP]

\end{lstlisting}
\end{example}





\chapter{Magic Methods}


\_\_construct()，\_\_destruct()，\_\_call()，\_\_callStatic()，\_\_get()，\_\_set()，\_\_isset()，\_\_unset()，\_\_sleep()，\_\_wakeup()，\_\_toString()，\_\_invoke()，\_\_set\_state() 和 \_\_clone() 等方法在 PHP 中被称为"魔术方法"（Magic methods）。

PHP 将所有以 \_\_（两个下划线）开头的类方法保留为魔术方法。所以在定义类方法时，除了上述魔术方法，建议不要以 \_\_ 为前缀。在命名自己的类方法时不能使用这些方法名，除非是想使用其魔术功能。


\section{\_\_sleep() \& \_\_wakeup()}


\begin{lstlisting}[language=PHP]
public array __sleep ( void )
void __wakeup ( void )
\end{lstlisting}

serialize() 函数会检查类中是否存在一个魔术方法\_\_sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E\_NOTICE 级别的错误。

\_\_sleep() 不能返回父类的私有成员的名字，这样做会产生一个 E\_NOTICE 级别的错误，可以用 Serializable 接口来替代。

\_\_sleep() 方法常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。

与之相反， unserialize() 会检查是否存在一个 \_\_wakeup() 方法。如果存在，则会先调用 \_\_wakeup 方法，预先准备对象需要的资源。

\_\_wakeup() 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。


\begin{lstlisting}[language=PHP]
<?php
class Connection 
{
    protected $link;
    private $server, $username, $password, $db;
    
    public function __construct($server, $username, $password, $db)
    {
        $this->server = $server;
        $this->username = $username;
        $this->password = $password;
        $this->db = $db;
        $this->connect();
    }
    
    private function connect()
    {
        $this->link = mysql_connect($this->server, $this->username, $this->password);
        mysql_select_db($this->db, $this->link);
    }
    
    public function __sleep()
    {
        return array('server', 'username', 'password', 'db');
    }
    
    public function __wakeup()
    {
        $this->connect();
    }
}
?>
\end{lstlisting}

\section{\_\_toString()}


\begin{lstlisting}[language=PHP]
public string __toString ( void )
\end{lstlisting}

\_\_toString() 方法用于一个类被当成字符串时应怎样回应。例如 echo \$obj; 应该显示些什么。此方法必须返回一个字符串，否则将发出一条 E\_RECOVERABLE\_ERROR 级别的致命错误。

\begin{lstlisting}[language=PHP]
不能在 \_\_toString() 方法中抛出异常，这么做会导致致命错误。
\end{lstlisting}


\begin{lstlisting}[language=PHP]
<?php
// Declare a simple class
class TestClass
{
    public $foo;

    public function __construct($foo) 
    {
        $this->foo = $foo;
    }

    public function __toString() {
        return $this->foo;
    }
}

$class = new TestClass('Hello');
echo $class;
?>
\end{lstlisting}

以上例程会输出：

\begin{verbatim}
Hello
\end{verbatim}

需要指出的是在 PHP 5.2.0 之前，\_\_toString() 方法只有在直接使用于 echo 或 print 时才能生效。PHP 5.2.0 之后，则可以在任何字符串环境生效（例如通过 printf()，使用 \%s 修饰符），但不能用于非字符串环境（如使用 \%d 修饰符）。自 PHP 5.2.0 起，如果将一个未定义 \_\_toString() 方法的对象转换为字符串，会产生 E\_RECOVERABLE\_ERROR 级别的错误。

\section{\_\_invoke()}


\begin{lstlisting}[language=PHP]
mixed __invoke ([ $... ] )
\end{lstlisting}

自PHP 5.3.0 及以上版本起，当尝试以调用函数的方式调用一个对象时，\_\_invoke() 方法会被自动调用。

\begin{lstlisting}[language=PHP]
<?php
class CallableClass 
{
    function __invoke($x) {
        var_dump($x);
    }
}
$obj = new CallableClass;
$obj(5);
var_dump(is_callable($obj));
?>
\end{lstlisting}

以上例程会输出：

\begin{verbatim}
int(5)
bool(true)
\end{verbatim}

\section{\_\_set\_state()}


\begin{lstlisting}[language=PHP]
static object __set_state ( array $properties )
\end{lstlisting}

自 PHP 5.1.0 起当调用 var\_export() 导出类时，此静态方法会被调用。

本方法的唯一参数是一个数组，其中包含按 \texttt{array('property' => value, ...)} 格式排列的类属性。

\begin{lstlisting}[language=PHP]
<?php

class A
{
    public $var1;
    public $var2;

    public static function __set_state($an_array) // As of PHP 5.1.0
    {
        $obj = new A;
        $obj->var1 = $an_array['var1'];
        $obj->var2 = $an_array['var2'];
        return $obj;
    }
}

$a = new A;
$a->var1 = 5;
$a->var2 = 'foo';

eval('$b = ' . var_export($a, true) . ';'); // $b = A::__set_state(array(
                                            //    'var1' => 5,
                                            //    'var2' => 'foo',
                                            // ));
var_dump($b);

?>
\end{lstlisting}

以上例程会输出：

\begin{verbatim}
object(A)#2 (2) {
  ["var1"]=>
  int(5)
  ["var2"]=>
  string(3) "foo"
}
\end{verbatim}


\chapter{Final Keyword}

PHP 5 新增了一个 final 关键字。如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。

\begin{lstlisting}[language=PHP]
<?php
class BaseClass {
   public function test() {
       echo "BaseClass::test() called\n";
   }
   
   final public function moreTesting() {
       echo "BaseClass::moreTesting() called\n";
   }
}

class ChildClass extends BaseClass {
   public function moreTesting() {
       echo "ChildClass::moreTesting() called\n";
   }
}
// Results in Fatal error: Cannot override final method BaseClass::moreTesting()
?>
\end{lstlisting}


属性不能被定义为 final，只有类和方法才能被定义为 final。



\begin{lstlisting}[language=PHP]
<?php
final class BaseClass {
   public function test() {
       echo "BaseClass::test() called\n";
   }
   
   // 这里无论你是否将方法声明为final，都没有关系
   final public function moreTesting() {
       echo "BaseClass::moreTesting() called\n";
   }
}

class ChildClass extends BaseClass {
}
// 产生 Fatal error: Class ChildClass may not inherit from final class (BaseClass)
?>
\end{lstlisting}

\chapter{Object Cloning}

在多数情况下，我们并不需要完全复制一个对象来获得其中属性。但有一个情况下确实需要：如果你有一个 GTK 窗口对象，该对象持有窗口相关的资源。你可能会想复制一个新的窗口，保持所有属性与原来的窗口相同，但必须是一个新的对象（因为如果不是新的对象，那么一个窗口中的改变就会影响到另一个窗口）。还有一种情况：如果对象 A 中保存着对象 B 的引用，当你复制对象 A 时，你想其中使用的对象不再是对象 B 而是 B 的一个副本，那么你必须得到对象 A 的一个副本。

对象复制可以通过 clone 关键字来完成（如果可能，这将调用对象的 \_\_clone() 方法）。对象中的 \_\_clone() 方法不能被直接调用。

\begin{lstlisting}[language=PHP]
$copy_of_object = clone $object;
\end{lstlisting}

当对象被复制后，PHP 5 会对对象的所有属性执行一个浅复制（shallow copy）。所有的引用属性 仍然会是一个指向原来的变量的引用。






\begin{lstlisting}[language=PHP]
void __clone ( void )
\end{lstlisting}

当复制完成时，如果定义了 \_\_clone() 方法，则新创建的对象（复制生成的对象）中的 \_\_clone() 方法会被调用，可用于修改属性的值（如果有必要的话）。

\begin{lstlisting}[language=PHP]
<?php
class SubObject
{
    static $instances = 0;
    public $instance;

    public function __construct() {
        $this->instance = ++self::$instances;
    }

    public function __clone() {
        $this->instance = ++self::$instances;
    }
}

class MyCloneable
{
    public $object1;
    public $object2;

    function __clone()
    {
      
        // 强制复制一份this->object， 否则仍然指向同一个对象
        $this->object1 = clone $this->object1;
    }
}

$obj = new MyCloneable();

$obj->object1 = new SubObject();
$obj->object2 = new SubObject();

$obj2 = clone $obj;


print("Original Object:\n");
print_r($obj);

print("Cloned Object:\n");
print_r($obj2);

?>
\end{lstlisting}

以上例程会输出：

\begin{verbatim}
Original Object:
MyCloneable Object
(
    [object1] => SubObject Object
        (
            [instance] => 1
        )

    [object2] => SubObject Object
        (
            [instance] => 2
        )

)
Cloned Object:
MyCloneable Object
(
    [object1] => SubObject Object
        (
            [instance] => 3
        )

    [object2] => SubObject Object
        (
            [instance] => 2
        )

)
\end{verbatim}


\chapter{Objects Comparison}

PHP 5 中的对象比较要比 PHP 4 中复杂，所期望的结果更符合一个面向对象语言。

当使用比较运算符（==）比较两个对象变量时，比较的原则是：如果两个对象的属性和属性值 都相等，而且两个对象是同一个类的实例，那么这两个对象变量相等。

而如果使用全等运算符（===），这两个对象变量一定要指向某个类的同一个实例（即同一个对象）。

通过下面的示例可以理解以上原则。


\begin{lstlisting}[language=PHP]
<?php
function bool2str($bool)
{
    if ($bool === false) {
        return 'FALSE';
    } else {
        return 'TRUE';
    }
}

function compareObjects(&$o1, &$o2)
{
    echo 'o1 == o2 : ' . bool2str($o1 == $o2) . "\n";
    echo 'o1 != o2 : ' . bool2str($o1 != $o2) . "\n";
    echo 'o1 === o2 : ' . bool2str($o1 === $o2) . "\n";
    echo 'o1 !== o2 : ' . bool2str($o1 !== $o2) . "\n";
}

class Flag
{
    public $flag;

    function Flag($flag = true) {
        $this->flag = $flag;
    }
}

class OtherFlag
{
    public $flag;

    function OtherFlag($flag = true) {
        $this->flag = $flag;
    }
}

$o = new Flag();
$p = new Flag();
$q = $o;
$r = new OtherFlag();

echo "Two instances of the same class\n";
compareObjects($o, $p);

echo "\nTwo references to the same instance\n";
compareObjects($o, $q);

echo "\nInstances of two different classes\n";
compareObjects($o, $r);
?>
\end{lstlisting}

以上例程会输出：

\begin{verbatim}
Two instances of the same class
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : FALSE
o1 !== o2 : TRUE

Two references to the same instance
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : TRUE
o1 !== o2 : FALSE

Instances of two different classes
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE
\end{verbatim}



PHP 扩展中可以自行定义对象比较的原则。


\chapter{Type Hinting}

PHP 5 可以使用类型约束。函数的参数可以指定必须为对象（在函数原型里面指定类的名字），接口，数组（PHP 5.1 起）或者 callable（PHP 5.4 起）。不过如果使用 NULL 作为参数的默认值，那么在调用函数的时候依然可以使用 NULL 作为实参。

如果一个类或接口指定了类型约束，则其所有的子类或实现也都如此。

类型约束不能用于标量类型如 int 或 string。Traits 也不允许。



\begin{lstlisting}[language=PHP]
<?php
//如下面的类
class MyClass
{
    /**
     * 测试函数
     * 第一个参数必须为 OtherClass 类的一个对象
     */
    public function test(OtherClass $otherclass) {
        echo $otherclass->var;
    }


    /**
     * 另一个测试函数
     * 第一个参数必须为数组 
     */
    public function test_array(array $input_array) {
        print_r($input_array);
    }
}

    /**
     * 第一个参数必须为递归类型
     */
    public function test_interface(Traversable $iterator) {
        echo get_class($iterator);
    }
    
    /**
     * 第一个参数必须为回调类型
     */
    public function test_callable(callable $callback, $data) {
        call_user_func($callback, $data);
    }
}

// OtherClass 类定义
class OtherClass {
    public $var = 'Hello World';
}
?>
\end{lstlisting}

函数调用的参数与定义的参数类型不一致时，会抛出一个可捕获的致命错误。

\begin{lstlisting}[language=PHP]
<?php
// 两个类的对象
$myclass = new MyClass;
$otherclass = new OtherClass;

// 致命错误：第一个参数必须是 OtherClass 类的一个对象
$myclass->test('hello');

// 致命错误：第一个参数必须为 OtherClass 类的一个实例
$foo = new stdClass;
$myclass->test($foo);

// 致命错误：第一个参数不能为 null
$myclass->test(null);

// 正确：输出 Hello World 
$myclass->test($otherclass);

// 致命错误：第一个参数必须为数组
$myclass->test_array('a string');

// 正确：输出数组
$myclass->test_array(array('a', 'b', 'c'));

// 正确：输出 ArrayObject
$myclass->test_interface(new ArrayObject(array()));

// 正确：输出 int(1)
$myclass->test_callable('var_dump', 1);
?>
\end{lstlisting}

类型约束不只是用在类的成员函数里，也能使用在函数里：


\begin{lstlisting}[language=PHP]
<?php
// 如下面的类
class MyClass {
    public $var = 'Hello World';
}

/**
 * 测试函数
 * 第一个参数必须是 MyClass 类的一个对象
 */
function MyFunction (MyClass $foo) {
    echo $foo->var;
}

// 正确
$myclass = new MyClass;
MyFunction($myclass);
?>
\end{lstlisting}

类型约束允许 NULL 值：


\begin{lstlisting}[language=PHP]
<?php

/* 接受 NULL 值 */
function test(stdClass $obj = NULL) {

}

test(NULL);
test(new stdClass);

?>
\end{lstlisting}


\chapter{Late Static Bindings}

自 PHP 5.3.0 起，PHP 增加了一个叫做后期静态绑定的功能，用于在继承范围内引用静态调用的类。

准确说，后期静态绑定工作原理是存储了在上一个“非转发调用”（non-forwarding call）的类名。当进行静态方法调用时，该类名即为明确指定的那个（通常在 :: 运算符左侧部分）；当进行非静态方法调用时，即为该对象所属的类。所谓的“转发调用”（forwarding call）指的是通过以下几种方式进行的静态调用：self::，parent::，static:: 以及 forward\_static\_call()。可用 get\_called\_class() 函数来得到被调用的方法所在的类名，static:: 则指出了其范围。

该功能从语言内部角度考虑被命名为“后期静态绑定”。“后期绑定”的意思是说，static:: 不再被解析为定义当前方法所在的类，而是在实际运行时计算的。也可以称之为“静态绑定”，因为它可以用于（但不限于）静态方法的调用。


\section{Limitations of self::}

使用 self:: 或者 \_\_CLASS\_\_ 对当前类的静态引用，取决于定义当前方法所在的类：


\begin{lstlisting}[language=PHP]
<?php
class A {
    public static function who() {
        echo __CLASS__;
    }
    public static function test() {
        self::who();
    }
}

class B extends A {
    public static function who() {
        echo __CLASS__;
    }
}

B::test();
?>
\end{lstlisting}

以上例程会输出：\verb|A|



\section{Late Static Bindings Usage}


后期静态绑定本想通过引入一个新的关键字表示运行时最初调用的类来绕过限制。简单地说，这个关键字能够让你在上述例子中调用 test() 时引用的类是 B 而不是 A。最终决定不引入新的关键字，而是使用已经预留的 static 关键字。

\begin{lstlisting}[language=PHP]
<?php
class A {
    public static function who() {
        echo __CLASS__;
    }
    public static function test() {
        static::who(); // 后期静态绑定从这里开始
    }
}

class B extends A {
    public static function who() {
        echo __CLASS__;
    }
}

B::test();
?>
\end{lstlisting}


以上例程会输出：\verb|B|

在非静态环境下，所调用的类即为该对象实例所属的类。由于 \$this-> 会在同一作用范围内尝试调用私有方法，而 static:: 则可能给出不同结果。另一个区别是 static:: 只能用于静态属性。

\begin{lstlisting}[language=PHP]
<?php
class A {
    private function foo() {
        echo "success!\n";
    }
    public function test() {
        $this->foo();
        static::foo();
    }
}

class B extends A {
   /* foo() will be copied to B, hence its scope will still be A and
    * the call be successful */
}

class C extends A {
    private function foo() {
        /* original method is replaced; the scope of the new one is C */
    }
}

$b = new B();
$b->test();
$c = new C();
$c->test();   //fails
?>
\end{lstlisting}

以上例程会输出：

\begin{verbatim}
success!
success!
success!

Fatal error:  Call to private method C::foo() from context 'A' in /tmp/test.php on line 9
\end{verbatim}


后期静态绑定的解析会一直到取得一个完全解析了的静态调用为止。另一方面，如果静态调用使用 parent:: 或者 self:: 将转发调用信息。



\begin{lstlisting}[language=PHP]
转发和非转发调用
<?php
class A {
    public static function foo() {
        static::who();
    }

    public static function who() {
        echo __CLASS__."\n";
    }
}

class B extends A {
    public static function test() {
        A::foo();
        parent::foo();
        self::foo();
    }

    public static function who() {
        echo __CLASS__."\n";
    }
}
class C extends B {
    public static function who() {
        echo __CLASS__."\n";
    }
}

C::test();
?>
\end{lstlisting}

以上例程会输出：

\begin{verbatim}
A
C
C
\end{verbatim}


\chapter{Objects and References}

在php5 的对象编程经常提到的一个关键点是“默认情况下对象是通过引用传递的”。但其实这不是完全正确的。下面通过一些例子来说明。

php的引用是别名，就是两个不同的变量名字指向相同的内容。在php5，一个对象变量已经不再保存整个对象的值。只是保存一个标识符来访问真正的对象内容。 当对象作为参数传递，作为结果返回，或者赋值给另外一个变量，另外一个变量跟原来的不是引用的关系，只是他们都保存着同一个标识符的拷贝，这个标识符指向同一个对象的真正内容。


\begin{lstlisting}[language=PHP]
<?php
class A {
    public $foo = 1;
}  

$a = new A;
$b = $a;     // $a ,$b都是同一个标识符的拷贝
             // ($a) = ($b) = <id>
$b->foo = 2;
echo $a->foo."\n";


$c = new A;
$d = &$c;    // $c ,$d是引用
             // ($c,$d) = <id>

$d->foo = 2;
echo $c->foo."\n";


$e = new A;

function foo($obj) {
    // ($obj) = ($e) = <id>
    $obj->foo = 2;
}

foo($e);
echo $e->foo."\n";

?>
\end{lstlisting}

以上例程会输出：

\begin{verbatim}
2
2
2
\end{verbatim}


\chapter{Object Serialization}


\section{Serializing objects - objects in sessions}

所有php里面的值都可以使用函数 serialize()来返回一个包含字节流的字符串来表示。 unserialize()函数能够重新把字符串变回php原来的值。 序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。

为了能够 unserialize()一个对象，这个对象的类必须已经定义过。如果序列化类A的一个对象，将会返回一个跟类A相关，而且包含了对象所有变量值的字符串。 如果要想在另外一个文件中解序列化一个对象，这个对象的类必须在解序列化之前定义，可以通过包含一个定义该类的文件或使用函数 spl\_autoload\_register()来实现。


\begin{lstlisting}[language=PHP]
<?php
// classa.inc:
  
  class A {
      public $one = 1;
    
      public function show_one() {
          echo $this->one;
      }
  }
  
// page1.php:

  include("classa.inc");
  
  $a = new A;
  $s = serialize($a);
  // 把变量$s保存起来以便文件page2.php能够读到
  file_put_contents('store', $s);

// page2.php:
  
  // 要正确了解序列化，必须包含下面一个文件
  include("classa.inc");

  $s = file_get_contents('store');
  $a = unserialize($s);

  // 现在可以使用对象$a里面的函数 show_one()
  $a->show_one();
?>
\end{lstlisting}

当一个应用程序使用函数 session\_register()来保存对象到会话中时，在每个页面结束的时候这些对象都会自动序列化，而在每个页面开始的时候又自动解序列化。 所以一旦对象被保存在会话中，整个应用程序的页面都能使用这些对象。

但是， session\_register()这个函数在php5.3.0已经废弃，而且在php6.0.0就不再支持，所以不要依赖这个函数。

在应用程序中序列化对象以便在之后使用，强烈推荐在整个应用程序都包含对象的类的定义。 不然有可能出现在解序列化对象的时候，没有找到该对象的类的定义，从而把没有方法的类\_\_PHP\_Incomplete\_Class\_Name作为该对象的类，导致返回一个没有用的对象。

所以在上面的例子中，当运行session\_register("a")，把变量\$a放在会话里之后，需要在每个页面都包含文件classa.inc，而不是只有文件page1.php和page2.php。


\chapter{OOP Changelog}

\zihao{6}

\begin{longtable}{|m{30pt}|m{350pt}|}
%%
\multicolumn{2}{r}{}
\tabularnewline\hline
版本	&说明
\endhead
%%

%%
\caption{PHP 5 OOP 模型的变更日志}\\
\hline
版本	&说明
\endfirsthead
%%

%%
\multicolumn{2}{r}{}
\endfoot
%%

%%
\endlastfoot
%%
\hline
5.4.0	 &如果一个 抽象 类定义了构造函数的签名，它将必须被实现。\\
\hline
5.3.3	 & 命名空间 中和类同名的方法不再被作为 构造函数。这个变更不影响非命名空间中的类。\\
\hline
5.3.0	 &类实现接口的方法所具有的默认值不再需要和接口的默认值一致。\\
\hline
5.3.0	 &现在它也能够通过一个变量来引用一个类（例如，echo \$classname::constant;）。 这个变量的值不能是一个保留关键词（比如，self、parent 或 static）。\\
\hline
5.3.0	 &如果重载方法被定义为 static 将导致一个 E\_WARNING 级别的错误。 同时它也需要强制使用 public 的可见性。\\
\hline
5.3.0	 &在 5.3.0 之前的版本，\_\_autoload 函数里抛出的异常不能被 catch 块结构捕获，并会导致一个致命错误。 现在在一个前提下 catch 块能够捕获 \_\_autoload 函数中抛出的错误。如果抛出一个自定义异常，这个自定义异常的类必须是可用的。否则 \_\_autoload 函数可能递归自动加载这个自定义异常类。\\
\hline
5.3.0	 & \_\_callStatic 方法。\\
\hline
5.3.0	 & heredoc 和 nowdoc 支持类的 常量 和属性的定义，heredoc 值必须和双引号字符串遵循同样的规则（比如，变量将被替换）。\\
\hline
5.3.0	 &后期静态绑定。\\
\hline
5.3.0	 & \_\_invoke 方法。\\
\hline
5.2.0	 &\_\_toString 方法仅在直接与 echo 或 print 使用时被调用。但是现在它能在任何字符串上下文被调用（比如在 printf() 中使用 \%s ），但不是在其他类型的上下文被调用（例如 \%d 修饰符）。 自 PHP 5.2.0 起，将不具有 \_\_toString 方法的对象转化为字符串将导致一个 E\_RECOVERABLE\_ERROR 级别的错误。\\
\hline
5.1.3	 &在 PHP 5 之前的版本，var 的使用已被废弃，并将产生一个 E\_STRICT 级别的错误。现在它不再被废弃，因此也不会产生错误。\\
\hline
5.1.0	 &\_\_set\_state 静态方法在 var\_export() 导出类时会被调用。\\
\hline
5.1.0	 &\_\_isset 和 \_\_unset 方法。\\
\hline
\end{longtable}



\zihao{5}






\bibliographystyle{plainnat}
\bibliography{phpnotes}
\clearpage