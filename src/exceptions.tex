\part{PHP Exceptions}




\chapter{Introduction}

异常（Exception）用于在指定的错误发生时改变脚本的正常流程，这种情况称为异常。

PHP 5 提供了类似于其它面向对象的异常处理模块\footnote{PHP 内部函数主要使用错误报告, 只有现代面向对象的扩展才使用异常，但错误可以很容易的通过ErrorException转换为异常。PHP标准库 (SPL) 提供了许多内建的异常类。}。当异常被触发时，通常会发生的情况如下：

\begin{compactitem}
\item 当前代码状态被保存
\item 代码执行被切换到预定义的异常处理器函数
\item 根据情况，处理器也许会从保存的代码状态重新开始执行代码，终止脚本执行，或从代码中另外的位置继续执行脚本
\end{compactitem}

在 PHP 代码中所产生的异常可被 throw 语句抛出并被 catch 语句捕获。需要进行异常处理的代码都必须放入 try 代码块内，以便捕获可能存在的异常。每一个 try 至少要有一个与之对应的 catch。使用多个 catch 可以捕获不同的类所产生的异常。当 try 代码块不再抛出异常或者找不到 catch 能匹配所抛出的异常时，PHP 代码就会在跳转到最后一个 catch 的后面继续执行。当然，PHP 允许在 catch 代码块内再次抛出（throw）异常。


\section{Basic Exception}


当一个异常被抛出时，其后的代码（指抛出异常时所在的代码块）不会继续执行，而PHP 会尝试查找第一个能与之匹配的``catch" 代码块。

如果异常没有被捕获，而且又没用使用 set\_exception\_handler() 作相应的处理的话，那么 PHP 将会产生一个严重的错误（致命错误），并且输出 ``Uncaught Exception ...''（未捕获异常）的错误提示信息。



在下面的示例中，尝试抛出一个异常，同时不去捕获它：


\begin{lstlisting}[language=PHP]
<?php
//create function with an exception
function checkNum($number)
 {
 if($number>1)
  {
  throw new Exception("Value must be 1 or below");
  }
 return true;
 }

//trigger exception
checkNum(2);
?>
\end{lstlisting}

上面的代码会获得类似这样的一个错误：


\begin{lstlisting}[language=bash]
Fatal error: Uncaught exception 'Exception' 
with message 'Value must be 1 or below' in test.php:6 
Stack trace: #0 test.php(12): 
checkNum(28) #1 {main} thrown in test.php on line 6
\end{lstlisting}






\begin{example}
抛出一个异常
\begin{lstlisting}[language=PHP]
<![CDATA[
<?php
function inverse($x) {
    if (!$x) {
        throw new Exception('Division by zero.');
    }
    else return 1/$x;
}

try {
    echo inverse(5) . "\n";
    echo inverse(0) . "\n";
} catch (Exception $e) {
    echo 'Caught exception: ',  $e->getMessage(), "\n";
}

// Continue execution
echo 'Hello World';
?>
\end{lstlisting}
\end{example}

以上例程会输出：

\begin{verbatim}
0.2
Caught exception: Division by zero.
Hello World
\end{verbatim}

\begin{example}
嵌套的异常
\begin{lstlisting}[language=PHP]
<?php

class MyException extends Exception { }

class Test {
    public function testing() {
        try {
            try {
                throw new MyException('foo!');
            } catch (MyException $e) {
                /* rethrow it */
                throw $e;
            }
        } catch (Exception $e) {
            var_dump($e->getMessage());
        }
    }
}

$foo = new Test;
$foo->testing();

?>
\end{lstlisting}
\end{example}

以上例程会输出：

\begin{verbatim}
string(4) "foo!"
\end{verbatim}

\section{try,throw and catch}

要避免上面例子出现的错误，我们需要创建适当的代码来处理异常。




异常处理程序应当包括：



\begin{compactenum}
\item try - 使用异常的函数应该位于 "try" 代码块内。如果没有触发异常，则代码将照常继续执行。但是如果异常被触发，会抛出一个异常。
\item throw - 这里规定如何触发异常。每一个 "throw" 必须对应至少一个 "catch"
\item catch - "catch" 代码块会捕获异常，并创建一个包含异常信息的对象
\end{compactenum}

下面的示例将触发一个异常：

\begin{lstlisting}[language=PHP]
<?php
//创建可抛出一个异常的函数
function checkNum($number)
 {
 if($number>1)
  {
  throw new Exception("Value must be 1 or below");
  }
 return true;
 }

//在 "try" 代码块中触发异常
try
 {
 checkNum(2);
 //If the exception is thrown, this text will not be shown
 echo 'If you see this, the number is 1 or below';
 }

//捕获异常
catch(Exception $e)
 {
 echo 'Message: ' .$e->getMessage();
 }
?>
\end{lstlisting}


上面代码将获得类似这样一个错误：\verb|Message: Value must be 1 or below|

上面的代码抛出了一个异常，并捕获了它：

\begin{compactenum}
\item 创建 checkNum() 函数。它检测数字是否大于 1。如果是，则抛出一个异常。
\item 在``try" 代码块中调用 checkNum() 函数。
\item checkNum() 函数中的异常被抛出
\item ``catch" 代码块接收到该异常，并创建一个包含异常信息的对象 (\texttt{\$e})。
\item 通过从这个 exception 对象调用 \texttt{\$e->getMessage()}，输出来自该异常的错误消息
\end{compactenum}

不过，为了遵循“每个 throw 必须对应一个 catch”的原则，可以设置一个顶层的异常处理器来处理漏掉的错误。



\section{Custom Exception Class}

以下这段代码只为说明内置异常处理类的结构，它并不是一段有实际意义的可用代码。

\begin{example}
内置的异常处理类
\begin{lstlisting}[language=PHP]
<?php
class Exception
{
    protected $message = 'Unknown exception';   // 异常信息
    protected $code = 0;                        // 用户自定义异常代码
    protected $file;                            // 发生异常的文件名
    protected $line;                            // 发生异常的代码行号

    function __construct($message = null, $code = 0);

    final function getMessage();                // 返回异常信息
    final function getCode();                   // 返回异常代码
    final function getFile();                   // 返回发生异常的文件名
    final function getLine();                   // 返回发生异常的代码行号
    final function getTrace();                  // backtrace() 数组
    final function getTraceAsString();          // 已格成化成字符串的 getTrace() 信息

    /* 可重载的方法 */
    function __toString();                       // 可输出的字符串
}
?>
\end{lstlisting}
\end{example}


用户可以用自定义的异常处理类来扩展 PHP 内置的异常处理类，而创建自定义的异常处理程序非常简单。

通过自定义exception类，当 PHP 中发生异常时，可调用其函数，注意该类必须是 Exception 类的一个扩展。

以下的代码说明了在内置的异常处理类中，哪些属性和方法在子类中是可访问和可继承的。


这个自定义的 exception 类继承了 PHP 的 Exception 类的所有属性，可向其添加自定义的函数。


\begin{example}
创建 exception 类
\begin{lstlisting}[language=PHP]
<?php
class customException extends Exception
 {
 public function errorMessage()
  {
  //error message
  $errorMsg = 'Error on line '.$this->getLine().' in '.$this->getFile()
  .': <b>'.$this->getMessage().'</b> is not a valid E-Mail address';
  return $errorMsg;
  }
 }

$email = "someone@example...com";

try
 {
 //check if 
 if(filter_var($email, FILTER_VALIDATE_EMAIL) === FALSE)
  {
  //throw exception if email is not valid
  throw new customException($email);
  }
 }

catch (customException $e)
 {
 //display custom message
 echo $e->errorMessage();
 }
?>
\end{lstlisting}
\end{example}

这个新的类是旧的 Exception 类的副本，外加 errorMessage() 函数。正因为它是旧类的副本，因此它从旧类继承了属性和方法，我们可以使用 Exception 类的方法，比如 getLine() 、 getFile() 以及 getMessage()。

上面的代码抛出了一个异常，并通过一个自定义的 exception 类来捕获它：

\begin{compactenum}
\item customException() 类是作为旧的 exception 类的一个扩展来创建的。这样它就继承了旧类的所有属性和方法。
\item 创建 errorMessage() 函数。如果 e-mail 地址不合法，则该函数返回一条错误消息
\item 把 \$email 变量设置为不合法的 e-mail 地址字符串
\item 执行 "try" 代码块，由于 e-mail 地址不合法，因此抛出一个异常
\item "catch" 代码块捕获异常，并显示错误消息
\end{compactenum}

如果使用自定义的类来扩展内置异常处理类，并且要重新定义构造函数的话，建议同时调用 parent::\_\_construct() 来检查所有的变量是否已被赋值。当对象要输出字符串的时候，可以重载 \_\_toString() 并自定义输出的样式。

\begin{example}
扩展 PHP 内置的异常处理类
\begin{lstlisting}[language=PHP]
<?php
/**
 * 自定义一个异常处理类
 */
class MyException extends Exception
{
    // 重定义构造器使 message 变为必须被指定的属性
    public function __construct($message, $code = 0) {
        // 自定义的代码

        // 确保所有变量都被正确赋值
        parent::__construct($message, $code);
    }

    // 自定义字符串输出的样式
    public function __toString() {
        return __CLASS__ . ": [{$this->code}]: {$this->message}\n";
    }

    public function customFunction() {
        echo "A Custom function for this type of exception\n";
    }
}


/**
 * 创建一个用于测试异常处理机制的类
 */
class TestException
{
    public $var;

    const THROW_NONE    = 0;
    const THROW_CUSTOM  = 1;
    const THROW_DEFAULT = 2;

    function __construct($avalue = self::THROW_NONE) {

        switch ($avalue) {
            case self::THROW_CUSTOM:
                // 抛出自定义异常
                throw new MyException('1 is an invalid parameter', 5);
                break;

            case self::THROW_DEFAULT:
                // 抛出默认的异常
                throw new Exception('2 isnt allowed as a parameter', 6);
                break;

            default:
                // 没有异常的情况下，创建一个对象
                $this->var = $avalue;
                break;
        }
    }
}


// 例子 1
try {
    $o = new TestException(TestException::THROW_CUSTOM);
} catch (MyException $e) {      // 捕获异常
    echo "Caught my exception\n", $e;
    $e->customFunction();
} catch (Exception $e) {        // 被忽略
    echo "Caught Default Exception\n", $e;
}

// 执行后续代码
var_dump($o);
echo "\n\n";


// 例子 2
try {
    $o = new TestException(TestException::THROW_DEFAULT);
} catch (MyException $e) {      // 不能匹配异常的种类，被忽略
    echo "Caught my exception\n", $e;
    $e->customFunction();
} catch (Exception $e) {        // 捕获异常
    echo "Caught Default Exception\n", $e;
}

// 执行后续代码
var_dump($o);
echo "\n\n";


// 例子 3
try {
    $o = new TestException(TestException::THROW_CUSTOM);
} catch (Exception $e) {        // 捕获异常
    echo "Default Exception caught\n", $e;
}

// 执行后续代码
var_dump($o);
echo "\n\n";


// 例子 4
try {
    $o = new TestException();
} catch (Exception $e) {        // 没有异常，被忽略
    echo "Default Exception caught\n", $e;
}

// 执行后续代码
var_dump($o);
echo "\n\n";
?>
\end{lstlisting}
\end{example}



\section{Multiple Exceptions}

可以为一段脚本使用多个异常，来检测多种情况。


可以使用多个 if..else 代码块，或一个 switch 代码块，或者嵌套多个异常。这些异常能够使用不同的 exception 类，并返回不同的错误消息：

\begin{lstlisting}[language=PHP]
<?php
class customException extends Exception
{
public function errorMessage()
{
//error message
$errorMsg = 'Error on line '.$this->getLine().' in '.$this->getFile()
.': <b>'.$this->getMessage().'</b> is not a valid E-Mail address';
return $errorMsg;
}
}

$email = "someone@example.com";

try
 {
 //check if 
 if(filter_var($email, FILTER_VALIDATE_EMAIL) === FALSE)
  {
  //throw exception if email is not valid
  throw new customException($email);
  }
 //check for "example" in mail address
 if(strpos($email, "example") !== FALSE)
  {
  throw new Exception("$email is an example e-mail");
  }
 }

catch (customException $e)
 {
 echo $e->errorMessage();
 }

catch(Exception $e)
 {
 echo $e->getMessage();
 }
?>
\end{lstlisting}

上面的代码测试了两种条件，如何任何条件不成立，则抛出一个异常：

\begin{compactenum}
\item customException() 类是作为旧的 exception 类的一个扩展来创建的。这样它就继承了旧类的所有属性和方法。
\item 创建 errorMessage() 函数。如果 e-mail 地址不合法，则该函数返回一个错误消息。
\item 执行 "try" 代码块，在第一个条件下，不会抛出异常。
\item 由于 e-mail 含有字符串 "example"，第二个条件会触发异常。
\item "catch" 代码块会捕获异常，并显示恰当的错误消息
\end{compactenum}


如果没有捕获 customException，紧紧捕获了 base exception，则在那里处理异常。




\section{Re-throwing Exceptions}

有时，当异常被抛出时，开发者也许希望以不同于标准的方式对它进行处理，因此可以在一个 "catch" 代码块中再次抛出异常。


对程序员来说，系统错误也许很重要，但是用户对它们并不感兴趣，因此脚本应该对用户隐藏系统错误。

为了让用户更容易使用，开发者可以再次抛出带有对用户比较友好的消息的异常：

\begin{lstlisting}[language=PHP]
<?php
class customException extends Exception
 {
 public function errorMessage()
  {
  //error message
  $errorMsg = $this->getMessage().' is not a valid E-Mail address.';
  return $errorMsg;
  }
 }

$email = "someone@example.com";

try
 {
 try
  {
  //check for "example" in mail address
  if(strpos($email, "example") !== FALSE)
   {
   //throw exception if email is not valid
   throw new Exception($email);
   }
  }
 catch(Exception $e)
  {
  //re-throw exception
  throw new customException($email);
  }
 }

catch (customException $e)
 {
 //display custom message
 echo $e->errorMessage();
 }
?>
\end{lstlisting}

上面的代码检测在邮件地址中是否含有字符串 "example"。如果有，则再次抛出异常：

\begin{compactenum}
\item customException() 类是作为旧的 exception 类的一个扩展来创建的。这样它就继承了旧类的所有属性和方法。
\item 创建 errorMessage() 函数。如果 e-mail 地址不合法，则该函数返回一个错误消息。
\item 把 \$email 变量设置为一个有效的邮件地址，但含有字符串``example"。
\item ``try" 代码块包含另一个``try" 代码块，这样就可以再次抛出异常。
\item 由于 e-mail 包含字符串``example"，因此触发异常。
\item ``catch" 捕获到该异常，并重新抛出``customException"。
\item 捕获到``customException"，并显示一条错误消息。
\end{compactenum}

如果在其目前的``try" 代码块中异常没有被捕获，则它将在更高层级上查找 catch 代码块。


\section{Top Level Exception Handler}

set\_exception\_handler() 函数可设置处理所有未捕获异常的用户定义函数。

\begin{lstlisting}[language=PHP]
<?php
function myException($exception)
{
echo "<b>Exception:</b> " , $exception->getMessage();
}

set_exception_handler('myException');

throw new Exception('Uncaught Exception occurred');
?>
\end{lstlisting}

以上代码的输出应该类似这样：\verb|Exception:Uncaught Exception ocuured|

在上面的代码中，不存在 "catch" 代码块，而是触发顶层的异常处理程序。应该使用此函数来捕获所有未被捕获的异常。





\section{Rules for Exception}

异常处理的规则包括：

\begin{compactitem}
\item 需要进行异常处理的代码应该放入 try 代码块内，以便捕获潜在的异常。
\item 每个 try 或 throw 代码块必须至少拥有一个对应的 catch 代码块。
\item 使用多个 catch 代码块可以捕获不同种类的异常。
\item 可以在 try 代码块内的 catch 代码块中再次抛出（re-thrown）异常。
\end{compactitem}

简而言之就是，如果抛出了异常，就必须捕获它。


\chapter{Predefined Exceptions}


Exception是所有异常的基类。




