\part{Domain-Driven Design}

\chapter{Overview}




“领域驱动设计”，顾名思义，首先强调的是“领域”。这个词不是指技术上的任何东西，而是指“业务领域”，是说用领域的角度去分析和设计业务。
 
现实中的大部分开发者并不会直接接触业务，实际接触到的仅仅是架构师消化过的，而且企业开发中处处充满着管理的不规范性，再加上用户的很多需求本身就是不规范的，因此实际生产出的软件只能是怪胎，大多数软件只能满足一时之需，跟不上用户的成长和规范。

为了实施领域驱动设计，需要在向领域专家和专业书籍学习的同时，找出当前用户在业务不足之处，从而在规范和现实之间构建桥梁。



\section{MDD}

MDD（Model-Driven Development）包括基于图形（MDE）和基于文本语言（DSL）等形式，MDD的建议：

\begin{compactitem}
\item 尽量保持领域模型更加紧凑和窄化。
\item 领域要众所周知。
\item 对MDD要足够重视，不要作为试点项目。
\item MDD最好形式是落地
\item Be careful of gains that are offset elsewhere
\item 不要对代码生成迷惑
\item 不是每个人能够抽象思考。
\item 大多数项目失败在可伸缩上。
\item 使用正确的工具和过程。
\end{compactitem}

图形化在架构基本虚拟抽象是有用处的，但是在对象组件构件级别没有任何意义，相比基于文本语言，图形化工具难于和环境以及开发过程进行整合。



文本建模语言DSL已经有不少成功工业应用，当然还有些问题（比如削弱MDD的一些特点），好的编程语言不但在细节上执行有效，而且支持DSL构建，提供抽象层次，并且可以用在组件和类似MDD的任务上。


所有MDD都是基于面向对象，但是，对象在构建可重用的组件构件标准上力不从心，已知的成功的标准组件（如TCP和HTTP等）都不是对象化的，而面向对象的组件标准（如CORBA）则证明会带来复杂性。

函数式编程语言则具备了构成成功组件的构件标准的特点。



\section{Entity}

过去看到的OO都是“简单实体建模”，也就是从需求中挖出几个实体对象，然后填充属性，至于其它的只要会查询即可，这种建模方式随处可见。


其实OO就是“贫血对象”，DDD之所以让领域对象富有生命，是因为值对象的存在。DDD采取的是“特征建模”思想，领域对象不仅仅有实体对象，还有表示状态的值对象。 

DDD强调“充血模型”。在复杂业务中，这很有用，可以提高对象的可复用性。但是要注意，“充血模型”虽然很好，但其背后却隐藏玄机。复杂场景中，如果所有的行为都放到了对象中，那领域对象就会变得沉重无比，带来各种副作用。同时，描述状态的值对象往往不是一蹴而就，而是充满着变化，难以把握。当业务不明时，"贫血模型"容易把握，这也就是为什么现在”充血模型“不多，而"贫血模型"大行其道的原因。

DDD认为"领域对象应该是有行为的"，大家都认可。如果说"贫血模型"造成了对象和行为的分离的话；那么"充血模型"也是有问题的，因为DDD中简单地认为把行为放到对象中就行了，殊不知这其实是关于对象和行为之间的一种静态地僵化的看法。

DCI对这种思想进行了修正，认为对象在场景中才具有行为。DCI中的对象（数据）是一种裸对象，但却不是简单意义上的“贫血对象”。

DCI中的对象和行为是一种动态关系，是依赖于场景而存在的，这也就是说对象不会无缘无故的产生行为，而且对象具有行为一定是有意义的。

在DCI中可以用"事件"把对象和行为联系在一起就避免了"贫血对象"的问题。

另外，DDD提出聚合的概念是为了保证领域内对象之间的一致性问题，DDD特别强调聚合根的封装性，不过可能会导致领域内对象之间的逻辑强耦合。

在实战中，领域模型内部的值对象往往存在着变数，这是我们认识客观世界的必然规律。然而这会导致领域模型的不稳定性。所以即使领域内部的对象也应该注意低耦合，这个问题同样需要靠事件来解决，事件才是保证领域对象一致性的关键。


领域聚合内部的松耦合因为天然的业务的高聚合性只能通过软件设计上的松耦合方式来实现（比如设计模式等）。

为了保证一致性，一般采取在实体根对象中放入对值对象或其他状态实体修改的方法行为，外界不可以绕过根实体直接修改状态。

另外，值对象并不适合保存状态，状态应该属于实体的一个重要部分，如果状态复杂，可以用专门的状态模式等设计方式消肿，所以担心“充血模型”会变得沉重无比是多余的，因为这里面忽视了软件设计模式的作用。


总体来说，根据业务的设计和根据纯软件设计目标松耦合的设计这两种切分方式，可以将业务真正落实为好的软件，而我们过去常常注重业务的切分设计，忽视软件层面设计，也就是设计模式。


当然，掌握设计模式的人去进行业务分析设计时，发现设计模式毫无用处，这是因为没有掌握业务建模设计的原因，业务建模设计好了，自然软件设计就派上用上。

业务建模设计和软件设计相当于切菜的大刀和小刀，对于整只猪，必须先用大刀，然后再用小刀。有了这两把刀，就不用担心胖对象的沉重，相反，如果一开始做成很瘦的只有数据的贫血模型，设计模式真的一无用处了，然后系统开发就走上了依赖数据库/数据表的系统，根本没有设计。

\section{Problem}

现实业务中的问题域模型更侧重强调是“领域模型”，因此很难立体化并动态地完整描述这个“问题域模型”，技术的演进目的是试图解决“问题域模型”的变化问题。

“领域模型”存在与”问题域模型“不匹配的问题，原因可能是时间变化或者用户场景变化导致的，因此对”领域模型“的检验标准就是其是否能适应”问题域模型“的变化，其中”开闭原则“是在这里适用的。

“领域驱动设计”的第一层”驱动“的含义是"问题域模型"驱动"领域建模"以及"测试建模"。从这一点来说，"领域驱动设计"是适合一切场景的，”领域驱动设计“有问题的情况准确地来讲是目前的"领域建模技术"还不完善，当然也可以说是"领域建模技术"的运用有问题，“面向对象编程走错了路”并不是OO错了，而是“传统OO”有很大的缺陷，首先第一条就是“没有面向消息的传递机制”。

领域建模的真谛是认清业务发展变化的脉络，其最高境界就是“庖丁解牛”，但是真实世界中并不存在“稳定领域”，业务的是永恒变化的。如果业务永远不变，那么只要满足用户需求，怎么设计都可以。

“领域驱动设计”的第二层含义是“驱动设计”。显然，“设计”只是一种手段和工具，是为“领域”服务的。“设计”的过程和质量必须通过“领域模型”来检验和验证，这也是测试驱动的本质。



尽可能不要让设计工具本身的缺陷扭曲了“领域”本身，否则就本末倒置了。例如，Banq批判的“基于关系数据库的业务设计”以及坚持“域模型不要让技术污染“。

在生活中也是如此，例如在骑车或者开车出行时，用户心中都有一辆真正属于自己的车，至于这个车是不是有轮子等都并不重要，关键是能让自己舒适地出行。显然”舒适地出行“才是真正的业务领域，而”轮子之类的“只是设计。

领域驱动设计、敏捷工程以及测试驱动是浑然一体的，三者紧密结合，形成一套新的软件开发方式，而且已经开始普及和成熟，未来可能专门开发出专门的MDD工具或DSL来支持领域开发。

模型驱动架构、开发和工程学以及丰富的模型驱动开发环境——例如NeXTStep——都是在80年代末出现的，现在模型已经无处不在，然而开发工具的数量还是很少，业界还在寻找让模型驱动开发成为主流的方法。

“领域驱动设计” =“问题域模型驱动领域建模” +“领域建模驱动软件实现”。


\section{Business}


在面对企业多业务集成（如ERP、MES、HR、多项目、PDM、MRO）模式时，需要根据问题来考虑解决业务建模的问题，并且让设计模式和领域模型的思想融入到业务模型中。

业务建模应该回归自然，这样就可以把SOA、ESB等的意图理解为打造一个企业的“神经脉络”，“OO”可以理解为“神经元”，它们之间的通讯就是靠生物电脉冲，也就是消息驱动。如果在项目开发中感觉不自然的时候，那一定是模型出问题了。

大项目需要从整体思考并自上而下的进行大的业务划分，并确定不同业务领域的边界，领域驱动设计往往只是强调了业务的水平分割。

在开始阶段就对对象进行建模，然后再进行归类划分模块，并且把垂直分割完全等同于包的划分的做法是错误的，正确的做法应该是前期以确认领域边界功能为主，后期以确认领域内的对象模型为主。

上面提到的领域的切分就是不断对企业业务知识的学习和分析。当对一个业务认识不清的时候，最好的办法就是不同企业环境下去分析这个业务，那这个业务的所有发展变化就清楚了。

领域的边界就是服务，或者说是对外提供服务的唯一入口，领域服务和领域对象模型是一个业务领域的2个不同侧面。

\begin{compactitem}
\item 领域服务强调是从外向内看，反映了“外部对业务领域的使用功能”；
\item 领域对象模型强调业务领域就像一个独立的具有一定自主能力的生命体，反映了“业务领域的内部运行机制”。
\end{compactitem}

领域对象模型的功能是不能对外暴露的，否则会造成外部对领域对象的耦合，而且域对象到处暴露可能导致整个系统形成了一个领域对象相互关联的蜘蛛网，一旦项目变大需要不同的部分独自发展时就无法进行切割。为了解决松耦合，DDD还提出了专门的防腐层。

领域模型是不断变化的。比如说，以“添加一个user对象”这个功能为例，一开始业务很简单，认为放到User对象中即可，但是后来随着业务的复杂度提升，“添加一个user对象必须先审批”，最后业务更复杂了，“在不同的企业里这个审批的流程也不一样”。

这里，对于外部而言，如果一开始就调用的user域对象的方法就需要重新修改，因为后来增加的业务应该是user与其他对象协作一起完成的，因此不能放在User内部，不过放在服务里就没问题了，外界只关心提供必要的创建user的信息即可，不关心内部怎实现的，怎么变化的，以至于内部有没有User这个对象都没有关系。

注意，服务里的addUser和User里的add方法是同时存在的，但是二者的侧重点不同。其中，服务里的addUser是业务方法，而User的add方法仅仅是对象方法，前者调用后者。这就是封装，同时也支持了一定的柔性，越大的项目越需要注意区分。

至于什么样的对象适合作为聚合根的领域对象，一般而言，user在大多数情况下都不是领域对象，而customer可以是。因为user是泛指，除了在HR中user可以是领域对象。

想象一下，在一个企业里有好几个不同的单业务系统，都是基于领域驱动设计的；在这些不同的业务场景下，user都可以聚合根，这很正常，因为人可以干不同的事情，不过在把这些业务集成起来时就有问题了，因此作为聚合根的领域对象应该是业务场景类，而不应该是类似user的这样的类。

对于User作为另外一个域中的对象，在其他领域内如何引用的问题，其实大多数业务应用中只需要一个仅仅包含UserId和UserName属性的对象就足够了，所以User在其他域里是值对象，不需要引用像rich domain中的那样的User。



\section{Modeling}


“一上来先识别类，然后就考虑怎么分配职责”的做法是一种本末倒置的僵化的静态建模。这种方式往往让人落入一种只注重“形”而忽略“意”（业务本来的面目）的怪圈。

建模分为2个阶段，第一个是“有机的业务建模”，第二个是“技术建模”。“业务建模”和“技术建模”的区别是：“业务建模”完全是业务语言，不含任何技术成分，比如“类、值对象和职责”的概念，在“技术建模”中才涉及那些概念。“业务建模”做好了，“技术建模”就成了自然而然的东西了。

“有机的业务建模”的一个非常重要的特征就是“有机”，就是强调业务模型中的每一个“业务主体”都是一个生命体。这些业务主体都有“生命特征”，在一定条件下受到外界的刺激就会发生一定的行为。这些业务主体构成了整个业务模型。当然，这些业务主体的规模和层次不同：比较大的业务主体就是“领域主体”，他有明确的领域边界；而领域主体的对外界响应其实是通过内部的“业务核心主体”的协作来完成的，有的看见的见摸得着————具有业务实体的特点，有的比较抽象————控制规则和流程，当然有的“业务核心主体”可能是个多核细胞。“有机的业务建模”有一个非常重要的工作就是“检查业务模型的生命健康状况”。

需要注意的是，这个业务建模可能是通过不完善的用户需求建立起来的，所以需要构建多种场景通过不同的刺激去看这个领域主体内部的响应中是否有“异常情况”，如果有那就要修改模型。

“技术建模”应该“对内功能和对外功能要分开”，领域对象不建议同时承担对内和对外的功能，但是小项目除外。服务对外要封装和隐藏领域内部的东西，提供的是服务接口，同时服务要负责领域内部对象的行为组装。

从另外一个层面看，服务是需求，领域对象模型是实现。值对象的本质就是反映业务主体的不同业务特征，可能是业务主体的临时状态（比如用户的发帖数）或者属于另一业务主体的状态值。

\begin{compactitem}
\item 从微观看，聚合是交互最紧密的业务对象的封装；
\item 从宏观看，聚合是一个具有明确业务边界的独立业务核心主体。
\end{compactitem}

聚合只是形式，业务模型的正确建立才是决定要素。


在实际建模过程中，从用户的角度看，业务本来就是面向关系和过程的；从设计看，业务是不同主体在相互作用，因此这也就是为什么越靠近用户的地方面向关系和过程的设计味道越浓的原因。

如果建模分成分析和设计两个阶段，也就是业务建模和技术建模，这样做会产生两者隔阂，业务建模注重如何反应需求，技术建模比较注重技术实现，两个关注点不一样，那么两者如何衔接就成了没人关注的，但是最重要的部分。

如果将两者合并在一起，只是按照DDD是不够的，DDD只是一种静态建模，更多的是考虑特征特点等静态对象属性，而没有从行为职责去考虑，所以这时需要引入对象职责，通过对象职责和协作来完成聚合以及层次以及流程，确定聚合大边界和内部协作对象小边界，分离出规则和流程等。

另一方面，业务建模和技术建模的过程完全就是一体两面，而把它们分开是因为各种技术名词束缚了我们对业务的真正认识。


从“事件”角度看，“职责的本质就是事件的响应”，如果当职责分配不能合理地表示出来，就说明OO这方面到头了。其实就是OO这种世界观能把世界认识到什么一种程度而已。

过去的OO过于僵化、教条，偏重于静态场景，忽略了客观世界运动和相互作用的本质规律，而最近出现新技术和对OO的反思“正在回归自然”。例如，过去的业务模型更多表现在用例图、流程图和状态图等（与类无关的，是对业务的一种描述）。其中，用例图就是一种对边界捕捉的方法。


类的这些描述是静态的，所以只分析类图是不全面，或者说是危险的，所以出现了时序图和数据流图等来更好地、全面地描述业务。

即使理解了两面一体，问题仍然在于中间，中间怎样过渡很重要，而且即使掌握了业务模型也不知道怎样把这两面联系起来——也就是到底具体怎么表示。


建模是动态的、基于场景交互的，应该用更自然的还原业务本来面目的眼光去审视建模过程，也就是说“有机的业务建模”实际上就是“技术建模”的问题域建模，而“技术建模”只是“业务建模”的技术落地而已。这和过去的方式是完全不同的，因此一气呵成应该是领域驱动建模的一个特点，区别于过去方法的重要特征。

过早地进入“技术建模”或者“用技术建模来替代业务建模”是有危险的，容易犯“形而上学”的毛病，把“TDD思想提前到业务建模阶段”对软件的质量非常重要，让技术建模更加容易。


企业业务建模的终极目标一定是非常复杂的（也就是我原来常说的大项目场景），而且只有在复杂的场景下才能真正检验各种建模技术的偏颇。


从层次上来讲，企业的业务建模可以分为两个层面，”宏观建模”和“微观建模”。“宏观建模”是指首先要对企业做一个整体的信息化规划，对企业进行整体的的业务架构建模，其成果就是业务组件。其中的方法论可以参照IBM的CBM，真正的落地还要靠自己对CBM的领悟。

DDD主要属于“微观建模”部分，“微观建模”的两个方面——“结构化建模”和“行为建模”是一体两面。Evans对DDD总结了关键的要素：实体、值对象、聚合、工厂和存储，不过其中还少了一个非常重要和关键的要素——“事件”。

众所周知，人体是由很多细胞构成的，那细胞之间是如何作用的呢，其实就是“刺激”和“响应”。其中“刺激”就是“事件”，所以“事件”是业务模型本来就应该具备的要素。

从这点来看，用户发帖这个动作激发一个“发帖事件”，这个事件会导致一系列的对象和值对象的状态变化。

\begin{compactitem}
\item “结构化建模”是指建模中除了静态的实体和值对象的结构关系外，从“事件”角度看，实体或者值对象还具备一些“本能的反应”，比如"手指会弯曲"。
\item “行为建模”是指通过神经中枢（消息总线）来控制不同对象的本能反应来完成一个复杂的组合，比如"用手弹钢琴"。
\end{compactitem}

用事件来实现职责，在过去SOA以及传统架构比较常见，也有Scala的邮箱通讯机制，如果说事件机制类似观察者模式是一种分布式通讯，那么DCI则类似Mediator模式，它是一种封装通讯，其实比Mediator更彻底，根本就没有事件概念，直接和角色、职责、场景等业务建模概念结合。



目前的“领域建模”可能大多只停留在描述或者仿生“领域的事物(what)及活动(how)”，可能并没有深入研究领域的模式或规律(why)。


举个例子，复杂网络的建模，复杂网络的具体例子有生物网络、交通网络、互联网、神经网络、社会网络等，科学家要从这些网络抽象一个通用的模型，这个模型要足够简单，又不能太简单（比如，只将网络当成点与边的集合），一旦成功建模后，科学家们便可以研究模型找出规律，用于指导实践和预测未来。可是构造一个通用的模型几乎不可能，建立起来的模型往往只能反映现实的部分特性。


建模与需求分析的关系不能简单的认为是“需求分析的目标是就是建模，建模后指导技术实现”。例如，即时通信的领域模型本身也有助于我们做好需求分析，如果有可能，可以放在需求分析之前，或者对两者以拉锯式、互相推动的方式进行思考。

