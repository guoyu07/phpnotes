\part{Functions}

PHP提供了超过 700 个内建的函数，函数只需被编译一次就可以多次调用，因而PHP的真正威力源自于它的函数。


具体来说，函数是一种可以在任何被需要的时候执行的代码块，并且函数可以接受一组参数，然后返回操作结果。



PHP 有很多标准的函数和结构。还有一些函数需要和特定地 PHP 扩展模块一起编译，否则在使用它们的时候就会得到一个致命的“未定义函数”错误。

例如，要使用 image 函数中的 imagecreatetruecolor()，需要在编译 PHP 的时候加上 GD 的支持。或者，要使用 mysql\_connect() 函数，就需要在编译 PHP 的时候加上 MySQL 支持。有很多核心函数已包含在每个版本的 PHP 中如字符串和变量函数。调用 phpinfo() 或者 get\_loaded\_extensions() 可以得知 PHP 加载了那些扩展库。同时还应该注意，很多扩展库默认就是有效的。

通过阅读和理解一个函数的原型，可以确认一个函数将返回什么，或者函数是否直接作用于传递的参数。例如， str\_replace() 函数将返回修改过的字符串，而 usort() 却直接作用于传递的参数变量本身。



如果传递给函数的参数类型与实际的类型不一致，例如将一个 array 传递给一个 string 类型的变量，那么函数的返回值是不确定的。在这种情况下，通常函数会返回 NULL。但这仅仅是一个惯例，并不一定如此。

了解这些重要的（常常是细微的）差别是编写正确的 PHP 代码的关键。



\chapter{Introduction}


\section{Function Prototype}



函数的定义又可以称为函数原型，可以使用function声明自定义函数。

\begin{lstlisting}[language=PHP]
<?php
function foo($arg_1, $arg_2, /* ..., */ $arg_n)
{
    echo "Example function.\n";
    return $retval;
}
?>
\end{lstlisting}



\begin{compactitem}
\item 所有的函数都使用关键词``\texttt{function()}" 来开始
\item 命名函数 - 函数的名称应该提示出它的功能，函数名称以字母或下划线开头。
\item 添加``\texttt{\{}" - 开口的花括号之后的部分是函数的代码。
\item 插入函数代码
\item 添加一个``\texttt{\}}" - 函数通过关闭花括号来结束。
\end{compactitem}

函数定义首先会告诉我们函数返回什么类型的值，以及函数有多少个变量。任何有效的 PHP 代码都有可能出现在函数内部，还可以包括其它函数和类定义。


函数名和 PHP 中的其它标识符命名规则相同，即有效的函数名应该以字母或下划线开始，后面跟字母、数字或下划线。

函数名是大小写无关的，不过在调用函数的时候，使用其在定义时相同的形式是个好习惯。

可以用正则表达式将函数名规则表示为：\colorbox{lightgray}{\texttt{[a-zA-Z\_\textbackslash x7f-\textbackslash xff][a-zA-Z0-9\_\textbackslash x7f-\textbackslash xff]*}}。

下面用函数 strlen() 的定义作为第一个范例：

\begin{verbatim}
strlen
(PHP 4, PHP 5)
strlen -- 获取字符串长度
说明
int strlen ( string str )
返回给定的字符串 string 的长度。
\end{verbatim}

\begin{table}
\centering
\caption{函数原型}
\begin{tabular}{|l|l|}
\hline
组成部分	&说明\\
\hline
strlen	 &函数名称。\\
\hline
(PHP 4, PHP 5)	& strlen() 在 PHP 4 和 PHP 5 的所有版本中都存在。\\
\hline
int	 &该函数返回的值的类型，这里为整型 integer（即以数字来衡量的字符串的长度）。\\
\hline
( string str )	 &第一个参数，在该函数中名为 str，且类型为 string。\\
\hline
\end{tabular}
\end{table}

可以将以上函数的定义写成一般形式：

\begin{verbatim}
返回类型          函数名           ( 参数类型          参数名 )
returned type    function name    ( parameter type   parameter name )
\end{verbatim}



很多函数（例如 in\_array()）都有多个变量，其函数原型如下：

\begin{verbatim}
 bool in_array ( mixed $needle, array $haystack [, bool $strict])
\end{verbatim}

in\_array() 返回一个“布尔”值，成功（如果在参数 haystack 中能找到参数 needle）则返回 TRUE, 或者在失败时返回 FALSE（如果在参数 haystack 中找不到参数 needle）。第一个参数被命名为 needle 且其类型不定，因此我们将其称为“混和”类型。该混和类型的 needle 参数（我们要找的对象）可以是一个标量的值（字符串、整数、或者浮点数），或者一个数组。haystack（我们寻找的范围）是第二个参数。第三个可选参数被命名为 strict。所有的可选参数都用 [ 方括号 ] 括起来。


有的函数包含更复杂的 PHP 版本信息，例如：

\begin{verbatim}
(PHP 4 >= 4.3.0, PHP 5)
\end{verbatim}

它意味着该函数不可在 PHP 3 中使用，只可在 PHP 4.3.0 及以后发布的版本中使用。






比较下面两个简单的函数，在其被调用时能输出名字。


\begin{tabular}{m{180pt}m{5pt}m{180pt}}
\begin{lstlisting}[language=PHP]
<?php
function writeMyName() {
  echo "David Yang";
}

writeMyName();
?>
\end{lstlisting} && 
\begin{lstlisting}[language=PHP]
<?php
function writeMyName() {
  return "David Yang";
}

echo writeMyName();
?>
\end{lstlisting}\\
\end{tabular}



函数无需在调用之前被定义，除非是下面两个例子中函数是有条件被定义时。

\begin{tabular}{m{190pt}m{2pt}m{190pt}}
/* 有条件的函数 */ 
\begin{lstlisting}[language=PHP]
<?php
$makefoo = true;
/* 不能在此处调用foo()函数，
   因为它还不存在，但可以调用bar()函数。*/
bar();
if ($makefoo) {
  function foo()
  {
    echo "I don't exist until program execution reaches me.\n";
  }
}
/* 现在可以安全调用函数 foo()了，
   因为 $makefoo 值为真 */
if ($makefoo) foo();
function bar()
{
  echo "I exist immediately upon program start.\n";
}
?>
\end{lstlisting}&&/* 函数中的函数 */ 
\begin{lstlisting}[language=PHP]
<?php
function foo()
{
  function bar()
  {
    echo "I don't exist until foo() is called.\n";
  }
}

/* 现在还不能调用bar()函数，因为它还不存在 */

foo();

/* 现在可以调用bar()函数了，因为foo()函数
   的执行使得bar()函数变为已定义的函数 */

bar();

?>
\end{lstlisting}\\
\end{tabular}



当一个函数是有条件被定义时，其定义必须在调用之前先处理。

\section{Function Iteration}

PHP中的函数可以在被调用之前定义，也可以在被调用之后定义，但是在某些情况下需要对函数的定义增加限制条件。

\begin{lstlisting}[language=PHP]
<?php
echo cal_circle_area(0.5);

function cal_circle_area($radius){
	return M_PI * ($radius * $radius);
}
?>
\end{lstlisting}

在函数的迭代中，低版本的PHP无法使用高版本PHP提供的更简便和实用的函数，同时还需要保证在不同版本中的兼容性，因此在使用PHP内置函数之前需要判断函数是否已被定义。

\begin{lstlisting}[language=PHP]
<?php
/* 如果file_get_contents()函数不存在，则使用自定义的file_get_contents()函数版本 */
if(!function_exists("file_get_contents")){
	function file_get_contents($filename){
		$handle = fopen($filename,"r");
		$contents = fread($handle,filesize($filename));
		fclose($handle);
		return $contents;
	}
}

$string = file_get_contents("data.txt"); // 函数调用
?>
\end{lstlisting}


function\_exists()函数用于检查指定的函数是否存在，这样在不同版本的PHP环境之间切换时可以提高可移植性。

\begin{compactitem}
\item 在低版本的PHP环境中使用自定义的函数；
\item 在高版本的PHP环境中直接使用PHP内置的同名函数。
\end{compactitem}

在上述的示例中，如果PHP版本小于4.2.0的环境中将会使用用户自己实现的file\_get\_contents()函数，反之则可以直接使用PHP内置的file\_get\_contents()函数。不过，为防止系统无法找到函数定义，需要在调用函数之前预先定义函数。






\section{Function Usage}

PHP 中的所有函数和类都具有全局作用域，可以定义在一个函数之内而在之外调用，反之亦然。

PHP 不支持函数重载，也不可能取消定义或者重定义已声明的函数。

PHP 的函数支持可变数量的参数和默认参数。


下面的示例演示了如何在PHP脚本中使用定义的函数：


\begin{lstlisting}[language=PHP]
<?php
function writeMyName() {
  echo "David Yang";
}

echo "Hello world!<br />";
echo "My name is ";
writeMyName();
echo ".<br />That's right, ";
writeMyName();
echo " is my name.";
?>
\end{lstlisting}

\section{Recursive Functions}


在 PHP 中可以调用递归函数，不过要避免递归函数/方法调用超过 100-200 层，否则可能导致堆栈崩溃并使当前脚本终止。

\begin{lstlisting}[language=PHP]
<?php
function recursion($a)
{
    if ($a < 20) {
        echo "$a\n";
        recursion($a + 1);
    }
}
?>
\end{lstlisting}

递归本身是一种算法，即一个对象部分地包含自己，或者用自己给自己定义，例如PHP语言名称（PHP: Hypertext Preprocessor）本身就是递归的。

如果一个过程直接或间接地调用自己，那么就称其为递归的过程，例如数学上的阶乘函数、幂函数和斐波那契数列等的定义和计算都是递归的。


\begin{lstlisting}[language=PHP]
<?php
function Fractorial($n){
	if($n==0)
		return 1;
	else
		return n*Fractorial(n-1);
}
?>
\end{lstlisting}

递归函数必须要有终止递归的条件，否则函数将进入无限循环。

在使用PHP开发应用程序时，递归的应用包括文件目录的搜索和删除等，不过需要注意设计不合理的递归运算可能需要耗费大量的系统资源，因此在使用递归解决问题时需要限制递归的层数。


\section{Function Parameter}

每个函数名称后面都有一个括号，比如 writeMyName()，而参数就是在括号中规定的，而且参数是从左向右求值的。

\begin{lstlisting}[language=PHP]
<?php
function takes_array($input)
{
    echo "$input[0] + $input[1] = ", $input[0]+$input[1];
}
?>
\end{lstlisting}

下面的例子会输出不同的名字，但姓是相同的：


\begin{lstlisting}[language=PHP]
<?php
function writeMyName($fname)
  {
  echo $fname . " Yang.<br />";
  }

echo "My name is ";
writeMyName("David");

echo "My name is ";
writeMyName("Mike");

echo "My name is ";
writeMyName("John");
?>
\end{lstlisting}

可以通过添加参数向函数添加更多的功能，其中参数类似一个变量。

函数的参数列表是以逗号分隔的变量和常量的列表，可以将外部信息通过参数列表传入函数。例如，下面示例中的函数的参数列表包含两个参数：

\begin{lstlisting}[language=PHP]
<?php
function writeMyName($fname,$punctuation)
  {
  echo $fname . " Yang" . $punctuation . "<br />";
  }

echo "My name is ";
writeMyName("David",".");

echo "My name is ";
writeMyName("Mike","!");

echo "My name is ";
writeMyName("John","...");
?>
\end{lstlisting}

\begin{compactitem}
\item 在定义PHP函数时，带有默认值的参数必须放在参数列表的末尾。
\item 在调用PHP函数时，将自动为没有赋值的参数赋予对应类型类型的默认值。
\end{compactitem}

PHP 在用户自定义函数中支持可变数量的参数列表，只需使用 func\_num\_args()， func\_get\_arg()，和 func\_get\_args() 函数。

\begin{compactitem}
\item func\_get\_args()函数作用于自定义函数内部，返回一个包含所有传递给函数的参数的数组。

\begin{lstlisting}[language=PHP]
<?php
function more_args(){
	$args = func_get_args();
	foreach($args as $current_arg){
		echo $current_arg . PATH_SEPARATOR;
	}
}
more_args("A","B","C");
?>
\end{lstlisting}

\item func\_num\_args()函数返回参数的总数。

\begin{lstlisting}[language=PHP]
<?php
function more_args(){
	$num = func_num_args();
	for($i=0; $i<$num; $i++){
		$current_arg = func_get_arg($i);
		echo $current_arg . PATH_SEPARATOR;
	}
}
?>
\end{lstlisting}


\item func\_num\_arg()函数接受一个数字参数，并返回指定的参数。

\end{compactitem}



可变参数并不需要特别的语法，参数列表仍按函数定义的方式传递给函数，并按通常的方式使用这些参数。



\section{Parameter passing}



PHP 支持按值传递参数，通过引用传递参数以及默认参数\footnote{自 PHP 5 起，默认值才可以通过引用传递。}，而且PHP也支持可变长度参数列表。


默认情况下，函数参数通过值传递（因而即使在函数内部改变参数的值，它并不会改变函数外部的值）。

\begin{compactitem}
\item 如果希望函数内部的改变不影响到函数外部，可以按值来传递参数。
\item 如果希望允许函数修改它的参数值，必须通过引用传递参数。
\end{compactitem}

变量和变量地址类似于旅馆中的房间和房间号码，PHP中的引用就是变量的“房间号码”，通过号码可以很容易找到变量。

引用可以高效地处理大型变量、数组和对象，使用引用向函数传递参数时可以在函数定义中的对应参数的前面加上符号 \&。

\begin{lstlisting}[language=PHP]
<?php
function add_some_extra(&$string)
{
    $string .= 'and something extra.';
}
$str = 'This is a string, ';
add_some_extra($str);
echo $str;    // outputs 'This is a string, and something extra.'
?>
\end{lstlisting}

\begin{compactitem}
\item C语言变量的指针是符号表的别名，指针和变量本身存储在不同的内存地址中。
\item PHP变量的引用和变量具有相同的内容（内存地址）。
\end{compactitem}




PHP函数可以定义 C++ 风格的标量参数默认值，如下所示：

\begin{lstlisting}[language=PHP]
<?php
function makecoffee($type = "cappuccino")
{
    return "Making a cup of $type.\n";
}
echo makecoffee();
echo makecoffee(null);
echo makecoffee("espresso");
?>
\end{lstlisting}

以上例程会输出：

\begin{verbatim}
Making a cup of cappuccino.
Making a cup of .
Making a cup of espresso.
\end{verbatim}

PHP 还允许使用数组 array 和特殊类型 NULL 作为默认参数，例如：

\begin{lstlisting}[language=PHP]
<?php
function makecoffee($types = array("cappuccino"), $coffeeMaker = NULL)
{
    $device = is_null($coffeeMaker) ? "hands" : $coffeeMaker;
    return "Making a cup of ".join(", ", $types)." with $device.\n";
}
echo makecoffee();
echo makecoffee(array("cappuccino", "lavazza"), "teapot");
?>
\end{lstlisting}


默认值必须是常量表达式，不能是诸如变量，类成员，或者函数调用等。

注意当使用默认参数时，任何默认参数必须放在任何非默认参数的右侧；否则，函数将不会按照预期的情况工作。考虑下面的代码片断：

\begin{lstlisting}[language=PHP]
<?php
function makeyogurt($type = "acidophilus", $flavour)
{
    return "Making a bowl of $type $flavour.\n";
}

echo makeyogurt("raspberry");   // won't work as expected
?>
\end{lstlisting}

以上例程会输出：

\begin{verbatim}
Warning: Missing argument 2 in call to makeyogurt() in 
/usr/local/etc/httpd/htdocs/phptest/functest.html on line 41
Making a bowl of raspberry .
\end{verbatim}


现在，比较上面的例子和这个例子：


\begin{lstlisting}[language=PHP]
<?php
function makeyogurt($flavour, $type = "acidophilus")
{
    return "Making a bowl of $type $flavour.\n";
}

echo makeyogurt("raspberry");   // works as expected
?>
\end{lstlisting}

以上例程会输出：

\begin{verbatim}
Making a bowl of acidophilus raspberry.
\end{verbatim}



\section{Function Return Values}

函数也能用于返回值，值通过使用可选的返回语句返回。

显式的return语句表示函数执行结束，并返回执行结果。如果省略了return，则返回值为NULL，这样函数的作用和过程类似。



函数可以返回的值包括数组和对象的任意类型，返回语句会立即中止函数的运行，并且将控制权交回调用该函数的代码行。

函数的参数和返回值类型都是不受限制的，可以是标量，也可以是对象或资源，而且实际上参数列表和return都不是必须的。

\begin{lstlisting}[language=PHP]
<?php
function add($x,$y)
  {
  $total = $x + $y;
  return $total;
  }

echo "1 + 16 = " . add(1,16);
?>
\end{lstlisting}


函数不能返回多个值，但可以通过返回一个数组来得到类似的效果。

\begin{lstlisting}[language=PHP]
<?php
function small_numbers()
{
    return array (0, 1, 2);
}
list ($zero, $one, $two) = small_numbers();
?>
\end{lstlisting}

从函数返回一个引用，必须在函数声明和指派返回值给一个变量时都使用引用运算符 \&：

\begin{lstlisting}[language=PHP]
<?php
function &returns_reference()
{
    return $someref;
}

$newref =& returns_reference();
?>
\end{lstlisting}


\chapter{Variable functions}


PHP 支持可变函数的概念。这意味着如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它。可变函数可以用来实现包括回调函数，函数表在内的一些用途。


可变函数不能用于例如 echo， print， unset()， isset()， empty()， include， require 以及类似的语言结构。需要使用自己的包装函数来将这些结构用作可变函数。

\begin{lstlisting}[language=PHP]
<?php
function foo() {
    echo "In foo()<br />\n";
}

function bar($arg = '') {
    echo "In bar(); argument was '$arg'.<br />\n";
}

// 使用 echo 的包装函数
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // This calls foo()

$func = 'bar';
$func('test');  // This calls bar()

$func = 'echoit';
$func('test');  // This calls echoit()
?>
\end{lstlisting}


也可以用可变函数的语法来调用一个对象的方法。

\begin{lstlisting}[language=PHP]
<?php
class Foo
{
    function Variable()
    {
        $name = 'Bar';
        $this->$name(); // This calls the Bar() method
    }

    function Bar()
    {
        echo "This is Bar";
    }
}

$foo = new Foo();
$funcname = "Variable";
$foo->$funcname();   // This calls $foo->Variable()

?>
\end{lstlisting}

当调用静态方法时，函数调用要比静态属性优先：

\begin{lstlisting}[language=PHP]
<?php
class Foo
{
    static $variable = 'static property';
    static function Variable()
    {
        echo 'Method Variable called';
    }
}

echo Foo::$variable; // This prints 'static property'. It does need a $variable in this scope.
$variable = "Variable";
Foo::$variable();  // This calls $foo->Variable() reading $variable in this scope.

?>
\end{lstlisting}


\chapter{Anonymous functions}

匿名函数（Anonymous functions），也叫闭包函数（closures），允许 临时创建一个没有指定名称的函数。最经常用作回调函数（callback）参数的值。当然，也有其它应用的情况。


\begin{lstlisting}[language=PHP]
<?php
echo preg_replace_callback('~-([a-z])~', function ($match) {
    return strtoupper($match[1]);
}, 'hello-world');
// 输出 helloWorld
?>
\end{lstlisting}

闭包函数也可以作为变量的值来使用。PHP 会自动把此种表达式转换成内置类 Closure 的对象实例。把一个 closure 对象赋值给一个变量的方式与普通变量赋值的语法是一样的，最后也要加上分号。

\begin{lstlisting}[language=PHP]
<?php
$greet = function($name)
{
    printf("Hello %s\r\n", $name);
};

$greet('World');
$greet('PHP');
?>
\end{lstlisting}

Closure 对象也会从父作用域中继承类属性。这些变量都必须在函数或类的头部声明。从父作用域中继承变量与使用全局变量是不同的。全局变量存在于一个全局的范围，无论当前在执行的是哪个函数。而 closure 的父作用域则是声明该 closure 的函数（不一定要是它被调用的函数）。示例如下：

\begin{lstlisting}[language=PHP]
<?php
// 一个基本的购物车，包括一些已经添加的商品和每种商品的数量。
// 其中有一个方法用来计算购物车中所有商品的总价格，该方法使
// 用了一个 closure 作为回调函数。
class Cart
{
    const PRICE_BUTTER  = 1.00;
    const PRICE_MILK    = 3.00;
    const PRICE_EGGS    = 6.95;

    protected   $products = array();
    
    public function add($product, $quantity)
    {
        $this->products[$product] = $quantity;
    }
    
    public function getQuantity($product)
    {
        return isset($this->products[$product]) ? $this->products[$product] :
               FALSE;
    }
    
    public function getTotal($tax)
    {
        $total = 0.00;
        
        $callback =
            function ($quantity, $product) use ($tax, &$total)
            {
                $pricePerItem = constant(__CLASS__ . "::PRICE_" .
                    strtoupper($product));
                $total += ($pricePerItem * $quantity) * ($tax + 1.0);
            };
        
        array_walk($this->products, $callback);
        return round($total, 2);;
    }
}

$my_cart = new Cart;

// 往购物车里添加条目
$my_cart->add('butter', 1);
$my_cart->add('milk', 3);
$my_cart->add('eggs', 6);

// 打出出总价格，其中有 5% 的销售税.
print $my_cart->getTotal(0.05) . "\n";
// 最后结果是 54.29
?>
\end{lstlisting}

匿名函数目前是通过 Closure 类来实现的，可以在 closure 中使用 func\_num\_args()， func\_get\_arg() 和 func\_get\_args()。

自PHP 5.3.0起，可以使用匿名函数。自PHP 5.4.0起，\$this 可用于匿名函数。


\chapter{PHP Script}


现在来编写一些更实用的脚本，比如检查浏览页面的访问者在用什么浏览器。要达到这个目的，需要检查用户的 agent 字符串，它是浏览器发送的 HTTP 请求的一部分。该信息被存储在一个变量中。在 PHP 中，变量总是以\texttt{\$}开头。

现在要用到的变量是 \texttt{\$\_SERVER['HTTP\_USER\_AGENT']}，而\texttt{\$\_SERVER} 是一个特殊的 PHP 保留变量，它包含了Web服务器提供的所有信息，被称为\textbf{超全局变量}。这些特殊的变量是在 PHP 4.1.0 版本引入的，在这之前使用 \texttt{\$HTTP\_*\_VARS} 数组，如 \texttt{\$HTTP\_SERVER\_VARS}。尽管现在已经不用了，但它们在新版本中仍然存在。

要显示\texttt{\$\_SERVER['HTTP\_USER\_AGENT']}变量，只需简单地进行如下操作：

\begin{lstlisting}[language=PHP]
<?php 
echo $_SERVER['HTTP_USER_AGENT']; 
?>
\end{lstlisting}

PHP 有很多种不同类型的变量，\texttt{\$\_SERVER} 只是 PHP 自动全局化的变量之一。在以上例子中我们打印了一个数组的单元，而数组是一类非常有用的变量。

可以在一个 PHP 标识中加入多个 PHP 语句，也可以建立一个代码块来做比简单的 echo 更多的事情。例如，如果需要识别 Internet Explorer，可以进行如下操作：


\begin{lstlisting}[language=PHP]
<?php
if (strpos($_SERVER['HTTP_USER_AGENT'], 'MSIE') !== FALSE) {
    echo '正在使用 Internet Explorer。<br />';
}
else{
    echo '你使用的不是Internet Explorer。';
}
?>
\end{lstlisting}

其中，\texttt{strpos()} 是 PHP 的一个内置函数，其功能是在一个字符串中搜索另外一个字符串。例如我们现在需要在 \texttt{\$\_SERVER['HTTP\_USER\_AGENT']}（即所谓的 \texttt{haystack}）变量中寻找 'MSIE'。如果在这个 \texttt{haystack} 中该字符串（即所谓的 \texttt{needle}）被找到（“草里寻针”），则函数返回 \texttt{needle} 在 \texttt{haystack} 中相对于开头的位置；如果没有，则返回 FALSE。如果该函数没有返回 FALSE，则 if 会将条件判断为 TRUE 并运行其花括号 \texttt{\{\}} 内的代码；否则，则不运行这些代码。可以自己尝试利用 if，else 以及其它的函数如 \texttt{strtoupper()} 和 \texttt{strlen()} 来建立类似的脚本。


以下我们进一步显示如何进出 PHP 模式，甚至是在一个 PHP 代码块的中间：


\begin{lstlisting}[language=PHP]
<?php
if (strpos($_SERVER['HTTP_USER_AGENT'], 'MSIE') !== FALSE) {
?>
<h3>strpos() 肯定没有返回假 (FALSE)</h3>
<p>正在使用 Internet Explorer</p>
<?php
} else {
?>
<h3>strpos() 肯定返回假 (FALSE)</h3>
<center><b>没有使用 Internet Explorer</b></center>
<?php
}
?>
\end{lstlisting}

和以上我们用一个 PHP 的 \texttt{echo} 语句来输出不同的是，我们跳出了 PHP 模式来直接写 HTML 代码。这里很值得注意的一点是，对于这两种情况而言，脚本的逻辑效率是相同的。在判断了 \texttt{strpos()} 函数的返回值是 TRUE 或是 FALSE，也就是判断了字符串 'MSIE' 是否被找到之后，最终只有一个 HTML 块被发送给浏览者。


\chapter{PHP Library Functions}




\chapter{PHP Array}


\section{Key}

\subsection{array\_values()}

array\_values()函数可以返回数组中的所有值，而且忽略原始的键名，并使用顺序的数字对数组重新索引。

\begin{lstlisting}[language=PHP]
array array_values ( array $input )
\end{lstlisting}

\subsection{array\_keys()}

array\_keys()函数可以返回一个数组中的所有键，其返回值是一个包含数字或字符串的键名数组。



\begin{lstlisting}[language=PHP]
array array_keys ( array $array [, mixed $search_value [, bool $strict = false ]] )
\end{lstlisting}


array\_values()和array\_keys()函数都把数组作为一维的进行处理，并且保持元素值或键名的原始顺序。


\subsection{array\_flip()}

array_flip() 返回一个反转后的 array，例如 trans 中的键名变成了值，而 trans 中的值成了键名。


\begin{lstlisting}[language=PHP]
array array_flip ( array $trans )
\end{lstlisting}


值和键名的交换是有条件的，数组的值可以重复将导致交换后的数组中发生覆盖。

\begin{lstlisting}[language=PHP]

\end{lstlisting}

\subsection{in\_array()}




\begin{lstlisting}[language=PHP]
bool in_array ( mixed $needle , array $haystack [, bool $strict = FALSE ] )
\end{lstlisting}

\subsection{array\_search()}

array\_search()函数和in\_array()函数的参数相同，而且都支持对数据类型的严格判断。





\begin{lstlisting}[language=PHP]
mixed array_search ( mixed $needle , array $haystack [, bool $strict = false ] )
\end{lstlisting}


\subsection{array\_key\_exists()}


array\_key\_exists()函数可以检索给定的键名（索引）是否存在于数组中。

\begin{lstlisting}[language=PHP]
bool array_key_exists ( mixed $key , array $search )
\end{lstlisting}

数组的键名是唯一的，也无需对其数据类型进行判断，因此在检索给定的键名时使用isset()函数是一个更好的选择。


\begin{lstlisting}[language=PHP]
if(array_key_exists("num",$var_array)){
	echo $var_array[$key];
}

// isset()是更为常见的解决方案
if(isset($var_array["num"])){
	echo $var_array[$key];
}
\end{lstlisting}

\section{Pointer}

指针是PHP数组的内部组织机制，内部指针指向一个数组单元，或者说对应着一个数组元素。

\begin{compactitem}
\item 在数组初始化时，或者将一个数组赋值给另一个数组时，指针将指向数组最开始的元素；
\item 在数组初始化后，通过移动或改变指针位置，可以访问数组的任意元素。
\end{compactitem}

\subsection{current()}





\begin{lstlisting}[language=PHP]
mixed current ( array &$array )
\end{lstlisting}


\subsection{key()}


\begin{lstlisting}[language=PHP]
mixed key ( array &$array )
\end{lstlisting}


\subsection{prev()}




\begin{lstlisting}[language=PHP]
mixed prev ( array &$array )
\end{lstlisting}

\subsection{next()}



\begin{lstlisting}[language=PHP]
mixed next ( array &$array )
\end{lstlisting}


\subsection{end()}



\begin{lstlisting}[language=PHP]
mixed end ( array &$array )
\end{lstlisting}


\subsection{reset()}



\begin{lstlisting}[language=PHP]
mixed reset ( array &$array )
\end{lstlisting}


\subsection{each()}

each()函数返回数组当前元素的一个键名/值的构造数组，并使数组指针向前移动一位。

\begin{lstlisting}[language=PHP]
array each ( array &$array )
\end{lstlisting}


\subsection{list()}

each()和list()可以配合使用来进行数组的遍历操作，不过list()仅能用于数字索引的数组，并假定数字索引从0开始。

用户可以使用下面的表达式来直接获得数组中的当前元素的键名和值。


\begin{lstlisting}[language=PHP]
list($index, $fruit) = each($arr)
\end{lstlisting}

\section{Variable}


extract()和compact()函数可以进行数组和变量之间的转换，并且转换后的数组元素的键名和变量名，以及元素的值和元素的值保持着对应的关系。


\subsection{extract()}





\begin{lstlisting}[language=PHP]
int extract ( array &$var_array [, int $extract_type = EXTR_OVERWRITE [, string $prefix = NULL ]] )
\end{lstlisting}

\subsection{compact()}



\begin{lstlisting}[language=PHP]
array compact ( mixed $varname [, mixed $... ] )
\end{lstlisting}

\section{Segment}


对于较大的数组，可以进行分段来提高操作效率。

\subsection{array\_slice()}




\begin{lstlisting}[language=PHP]
array array_slice ( array $array , int $offset [, int $length = NULL [, bool $preserve_keys = false ]] )
\end{lstlisting}


\subsection{array\_splice()}


\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{array\_chunk()}


\begin{lstlisting}[language=PHP]
array array_chunk ( array $input , int $size [, bool $preserve_keys = false ] )
\end{lstlisting}


\section{Padding}

\subsection{array\_pad()}




\begin{lstlisting}[language=PHP]
array array_pad ( array $input , int $pad_size , mixed $pad_value )
\end{lstlisting}

\section{Stack}

PHP数组也可以作为栈（数组栈）使用，栈底指向数组的第一个元素，栈顶指向数组中的最后一个元素。

对数组栈的操作包括入栈和出栈，而且PHP提供了array\_push()和array\_pop()函数来实现数组栈元素的压入和弹出。

\subsection{array\_push()}


\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{array\_pop()}



\begin{lstlisting}[language=PHP]

\end{lstlisting}



\section{Queue}



PHP数组可以实现对队列的模拟，这样就可以在队列的一端插入数组，并且在另一侧删除数据，这样最先进入队列的数据将最先离开队列。

\begin{compactitem}
\item 允许插入的一端称为队尾，即数组的第一个元素；
\item 允许删除的一端称为队头，即数组的最后一个元素。
\end{compactitem}


\subsection{array\_shift()}



\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{array\_unshift()}


\begin{lstlisting}[language=PHP]

\end{lstlisting}

\section{Callback}

回调机制允许用户使用自定义的方法对数据进行操作，例如回调函数可以用于对数组的处理。


\subsection{array\_walk()}

array\_walk()函数可以使用用户自定义的函数来对数组中的每个成员进行处理，因此也称为单一数组回调处理函数。



\begin{lstlisting}[language=PHP]
bool array_walk ( array &$array , callable $funcname [, mixed $userdata = NULL ] )
\end{lstlisting}

在array\_walk()函数中使用回调函数可以直接改变数组的元素值，但是对于键名的更改是无效的。


\subsection{array\_map()}



\begin{lstlisting}[language=PHP]
array array_map ( callable $callback , array $arr1 [, array $... ] )
\end{lstlisting}


\begin{lstlisting}[language=PHP]

\end{lstlisting}

回调函数平行作用于相应的数组元素上，因此array\_map()函数用于两个或多个数组时，它们的长度应该相同，否则最短的数组将用NULL元素进行扩充。

和使用单个数组不同，array\_map()函数忽略多个数组中的键名，并统一分配数字索引作为键名。


\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{array\_filter()}



\begin{lstlisting}[language=PHP]
array array_filter ( array $input [, callable $callback = "" ] )
\end{lstlisting}

\subsection{array\_reduce()}

array_reduce() 将回调函数 function 迭代地作用到 input 数组中的每一个单元中，从而将数组简化为单一的值。

\begin{lstlisting}[language=PHP]
mixed array_reduce ( array $input , callable $function [, mixed $initial = NULL ] )
\end{lstlisting}



\section{Sort}

PHP可以通过元素或索引进行排序，也可以使用自然排序法或用户自定义的排序方法等进行排序。

\subsection{sort()}


\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{rsort()}


\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{usort()}


\begin{lstlisting}[language=PHP]

\end{lstlisting}

\subsection{asort()}



\begin{lstlisting}[language=PHP]

\end{lstlisting}

\subsection{arsort()}

\begin{lstlisting}[language=PHP]

\end{lstlisting}

\subsection{uasort()}



\begin{lstlisting}[language=PHP]

\end{lstlisting}

\subsection{ksort()}



\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{krsort()}


\begin{lstlisting}[language=PHP]

\end{lstlisting}



\subsection{uksort()}



\begin{lstlisting}[language=PHP]

\end{lstlisting}

\subsection{natsort()}


natsort()函数可以使用自然排序法对包含文件名的数组进行排序，而且排序结构忽略键名。

natsort()函数对大小写不敏感，如果需要使用键名和值对应的“自然排序”，可以使用uasort()和strnatcmp()函数的替代方式。



\begin{lstlisting}[language=PHP]

\end{lstlisting}


\section{Computation}


通常情况下，对数组的计算包括求数组内部的所有元素之和，或者把数组作为一个集合进行处理，以及对两个或多个数组进行合并，计算数组之间的差集或交集等。

\subsection{array\_sum()}

\begin{lstlisting}[language=PHP]

\end{lstlisting}

\subsection{array\_merge()}



\begin{lstlisting}[language=PHP]

\end{lstlisting}

\subsection{array\_merge\_recursive()}


\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{array\_diff()}


\begin{lstlisting}[language=PHP]

\end{lstlisting}

\subsection{array\_intersect()}

和计算数组的差集类似，数组的交集仅计算多维数组中的一维，因此需要使用索引进行依次计算才能正确地处理多维数组。

在交集运算的结果数组中，键名将保持不变。




\subsection{array\_intersect\_assoc()}



\begin{lstlisting}[language=PHP]

\end{lstlisting}


\section{Unique}

\subsection{array\_unique()}

array\_unique()函数可以移除数组中重复的值，并且返回以恶没有重复元素的新数组。

一般情况下，数组中的重复元素指元素的字符串表达式相同，新的数组中将会保留元素原始的键名。




\section{Reverse}


\subsection{array\_reverse()}



\section{Random}


\subsection{array\_rand()}



array\_rand()从数组中随机取出一个或多个单元，并返回随机条目的一个或多个键。


\begin{lstlisting}[language=PHP]
mixed array_rand ( array $input [, int $num_req = 1 ] )
\end{lstlisting}


在下面的示例中使用随机数发生器种子来随机输出字符串。


\begin{lstlisting}[language=PHP]
<?php

// 设置随机数发生器种子
srand((float)microtime() * 10000000);

$servers = array("UNIX","Linux","Windows","Mac OS X","Solaris");
$rand_keys = array_rand($servers,2);
print $servers[$rand_keys[0]]."\n";
print $servers[$rand_keys[1]]."\n";
?>
\end{lstlisting}

在处理随机问题时，通常必须首先设置随机发生器的种子，这样才能让随机数功能正常执行。


\subsection{shuffle()}


shuffle()函数可以将数组的顺序打乱，其实质也是一个随机化过程，因此需要设置随机数发生器种子。

\begin{lstlisting}[language=PHP]
<?php
$numbers = range(1,20);
srand((float)microtimes() * 1000000);
shuffle($numbers);

// 循环输出
while(list(,$number) = each ($numbers))
{
	echo "$number = ";
}
?>
\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}




\section{Range}

\subsection{range()}





\begin{lstlisting}[language=PHP]
array range ( mixed $start , mixed $limit [, number $step = 1 ] )
\end{lstlisting}




\begin{lstlisting}[language=PHP]

\end{lstlisting}




\begin{lstlisting}[language=PHP]

\end{lstlisting}


\begin{lstlisting}[language=PHP]

\end{lstlisting}




\begin{lstlisting}[language=PHP]

\end{lstlisting}




\begin{lstlisting}[language=PHP]

\end{lstlisting}




\begin{lstlisting}[language=PHP]

\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}



\chapter{PHP Date/Time}


\section{date()}



PHP 的 date() 函数用于格式化时间戳\footnote{时间戳是自 1970 年 1 月 1 日（00:00:00 GMT）以来的秒数，它也被称为 Unix 时间戳（Unix Timestamp）。}或日期，从而产生可读性更好的日期和时间。

\begin{lstlisting}[language=PHP]
     date(format,timestamp)
\end{lstlisting}

其中：

\begin{compactitem}
\item format是必需的，用于规定时间戳的格式。
\item timestamp是可选的，用于规定时间戳。默认是当前的日期和时间。
\end{compactitem}


date() 函数的第一个参数规定了如何格式化日期/时间，它使用字母来表示日期和时间的格式。下面列出了一些可用的字母：

\begin{compactitem}
\item d - 月中的天 (01-31)
\item m - 当前月，以数字计 (01-12)
\item Y - 当前的年（四位数）
\end{compactitem}

通过在字母之间插入其他字符，比如 "/"、"." 或者 "-"，这样就可以对日期增加附加格式：


\begin{lstlisting}[language=PHP]
<?php
echo date("Y/m/d");
echo "<br />";
echo date("Y.m.d");
echo "<br />";
echo date("Y-m-d");
?>
\end{lstlisting}

date() 函数的第二个参数规定了一个时间戳，此参数是可选的。如果没有提供时间戳，将使用当前的时间。

\section{mktime()}


mktime() 函数可为指定的日期返回 Unix 时间戳。

\begin{lstlisting}[language=PHP]
mktime(hour,minute,second,month,day,year,is_dst)
\end{lstlisting}

下面的示例将使用 mktime() 函数为明天创建一个时间戳。


\begin{lstlisting}[language=PHP]
<?php
$tomorrow = mktime(0,0,0,date("m"),date("d")+1,date("Y"));
echo "明天是".date("Y/m/d", $tomorrow);
?>
\end{lstlisting}

PHP date/time 函数允许用户提取并格式化服务器上的日期和时间，当然这些函数依赖于服务器的本地设置（日期/时间函数的行为受到 php.ini 中设置的影响）。date/time 函数是 PHP 核心的组成部分，无需安装即可使用这些函数。


\begin{longtable}{|m{90pt}|m{40pt}|m{180pt}|m{60pt}|}
%head
\multicolumn{4}{r}{}
\tabularnewline\hline
名称	&默认	&描述	&可改变
\endhead
%endhead

%firsthead
\caption{PHP Date/Time 配置选项}\\
\hline
名称	&默认	&描述	&可改变
\endfirsthead
%endfirsthead

%foot
\multicolumn{4}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot

\hline
date.default\_latitude	 &``31.7667"	&规定默认纬度（从 PHP 5 开始可用）。date\_sunrise() 和 date\_sunset() 使用该选项。	&PHP\_INI\_ALL\\
\hline
date.default\_longitude	&``35.2333"	&规定默认经度（从 PHP 5 开始可用）。date\_sunrise() 和 date\_sunset() 使用该选项。	&PHP\_INI\_ALL\\
\hline
date.sunrise\_zenith		&``90.83"	&规定日出天顶（从 PHP 5 开始可用）。date\_sunrise() 和 date\_sunset() 使用该选项。	&PHP\_INI\_ALL\\
\hline
date.sunset\_zenith		&``90.83"	&规定日落天顶（从 PHP 5 开始可用）。date\_sunrise() 和 date\_sunset() 使用该选项。	&PHP\_INI\_ALL\\
\hline
date.timezone			&``"	&规定默认时区（从 PHP 5.1 开始可用）。	&PHP\_INI\_ALL\\
\hline
\end{longtable}






\section{PHP Date/Time Functions}







\begin{longtable}{|m{120pt}|m{250pt}|m{20pt}|}
%head
\multicolumn{3}{r}{}
\tabularnewline\hline
函数	&描述	&PHP
\endhead
%endhead

%firsthead
\caption{PHP Date / Time 函数}\\
\hline
函数	&描述	&PHP
\endfirsthead
%endfirsthead

%foot
\multicolumn{3}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot

\hline
checkdate()						&验证格利高里日期。	&3\\
\hline
date\_default\_timezone\_get()	&返回默认时区。	&5\\
\hline
date\_default\_timezone\_set()	&设置默认时区。	&5\\
\hline
date\_sunrise()					&返回给定的日期与地点的日出时间。	&5\\
\hline
date\_sunset()					&返回给定的日期与地点的日落时间。&	5\\
\hline
date()							&格式化本地时间／日期。&	3\\
\hline
getdate()						&返回日期／时间信息。	&3\\
\hline
gettimeofday()					&返回当前时间信息。	&3\\
\hline
gmdate()						&格式化 GMT/UTC 日期/时间。	&3\\
\hline
gmmktime()						&取得 GMT 日期的 UNIX 时间戳。	&3\\
\hline
gmstrftime()					&根据本地区域设置格式化 GMT/UTC 时间/日期。	&3\\
\hline
idate()							&将本地时间/日期格式化为整数	&5\\
\hline
localtime()						&返回本地时间。	&4\\
\hline
microtime()						&返回当前时间的微秒数。	&3\\
\hline
mktime()						&返回一个日期的 Unix 时间戳。&	3\\
\hline
strftime()						&根据区域设置格式化本地时间/日期。&	3\\
\hline
strptime()						&解析由 strftime 生成的日期/时间。&	5\\
\hline
strtotime()						&将任何英文文本的日期或时间描述解析为 Unix 时间戳。&	3\\
\hline
time()							&返回当前时间的 Unix 时间戳。&	3\\
\hline
\end{longtable}



\section{PHP Date/Time Constants}


\begin{longtable}{|m{120pt}|m{250pt}|m{20pt}|}
%head
\multicolumn{3}{r}{}
\tabularnewline\hline
常量	&描述	&PHP
\endhead
%endhead

%firsthead
\caption{PHP Date / Time 常量}\\
\hline
常量	&描述	&PHP
\endfirsthead
%endfirsthead

%foot
\multicolumn{3}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot

\hline
DATE\_ATOM	&原子钟格式 (如: 2005-08-15T16:13:03+0000)	 &\\
\hline
DATE\_COOKIE	&HTTP Cookies 格式 (如: Sun, 14 Aug 2005 16:13:03 UTC)	 &\\
\hline
DATE\_ISO8601&	ISO-8601 (如: 2005-08-14T16:13:03+0000)	 &\\
\hline
DATE\_RFC822	&RFC 822 (如: Sun, 14 Aug 2005 16:13:03 UTC)	 &\\
\hline
DATE\_RFC850	&RFC 850 (如: Sunday, 14-Aug-05 16:13:03 UTC)	 &\\
\hline
DATE\_RFC1036	&RFC 1036 (如: Sunday, 14-Aug-05 16:13:03 UTC)	 &\\
\hline
DATE\_RFC1123&	RFC 1123 (如: Sun, 14 Aug 2005 16:13:03 UTC)	 &\\
\hline
DATE\_RFC2822&	RFC 2822 (如: Sun, 14 Aug 2005 16:13:03 +0000)	 &\\
\hline
DATE\_RSS		&RSS (如: Sun, 14 Aug 2005 16:13:03 UTC)	 &\\
\hline
DATE\_W3C	&World Wide Web Consortium \newline (如:2005-08-14T16:13:03+0000)	 &\\
\hline
\end{longtable}










\chapter{PHP Filesystem}


在物理磁盘的上层的抽象层是文件系统，因此用户的角度来看，数据、信息和程序等都是以文件的形式存储在物理磁盘上。

文件的大小并不是固定的，因此一个文件通常需要对应磁盘上的一个或多个存储单元，目录（或文件夹）可以用来对文件进行有效地区分和管理。

从广义上来说，物理磁盘、文件和目录是操作系统固有地组成部分，通称为文件系统。

\section{filetype()}

PHP基于UNIX系统模型来设计对文件系统的操作，因此PHP的文件系统操作函数类似于UNIX的shell命令。




PHP将文件划分为file、dir、block、link、fifo、char和unknown等类型。

\begin{table}
\centering
\begin{tabular}{|l|l|}
\hline
file & 普通文件\\
\hline
dir & 目录\\
\hline
block & 设备文件\\
\hline
link & 符号链接\\
\hline
fifo & 命名管道\\
\hline
char & 套接字\\
\hline
unknown & 未知类型，使用非UNIX结构的文件\\
\hline
\end{tabular}
\end{table}


Windows没有提供UNIX的文件系统特性，而是通过其自己的实现来对绝大多数函数进行兼容，不过只能支持file、dir和unknown等文件类型。


\subsection{is\_file()}



\subsection{is\_dir()}



\subsection{is\_link()}


\subsection{stat()}


\subsection{lstat(}


\subsection{clearstatcache()}


PHP通过缓存stat()、lstat()等相关函数的返回信息来提供更快的性能，不过在某些情况下，用户可能需要清除被缓存的信息。


例如，在一个脚本中多次检查同一个文件，而且该文件在脚本执行期间可能被删除或修改，因此需要使用clearstatcache()来清除文件状态缓存。

\section{Operation}


文件处理包括文件读、写、删除、锁定，以及检查文件类型、文件完整性等。


为了读取或写入一个本地文件，首先需要以特定方式（只读、只写或可读可写等）打开文件，然后在系统获得对文件的控制权后，就可以执行相应的读写操作。


在文件处理操作结束后，需要及时关闭文件来释放资源。


除了操作本地文件之外，只要激活php.ini中的“allow\_url\_fopen”选项，PHP也支持访问远程文件。





\subsection{fopen()}




fopen() 函数用于在 PHP 中打开文件。此函数的第一个参数含有要打开的文件的名称，第二个参数规定了使用哪种模式来打开文件：

\begin{lstlisting}[language=PHP]
<?php
  $file=fopen("welcome.txt","r");
?>
\end{lstlisting}

文件可能通过下列模式\footnote{如果 fopen() 无法打开指定文件，则返回 0 (false)。}来打开：


\begin{longtable}{|m{50pt}|m{300pt}|}
%head
\multicolumn{2}{r}{}
\tabularnewline\hline
模式	&描述
\endhead
%endhead

%firsthead
\caption{PHP fopen() 模式}\\
\hline
模式	&描述
\endfirsthead
%endfirsthead

%foot
\multicolumn{2}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot

\hline
r	&只读。在文件的开头开始。\\
\hline
r+	&读/写。在文件的开头开始。\\
\hline
w	&只写。打开并清空文件的内容；如果文件不存在，则创建新文件。\\
\hline
w+	&读/写。打开并清空文件的内容；如果文件不存在，则创建新文件。\\
\hline
a	&追加。打开并向文件文件的末端进行写操作，如果文件不存在，则创建新文件。\\
\hline
a+	&读/追加。通过向文件末端写内容，来保持文件内容。\\
\hline
x	&只写。创建新文件。如果文件已存在，则返回 FALSE。\\
\hline
x+	&读/写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。\\
\hline
\end{longtable}

如果 fopen() 不能打开指定的文件，下面的例子会生成一段消息：


\begin{lstlisting}[language=HTML]
<?php
  $file=fopen("welcome.txt","r") or exit("Unable to open file!");
?>
\end{lstlisting}


为了使用fopen()访问远程文件，需要指定正确的URL参数，PHP可以依据相应的协议和地址进行处理。

PHP的fopen()函数支持HTTP、HTTPS、FTP和FTPS等协议。

\begin{compactitem}
\item 对于HTTP和HTTPS，fopen()只能以只读方式打开URL；
\item 对于FTP和FTPS，fopen()支持以“只写”或“只读”方式打开URL；
\item 对于FTP和FTPS，fopen()不能使用“可读可写”方式打开URL。
\end{compactitem}

在下面的示例中，fopen()获取远程文件内容后进行分析，并且配合正则表达式进行匹配，从而将结果重新格式化后在页面输出。


\begin{lstlisting}[language=PHP]
<?php
	set_time_limit(0);		//为了避免连接超时，这里设定
						//对程序运行时间未做限制
	$remote_url = "http://www.taodoor.com";

	//打开远程文件
	$handdle = fopen($remote_url . "/news.html", "r");

	if($handdle)
	{
		$data = '';

		//读取文件
		while(!feof($handdle))
		{
			$data .= fgets($handdle, 1024);
		}

		//使用正则表达式分析页面的链接地址
		preg_match_all('/<a\s+href="?([^>"]+)"?\s*[^>]*>([^>]+)<\/a>/i',$data,$arr);

		//循环输出
		for($i=0; $i<count($arr[1]); $i++)
		{
			echo '<li><a href="'.$remote_url.$arr[1][$i].'">'.$arr[2][$i].'</a>';
		}
	}else{
		echo "无法连接到远程服务器。";
	}
?>
\end{lstlisting}

在访问远程主机并执行文件操作时，难免发生超时错误，因此可以使用set\_time\_limit()函数来对程序的运行时间进行限制。




\subsection{fclose()}

fclose() 函数用于关闭打开的文件。

\begin{lstlisting}[language=PHP]
<?php
$file = fopen("test.txt","r");

//some code to be executed

fclose($file);
?>
\end{lstlisting}


\subsection{fsize()}


\subsection{feof()}


feof() 函数检测是否已达到文件的末端 (EOF)。在循环遍历未知长度的数据时，feof() 函数很有用，但是在 w 、a 以及 x 模式下无法读取打开的文件。


\begin{lstlisting}[language=PHP]
if (feof($file)) echo "End of file";
\end{lstlisting}


\subsection{fread()}



下面的示例代码说明了如何正确地将文件内容读取到\$content字符串中，并且对于二进制文件同样也是安全的。


\begin{lstlisting}[language=PHP]
<?php
	$filename = "/usr/local/readme.txt";
	
	//一次性读取整个文件
	$handle = fopen ($filename, "r");			//打开一个只读文件
	$length = filesize ($filename);				//计算文件的大小
	$content = fread ($handle, $length);			//读取文件的内容
	fclose ($handle);						//关闭文件
	
	//传统读取文件的方法
	$handle = fopen ($filename, "r+");
	$content = "";

	//使用feof()判断文件的结束
	while(!feof($handle))
	{
		$content .= fread($handle, 1024);
	}
	fclose ($handle);

	//更便捷的方法
	$handle = fopen ($filename, "r");
	$content = "";
	do{
		$data = fread($handle, 1024);
		if(strlen($data)===0)					//当没有数据时，跳出循环
			break;
		$content .= $data;
	}while(1);
	fclose ($handle);

	//使用fgets()的方法
	$handle = fopen ($filename, "rt");			//使用“t”将“\n”替换为“\r\n”
	while (!feof ($handle)) 
	{
		$content .= fgets($handle, 4096);
	}
	fclose ($handle);

	//使用fgetc()逐字节读取文件内容
	$handle = fopen ($filename, "r");
	while (($c = fgetc($handle))!==FALSE) 
	{
		$content .= $c;
	}
	fclose ($handle);
?>
\end{lstlisting}

\subsection{fgets()}


fgets() 函数用于从文件中逐行读取文件。在调用该函数之后，文件指针会移动到下一行。

下面的例子逐行读取文件，直到文件末端为止：


\begin{lstlisting}[language=PHP]
$file = fopen("welcome.txt", "r") or exit("Unable to open file!");
//Output a line of the file until the end is reached
while(!feof($file))
  {
  echo fgets($file). "<br />";
  }
fclose($file);
?>
\end{lstlisting}


\subsection{fgetc()}


fgetc() 函数用于从文件逐字符地读取文件。在调用该函数之后，文件指针会移动到下一个字符。

下面的例子逐字符地读取文件，直到文件末端为止：

\begin{lstlisting}[language=PHP]
$file = fopen("welcome.txt", "r") or exit("Unable to open file!");
//Output a line of the file until the end is reached
while(!feof($file))
  {
  echo fgetc($file). "<br />";
  }
fclose($file);
?>
\end{lstlisting}

\subsection{fwrite()}

下面的示例代码说明如何写入文件。

\begin{lstlisting}[language=PHP]
<?php
	$filename = 'test.txt';
	$somecontent = "添加这些文字到文件\n";

	//首先要确定文件存在并且可写
	if (is_writable($filename))
	{
    		//使用添加模式打开$filename，文件指针将会在文件的开头
	     if (!$handle = fopen($filename, 'a')) 
		{
			echo "不能打开文件 $filename";
			exit;									//无法打开文件则退出程序
    		}

    		//将$somecontent写入到我们打开的文件中。
		if (!fwrite($handle, $somecontent)) 
		{
			echo "不能写入到文件 $filename";
			exit;									//无法写入文件则退出程序
		}

		echo "文件“$filename”写入成功";

		//关闭文件
		fclose($handle);
	} else {
		echo "文件“$filename”不可写";
	}
?>
\end{lstlisting}


在写入文件之前需要使用is\_writable()函数判断文件是否可写，然后在可写的情况下按照打开、写入、关闭文件的顺序依次进行操作。

不同的操作系统使用不同的行结束符，因此在写入一个文本文件并需要插入一个新行时需要使用符合相应操作系统的行结束符。

\begin{compactitem}
\item UNIX/Linux等系统使用“\textbackslash n”作为行结束符；
\item Windows系统使用“\textbackslash r\textbackslash n”作为行结束符。
\item Mac OS X操作系统使用“\textbackslash r”作为行结束符。
\end{compactitem}




\subsection{fputs()}


\subsection{unlink()}


在删除文件时可能会发生删除失败的情况，其原因可能包括文件不存在、文件权限错误、文件被锁定以及删除目录而非文件等。

为了屏蔽删除文件失败时发生的错误，通常可以使用“@”来禁止显示删除文件时发生的E\_WARNING错误报告。


\subsection{ftruncate()}



\subsection{file\_get\_contents()}

fopen()、fread()、fgets()、fseek()等只能对文件进行最基本的处理，并返回文件指针。

file\_get\_contents()和file()函数可以使用更加简洁的方式来获得文件的全部或部分内容，并返回字符串或数组。

file\_get\_contents()函数可以将整个文件读入到一个字符串中，并且避免文件的打开、锁定和关闭等操作。

在操作系统提供支持的情况下，file\_get\_contents()函数还可以使用内存映射技术来增强性能。

和fopen()等函数打开本地或远程文件连接类似，file\_get\_contents()函数除了可以读取本地文件之外，还可以读取远程主机上的文件。

\begin{lstlisting}[language=PHP]
<?php
	//读取一个本地文件
	echo file_get_contents("/home/tom/public_html/index.html");

	//读取一个远程文件
	echo file_get_contents("http://www.taodoor.com/index.php");

	//如果使用低版本的PHP程序，应该使用代替方案，
	//这样可以增强程序的移植性
	if(!file_exists("file_get_contents"))
	{
		//自定义的代替方法
		function file_get_contents ($filename)
		{
			//打开文件
			$fp = @fopen ($filename, "r");

			//锁定文件
			@flock($fp, LOCK_SH);

			//读取文件内容
			$data = @fread($fp, filesize($filename));

			//关闭文件
			@fclock($fp);

			if($data)
			{
				return $data;
			}else{
				return "";
			}
		}
	}
?>
\end{lstlisting}



\subsection{file()}



file()函数可以将整个文件读入到一个数组中，这样就可以使用数组的相关函数来对文件内容进行处理。

从实质上来讲，file()函数通过把整个文件进行分割后读入数组，这样数组中的每个元素就是文件中相应的行（并且包括换行符在内）。

在分析日志文件时，可以通过file()函数实现对日志文件内容倒序处理，这样就可以从日志文件中获得最新的记录，它们原来的位置是日志文件的尾部。

\begin{lstlisting}[language=PHP]
<?php
	$logs = file("server.log");			//读取一个日志文件
	$contents = array_reverse($logs);
	foreach($contents as $line){
		echo $line;
	}
?>
\end{lstlisting}




\section{Pointer}



在PHP中对文件指针进行操作时，必须首先提供一个使用fopen()函数打开的、合法的文件指针。


文件指针的位置是以文件头开始的字节数度量的。

\subsection{ftell()}



\subsection{fseek()}


\subsection{rewind()}


\section{Tempfile}


PHP支持创建一个临时文件来存储数据，使用tmpfile()和tempnam()可以建立一个具有唯一文件名的临时文件。

通常情况下，PHP文件函数创建的临时文件位于系统临时目录/tmp下。


\subsection{tmpfile()}


tmpfile()函数不需要任何参数就可以以写模式建立一个具有唯一文件名的临时文件，并返回一个和fopen()相似的文件指针。

tmpfile()创建的临时文件在fclose()关闭文件或脚本执行结束后会被自动删除。

\subsection{tempnam()}


\begin{compactitem}
\item tmpfile()无法指定临时文件的目录，也无法获知创建的文件名。
\item tempnam()可以对临时文件提供更多的控制。
\end{compactitem}

tempnam()函数可以在指定的目录下创建一个具有唯一文件名的文件，而且tempnam()创建的临时文件不会被自动删除，除非使用unlink()进行手动删除。

\section{Lock}


\subsection{flock()}


在网络环境下，不同用户进程可能在同一时刻对同一文件进行操作，不合理的并发模型可能会对文件造成破坏。

最典型的网络文件访问破坏是多个进程同时对文件进行写入操作，用户可以使用flock()来对文件使用锁机制来避免文件访问破坏。


flock() 允许执行一个简单的可以在任何平台中使用的读取/写入模型（包括大部分的 Unix 派生版和 Windows）。

\begin{lstlisting}[language=PHP]
bool flock ( resource $handle , int $operation [, int &$wouldblock ] )
\end{lstlisting}



flock()函数获取文件的指针\$handle，并将该文件设定为某一访问权限\$operation。

\$operation 可以是以下值之一：

\begin{compactitem}
\item LOCK\_SH：共享锁定，读取文件时使用；
\item LOCK\_EX：独占锁定，写入文件时使用；
\item LOCK\_UN：释放锁定，释放已经存在的共享或独占锁；
\item LOCK\_NB：附加锁定，如果不希望flock()在锁定时堵塞，就应该在上述锁定后加上该锁。
\end{compactitem}

PHP 支持以咨询方式对全部文件执行轻便的锁定，也就是说所有访问程序必须使用同一方式锁定, 否则它不会工作。



flock()函数可以辨别同时运行的独立进程，判断它们能否在共享或独占模式下访问文件。



默认情况下，flock()函数会阻塞到获取锁，可以通过LOCK\_NB选项来控制（在非 Windows 平台上）。

如果其他进程不服从或不识别flock()函数加在用户文件上的锁，那么这个进程会忽略已存在的文件锁，因此只有所有访问程序使用相同的方式锁定文件时才能让flock()发挥作用，这样就要求其他访问程序都必须服从于flock()函数。

一个文件可以同时存在很多共享锁定LOCK\_SH，这样多个进程可以在同一时刻拥有对该文件的读取访问权限；


一个独占锁定LOCK\_EX只允许一个用户拥有一次，通常被用于文件的写入操作。

如果其他进程需要访问具有独占锁定的文件，那么必须等到独占锁定被释放以后才能进行。



\begin{lstlisting}[language=PHP]
<?php
	$fname = "/home/tom/public_html/test.txt";
	
	//以读写方式打开文件
	if( $fp = @fopen($fname, "w+") )
	{
		die("无法打开文件 $fname");
	}
	
	//写入文件时，总将文件锁定为LOCK_EX
	if( !flock($fp, LOCK_EX) )
	{
		die("无法将文件锁定为 LOCK_EX\n");
	}
	//写入文件
	fwrite($fp, "第一行文字\n");
	fwrite($fp, "另一行文字\n");

	flock($fp, LOCK_UN);						//释放独占锁定

	//读取文件时，总将文件锁定为LOCK_SH
	if( !flock($fp, LOCK_SH) )
	{
		die("无法将文件锁定为 LOCK_SH\n");
	}

	//读取文件
	rewind($fp);								//将文件指针倒回文件的开头
	while(!feof($fp))
	{
		echo fread($fp, 1024);
	}

	flock($fp, LOCK_UN);						//释放共享锁定

	fclose($fp);								//关闭文件
?>
\end{lstlisting}



在Windows以外的操作系统中，对于已经被flock()函数锁定的文件，如果再次执行锁定就会使flock()函数被挂起（锁定堵塞），直到以前的所有其他锁定被释放。

如果不希望上述锁定堵塞的情况发生，可以在\$operation参数中附加LOCK\_NB。

下面的示例说明了如何防止锁定堵塞发生。


\begin{lstlisting}[language=PHP]
<?php
	$fp = fopen($fname, "w+");
	flock($fp, LOCK_EX + LOCK_NB);
	fwrite($fp, "Some thing wrote\n");
	flock($fp, LOCK_UN + LOCK_NB);
	fclose();
?>
\end{lstlisting}




\begin{lstlisting}[language=PHP]

\end{lstlisting}




\begin{lstlisting}[language=PHP]

\end{lstlisting}




\begin{lstlisting}[language=PHP]

\end{lstlisting}

\section{Upload}





PHP允许用户从表单上传文件到服务器，也不限制浏览器上传的文件类型，而且PHP还允许用户对服务iq文件的下载进行控制。

不过，从安全方面来考虑时会发现允许用户上传文件是一个巨大的安全风险，因此应该仅仅允许可信任的用户执行文件上传操作。


最基本的文件上传方式是使用HTML表单的POST方法来提交文件。




\begin{lstlisting}[language=HTML]
<!DOCTYPE html>
<html>
<body>

<form action="upload_file.php" method="post" enctype="multipart/form-data">
<input type="hidden" name="MAX_FILE_SIZE" value="40000">
<label for="file">Filename:</label>
<input type="file" name="file" id="file" /> 
<br />
<input type="submit" name="submit" value="Submit" />
</form>

</body>
</html>
\end{lstlisting}

在隐藏域的MAX\_FILE\_SIZE中可以设置允许接收文件的最大尺寸（单位为字节），但是MAX\_FILE\_SIZE的值只是对浏览器的一个建议，可以被简单的绕过。

在实际应用中，php.ini中设置的文件上传的最大值upload\_max\_filesize是不会失效的，不过最好还是在表单中通过MAX\_FILE\_SIZE来进行限制。

<form> 标签的 enctype 属性规定了在提交表单时要使用哪种内容类型。在表单需要二进制数据时，比如文件内容，使用``multipart/form-data"。

<input> 标签的 type="file" 属性规定了应该把输入作为文件来处理。举例来说，当在浏览器中预览时，会看到输入框旁边有一个浏览按钮。

通过使用 PHP 的全局数组 \texttt{\$\_FILES}，用户可以从客户计算机向远程服务器上传文件，下面就是``upload\_file.php" 文件中用于上传文件的代码：



\begin{lstlisting}[language=PHP]
<?php
if ($_FILES["file"]["error"] > 0)
  {
  echo "Error: " . $_FILES["file"]["error"] . "<br />";
  }
else
  {
  echo "Upload: " . $_FILES["file"]["name"] . "<br />";
  echo "Type: " . $_FILES["file"]["type"] . "<br />";
  echo "Size: " . ($_FILES["file"]["size"] / 1024) . " Kb<br />";
  echo "Stored in: " . $_FILES["file"]["tmp_name"];
  }
?>
\end{lstlisting}

其中，第一个参数是表单的 input name，第二个下标可以是``name",``type", ``size", ``tmp\_name" 或``error"。就像这样：

\begin{compactitem}
\item \texttt{\$\_FILES["file"]["name"]} - 被上传文件的名称
\item \texttt{\$\_FILES["file"]["type"]} - 被上传文件的类型
\item \texttt{\$\_FILES["file"]["size"]} - 被上传文件的大小，以字节计
\item \texttt{\$\_FILES["file"]["tmp\_name"]} - 存储在服务器的文件的临时副本的名称
\item \texttt{\$\_FILES["file"]["error"]} - 由文件上传导致的错误代码
\end{compactitem}

在上述的简单文件上传实现中，服务器接收到的用户文件首先被存储在临时目录中，PHP将获得一个存储了上传文件的全部信息的\$\_FILES全局变量。


在处理文件上传的PHP脚本中，需要实现对文件进行检测并判断的逻辑，然后才能确定接下来是否允许文件开始上传。

\begin{compactitem}
\item \texttt{\$\_FILES["file"]["size"]}限制被上传文件的大小；
\item \texttt{\$\_FILES["file"]["type"]}限制被上传文件的类型；
\item \texttt{\$\_FILES["file"]["error"]}判断文件上传导致的错误代码。
\end{compactitem}

如果上传后的文件大小、类型都符合限制，那么接下来PHP可以将其从临时目录拷贝到指定的位置，从而完成文件上传。

基于安全方面的考虑，开发者应当增加有关什么用户有权上传文件的限制，因此需要增加对文件上传的限制，例如只允许用户上传 .gif 或 .jpeg 文件\footnote{对于 IE，识别 jpg 文件的类型必须是 pjpeg，对于 FireFox，必须是 jpeg。}，文件大小必须小于 20 kb。

\begin{lstlisting}[language=PHP]
<?php

if ((($_FILES["file"]["type"] == "image/gif")
|| ($_FILES["file"]["type"] == "image/jpeg")
|| ($_FILES["file"]["type"] == "image/pjpeg"))
&& ($_FILES["file"]["size"] < 20000))
  {
  if ($_FILES["file"]["error"] > 0)
    {
    echo "Error: " . $_FILES["file"]["error"] . "<br />";
    }
  else
    {
    echo "Upload: " . $_FILES["file"]["name"] . "<br />";
    echo "Type: " . $_FILES["file"]["type"] . "<br />";
    echo "Size: " . ($_FILES["file"]["size"] / 1024) . " Kb<br />";
    echo "Stored in: " . $_FILES["file"]["tmp_name"];
    }
  }
else
  {
  echo "Invalid file";
  }

?>
\end{lstlisting}

上面的例子在服务器的 PHP 临时文件夹创建了一个被上传文件的临时副本，但是这个临时的复制文件会在脚本结束时消失。


\subsection{move\_uploaded\_file()}


要保存被上传的文件，我们需要把它拷贝到另外的位置，PHP提供了专门用于上传文件拷贝的函数move\_uploaded\_file()，这样就有了copy()函数之外的另一种选择。

\begin{lstlisting}[language=PHP]
<?php
if ((($_FILES["file"]["type"] == "image/gif")
|| ($_FILES["file"]["type"] == "image/jpeg")
|| ($_FILES["file"]["type"] == "image/pjpeg"))
&& ($_FILES["file"]["size"] < 20000))
  {
  if ($_FILES["file"]["error"] > 0)
    {
    echo "Return Code: " . $_FILES["file"]["error"] . "<br />";
    }
  else
    {
    echo "Upload: " . $_FILES["file"]["name"] . "<br />";
    echo "Type: " . $_FILES["file"]["type"] . "<br />";
    echo "Size: " . ($_FILES["file"]["size"] / 1024) . " Kb<br />";
    echo "Temp file: " . $_FILES["file"]["tmp_name"] . "<br />";

    if (file_exists("upload/" . $_FILES["file"]["name"]))
      {
      echo $_FILES["file"]["name"] . " already exists. ";
      }
    else
      {
      move_uploaded_file($_FILES["file"]["tmp_name"],
      "upload/" . $_FILES["file"]["name"]);
      echo "Stored in: " . "upload/" . $_FILES["file"]["name"];
      }
    }
  }
else
  {
  echo "Invalid file";
  }
?>
\end{lstlisting}

这个例子把用户上传的文件保存到名为``upload" 的新文件夹，上面的脚本会检测是否已存在此文件，如果不存在，则把文件拷贝到指定的文件夹。



从思路上来看，处理多个文件的上传和单个文件的上传的情况是一样的，因此表单可以支持更多数量的文件上传，区别只是\$\_FILES数组的结构形式。

首先，在上传单个文件时，需要在<input>标签中指定文件的名字，并且在处理文件上传的脚本中对其进行处理。


\begin{lstlisting}[language=PHP]
<form enctype="multipart/form-data" method="POST" action="upload.php">
	<input type="hidden" name="MAX_FILE_SIZE" value="40000">
	文件：<input name="upfile" type="file">
	<input type="submit" value="上传文件">
</form>

<?php
	//上传文件的存储目录
	$uploaddir = "/home/tom/public_html/uploads/";

	//文件上传后全路径名称
	$uploadfile = $uploaddir. $_FILES["upfile"]["name"];
	
	if (move_uploaded_file($_FILES["upfile"]["tmp_name"], $uploadfile)) 
	{
	    print "文件上传成功！\n";
	    print_r($_FILES);
	} else {
	    print "文件上传失败！\n";
	    print_r($_FILES);
	}
?>
\end{lstlisting}

其次，在上传多个文件时，需要在<input>标签中指定不同的name属性值。

\begin{lstlisting}[language=PHP]
<form enctype="multipart/form-data" method="POST" action="multiy_upload.php">
	文件1：<input name="upfile1" type="file">
	文件2：<input name="upfile2" type="file">
	文件3：<input name="upfile3" type="file">
	<input type="submit" value="上传文件">
</form>

<!--
<form enctype="multipart/form-data" method="POST" action="multiy_upload.php">
	<input type="hidden" name="MAX_FILE_SIZE" value="40000">
	文件1：<input name="upfile[]" type="file"><br>
	文件2：<input name="upfile[]" type="file"><br>
	文件3：<input name="upfile[]" type="file"><br>
	<input type="submit" value="上传文件">
</form>
-->

<?php
	//文件上传目录
	$uploaddir = "/home/tom/public_html/uploads/";

	//循环遍历$_FILE数组进行判断
	for($i=0; $i<count($_FILES['upfile']['name']); $i++)
	{
		//错误数组
		$error = array();

		//判断文件大小
		if($_FILES['upfile']['size'][$i] >= 40000)
		{
			$error[] = "文件的尺寸太大！";
		}

		//判断文件类型
		if($_FILES['upfile']['type'][$i] != "text/plain")
		{
			$error[] = "文件的类型必须为文本文件！";
		}

		//其他错误类型
		if($_FILES['upfile']['error'][$i] != UPLOAD_ERR_OK)
		{
			$error[] = "文件上传失败！";
		}
	
		echo "文件{$i}：".$_FILES['upfile']['name'][$i]."<br>\n";
	
		if(count($error))
		{
			//发现错误
			echo join("<br>", $error);
		}else{
			move_uploaded_file($_FILES['upfile']['tmp_name'][$i],
							$uploaddir . $_FILES['upfile']['name'][$i]);
		}
		echo "<hr>";
	}
?>
\end{lstlisting}



\section{Download}


要实现文件下载，必须首先向浏览器发送必要的头信息来通知浏览器准备对将要下载的文件的处理。

Web服务器向浏览器发送的信息主要包括以下内容：

\begin{compactitem}
\item 下载文件的类型使用MIME类型表示；
\item 下载文件的描述给出文件名等信息；
\item 下载文件的长度以字节为单位进行说明。
\end{compactitem}

Web服务器向浏览器发送的最常见的的MIME类型就是“Content-type: text/html”。如果Web服务器向浏览器发送的是PNG图像，那么HTTP头信息可能如下：

\begin{lstlisting}[language=PHP]
Content-type: image/png
Content-Transfer-Encoding: BINARY
\end{lstlisting}


在不同的系统中，MIME类型的表示根据Web服务器的配置并不一致，例如可以在Apache httpd服务器的conf目录下查看magic文件来检查MIME类型。

\subsection{header()}

header()函数可以向浏览器发送头信息来指导下载，而且头信息必须在其他页面内容输出之前被发送，否则发生错误。

在header()函数发送完头信息后，可以使用echo()、print()等发送具体的HTML信息等输出到浏览器。




\begin{lstlisting}[language=PHP]
<?php
	//文件源是：original.html
	$name = 'original.html';

	//发送头信息：指定文件类型
	header('Content-type: text/html');

	//发送头信息：指定文件的表述
	header('Content-Disposition: attachment; filename="downloaded.html"');

	//发送头信息：指定文件的小
	header("Content-Length: ".filesize($name));

	//输出文件内容
	$fp = fopen($name, "r");
	while(false==feof($fp)){
		echo fread($fp, 1024);
	}
?>
\end{lstlisting}


\subsection{readfile()}




在输出文件内容时可以使用readfile()函数来将文件的内容直接输出到浏览器。


\begin{lstlisting}[language=PHP]
<?php
	//一个图片文件
	$name = "img.png";

	//发送头信息
	header("Content-Type: image/png");
	header("Content-Disposition: attachment; filename=\"$name\"");
	header("Content-Length: ".filesize($name));

	//输出文件
	readfile($fp);
?>
\end{lstlisting}






\begin{lstlisting}[language=PHP]

\end{lstlisting}










\begin{lstlisting}[language=PHP]

\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}




\begin{lstlisting}[language=PHP]

\end{lstlisting}




\begin{lstlisting}[language=PHP]

\end{lstlisting}





\begin{lstlisting}[language=PHP]

\end{lstlisting}






\begin{lstlisting}[language=PHP]

\end{lstlisting}










\begin{lstlisting}[language=PHP]

\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}




\begin{lstlisting}[language=PHP]

\end{lstlisting}




\begin{lstlisting}[language=PHP]

\end{lstlisting}





\begin{lstlisting}[language=PHP]

\end{lstlisting}






\begin{lstlisting}[language=PHP]

\end{lstlisting}









\begin{lstlisting}[language=PHP]

\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}




\begin{lstlisting}[language=PHP]

\end{lstlisting}




\begin{lstlisting}[language=PHP]

\end{lstlisting}





\begin{lstlisting}[language=PHP]

\end{lstlisting}






\begin{lstlisting}[language=PHP]

\end{lstlisting}








\section{Permission}


UNIX系统在安全性方面被设计为一个分级的权限控制系统，任何系统资源都属于特定的用户或用户组，其他用户或用户组在访问时则受到相应的限制。

超级用户root拥有对所有资源的绝对的控制权。

\begin{compactitem}
\item 只有root用户可以任意修改文件的所有者和用户组；
\item 其他用户只能将文件的组改为该用户自己所在的组，不能修改文件所有者。
\end{compactitem}

需要注意的是，访问权限是UNIX/Linux系统的一种内部机制，相关的函数在Windows操作系统下无效。


\subsection{fileowner()}

通常情况下，系统资源（即文件或目录）属于其创建者，fileowner()和filegroup()可以返回文件所有者ID和所属的用户组ID。




\subsection{filegroup()}



\subsection{posix\_getpwuid()}

posix\_getpwuid()和posix\_getgrgid()可以将用户ID和用户组ID解析为字符串形式。


\subsection{posix\_getgrgid()}



\subsection{chown()}





\subsection{chgrp()}



实际上，PHP运行在非root用户状态下，因此chgrp()函数在修改文件所属的组时受到一定的限制，而且使用chown()函数改变文件的所有者时不会生效。


\subsection{chmod()}


文件的访问权限可以用来指定特定的用户能否对文件进行读、写或执行等操作。

chmod()函数可以改变文件的访问权限，需要指定一个文件和相对应的权限值。

默认情况下，权限值需要使用以0开头的八进制数字表示。




\section{Path}


为了描述一个文件的位置，需要给出文件的路径和文件名。


PHP支持两种不同的路径分隔符，其中：

\begin{compactitem}
 \item UNIX/Linux系统必须使用“/”；
 \item Windows默认使用“\textbackslash ”，也接受“/”的写法。
\end{compactitem}

在考虑可移植情况时，建议使用“/”作为文件的路径分隔符，或者使用PHP内置的DIRECTORY\_SEPARATOR，其值为当前系统的默认路径分隔符。




\subsection{basename()}



\subsection{dirname()}



\subsection{pathinfo()}

pathinfo() 返回一个关联数组包含有 path 的信息。返回关联数组还是字符串取决于 options。



pathinfo()返回的数组包含了路径的信息，其中的dirname、basename和extension等分别表示目录名、文件名和文件扩展名。






\section{Directory}

PHP提供了与目录操作相关的函数，也可以使用目录类实现对文件系统中的目录的操作。

如果用户需要取得一个目录下的文件和子目录，可以使用遍历目录和检索目录两种方式来实现。


读取目录内容时可以使用opendir()、readdir()和closedir()等函数，类似于读取文件的操作，因此也称为遍历目录。

\begin{compactitem}
\item 遍历目录结构时可以使用文件系统函数，也可以使用Directory类；
\item 检索目录可以返回包含目录结构信息的数组。
\end{compactitem}

\begin{compactitem}
\item opendir()打开一个目录句柄，可用于之后的 closedir()，readdir() 和 rewinddir() 调用中。

\item readdir()返回目录中下一个文件的文件名。文件名以在文件系统中的排序返回。

\item closedir()关闭由 dir_handle 指定的目录流。流必须之前被 opendir() 所打开。

\end{compactitem}

下面的示例说明如何使用opendir()、readdir(）和closedir()等实现遍历目录结构。

\begin{lstlisting}[language=PHP]
<?php
	//打开一个目录
	$handle = @opendir("/path/to/files");
	
	if ($handle)
     {
		echo "目录文件：\n";

		readdir($handle);		//获取“.”，当前目录的表示
		readdir($handle);		//获取“..”，上级目录的表示

		//正确地遍历目录方法，使用“!==”符号
		while (false !== ($file = readdir($handle))) {
			echo "$file\n";
		}

		//将目录的指针倒回开头
		rewinddir($handle);

		//关闭目录
		closedir($handle);
	}
?>
\end{lstlisting}


PHP提供的内置的Directory类可以使用面向对象的方式来实现目录遍历。


\begin{lstlisting}[language=PHP]
Directory {
	/* 属性 */
	public string $path ;
	public resource $handle ;
	/* 方法 */
	public void close ([ resource $dir_handle ] )
	public string read ([ resource $dir_handle ] )
	public void rewind ([ resource $dir_handle ] )
}
\end{lstlisting}



Directory类是PHP的内建类，没有提供相应的构造函数，因此Directory 实例是通过调用 dir() 函数创建的，而不是 new 操作符。

下面的示例说明如何使用Directory类来实现目录遍历。

\begin{lstlisting}[language=PHP]
<?php
	//打开目录
	$d = dir("/path/to/files");

	echo "Handle: ".$d->handle."<br>\n";
	echo "Path: ".$d->path."<br>\n";
	
	//循环输出
	while (false !== ($file = $d->read()))
	{
	    echo $file."<br>\n";
	}
	
	//关闭目录
	$d->close();
?>
\end{lstlisting}


具体来说，dir()函数可以返回一个实例化了的Directory对象，其中：

\begin{compactitem}
\item \$handle是一个打开了的目录句柄；
\item \$path是当前目录的路径。
\end{compactitem}

Directory类的read()、rewind()和close()方法分别对应readdir()、rewinddir()和closedir()函数。

\begin{lstlisting}[language=PHP]

\end{lstlisting}




\subsection{opendir()}

opendir()函数接受一个目录路径字符串，并返回一个目录句柄。如果目录不存在或者无访问权限，则返回FALSE，同时产生一个E\_WARNING级别的错误信息。

在opendir()前面加上“@”符号可以抑制错误信息的输出。




\subsection{readdir()}

readdir()函数接受一个目录句柄，并返回当前目录指针位置的一个文件名，然后将目录指针向后移动一位，直到目录指针位于目录的末尾时才会返回FALSE以表示再没有文件了。

如果要重置目录指针到开始处，可以使用rewinddir()函数，该函数可以接受一个目录句柄，并将其倒回目录的开头。




\subsection{closedir()}

closedir()函数关闭一个打开的目录，也可以接受一个目录句柄作为参数来关闭指定的目录。




\subsection{glob()}

如果用户使用glob()函数检索指定的目录来实现遍历目录，也可以实现和其他目录函数类似的效果。

glob() 函数依照 libc glob() 函数使用的规则寻找所有与 pattern 匹配的文件路径，类似于一般 shells 所用的规则一样，不进行缩写扩展或参数替代。

glob()函数的返回值是一个包含目录检索结果的数组，其原型如下：

\begin{lstlisting}[language=PHP
array glob ( string $pattern [, int $flags = 0 ] )
\end{lstlisting}


\begin{compactitem}
\item \$pattern指定要检索的目录信息，可以使用“*”或“?”等通配符；
\item \$flags指定与检索模式相关的参数。
\end{compactitem}

下面的示例说明如何使用glob()函数实现检索目录文件。

\begin{lstlisting}[language=PHP
<?php
	//检索当前目录中的所有“*.txt”文件
	$files = glob("*.txt");
	foreach ($files as $filename)
	{
	    echo "$filename size " . filesize($filename) . "\n";
	}

	//检索当前目录中的所有以“c”开头的子目录
	$files = glob("c*", GLOB_ONLYDIR);
	foreach ($files as $filename) 
	{
	    echo "$filename size " . filesize($filename) . "\n";
	}

	//检索“/path/”中的所有以“a”、“b”或“c”开头的PHP文件
	$files = glob("/path/{a,b,c}*.php", GLOB_BRACE);
	foreach ($files as $filename)
	{
	    echo "$filename size " . filesize($filename) . "\n";
	}
?>
\end{lstlisting}




\subsection{mkdir()}




\subsection{rmdir()}


通常情况下，如果目录是非空的，那么就不能进行快速的删除，必须首先删除其中的文件，然后才能从最深处的目录开始层层向外删除目录。


递归思想的引入使得可以一次删除整个目录及其子目录和其中的文件。


首先，考虑要删除的目录中没有包含其他子目录的情况，只要遍历该目录并删除其他的所有文件后，就可以实现目录删除。

其次，如果目录中还包含子目录，那么就使用递归方式来删除所有目录。



\begin{lstlisting}[language=PHP]
<?php
	/**
	* 函数名：deleteDir
	* 功  能：递归地删除指定的目录
	* 参  数：$dir目录
	* 返回值：无
     */
	function deleteDir ($dir)
	{
		$handle = @opendir ($dir);	//打开目录

		readdir ($handle);			//排除当前目录“.”
		readdir ($handle);			//排除父级目录“..”
		while (false !== ($file = readdir($handle))) 
		{
			//构造文件或目录的路径
			$file = $dir .DIRECTORY_SEPARATOR. $file;

			if (is_dir ($file)){			//如果是子目录，就进行递归操作
				delete ($file);
			} else {				//如果是文件，则使用unlik()删除
				if (@unlink ($file)) {
					echo "文件<b>$file</b>删除成功了。<br>\n";
				} else {
					echo "文件<b>$file</b>删除失败！<br>\n";
				}
			}
		}
		
		//现在，删除当前目录
		if (@rmdir ($dir)) {
			echo "目录<b>$dir</b>删除成功了。<br>\n";
		} else {
			echo "目录<b>$dir</b>删除失败！<br>\n";
		}
	}

	//测试程序
	$dir = "/home/tom/public_html/delete_dir";
	deleteDir ($dir);
?>
\end{lstlisting}


在实际应用中，还需要考虑给定的目录是否已被删除，因此需要通过返回的状态值进行判断，或者在无法删除时终止并返回等。


\begin{lstlisting}[language=PHP]

\end{lstlisting}

\subsection{copy()}

PHP没有提供直接复制目录的函数，需要通过文件拷贝、删除、重命名等方法间接实现。

\subsection{rename()}

重命名文件函数rename()对目录操作也是有效的。

从表面上看，移动一个文件是将文件从一个目录复制到另一个目录，然后再删除原来目录中的文件。

从实现原理上看，移动一个文件也是一个重命名的过程，也就是将文件名中的路径名修改为移动文件后的新路径名，从而可以使用重命名思想来简化文件移动。






\begin{lstlisting}[language=PHP]
<?php
	/**
	* 函数名：move
	* 功  能：移动指定的文件和目录
	* 参  数：$source  要操作的文件
	*		 $dest    要移动到的文件目录
	* 返回值：bool
     */
	function move ($source, $dest)
	{
		$file = basename($source);			//取得目录名
		$desct = $desct .DIRECTORY_SEPARATOR. $file;
	
		return rename($source, $desct);
	}
	
	//将文件或目录从path1移动到path2目录下
	move("/path1/name.gif", "/path2");
	move("/path1/dir", "/path2");
?>
\end{lstlisting}


复制一个包含多级子目录的目录与删除一个非空目录时的情况类似，都需要涉及到文件复制、目录创建等操作，因此也是一个目录遍历和递归处理的综合。

首先，对源目录进行遍历。

\begin{compactitem}
\item 如果遇到的是文件，可以直接使用copy()函数进行复制；
\item 如果遇到的是目录，则必须先建立该目录，然后对其下的文件或子目录进行复制操作。
\end{compactitem}

其次，使用递归思想处理整个目录中的所有文件和子目录。



\begin{lstlisting}[language=PHP]
<?php
	/**
	* 函数名：copyDir
	* 功  能：递归地复制整个目录
	* 参  数：$dirFrom   源目录名
	*		$dirTo	  目标目录名
	* 返回值：无
     */
	function copyDir($dirFrom, $dirTo)
	{
		//如果遇到一个同名的文件，无法复制
		//目录则直接退出
		if(is_file($dirTo))
		{
			die("无法建立目录 $dirTo");
		}
		
		//如果目录已经存在就不必建立
		if(!file_exists($dirTo))
		{
			mkdir($dirTo);
		}

		$handle = opendir($dirFrom);		//打开当前目录

		readdir ($handle);				//排除当前目录“.”
		readdir ($handle);				//排除父级目录“..”

		//循环读取文件
		while (false !== ($file = readdir($handle))) 
		{
			//生成源文件名
			$fileFrom = $dirFrom .DIRECTORY_SEPARATOR. $file;
			//生成目标文件名
			$fileTo = $dirTo .DIRECTORY_SEPARATOR. $file;
			
			if(is_dir($fileFrom)){			//如果是子目录，就进行递归操作
				copyDir($fileFrom, $fileTo);
			}else{					//如果是文件，直接使用copy()函数
				@copy($fileFrom, $fileTo);
			}
		}
	}
	
	//测试代码
	copyDir("C:\\windows\\temp", "D:\\temp");
?>
\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}




\begin{lstlisting}[language=PHP]

\end{lstlisting}




\begin{lstlisting}[language=PHP]

\end{lstlisting}





\begin{lstlisting}[language=PHP]

\end{lstlisting}






\begin{lstlisting}[language=PHP]

\end{lstlisting}










\section{PHP Filesystem Functions}


Filesystem 函数允许您访问和操作文件系统。Filesystem 函数是 PHP 核心的组成部分，无需安装即可使用这些函数。

文件系统函数的行为受到 php.ini 中设置的影响。

\begin{longtable}{|m{110pt}|m{30pt}|m{150pt}|m{80pt}|}
%head
\multicolumn{4}{r}{}
\tabularnewline\hline
名称	&默认	&描述	&可改变
\endhead
%endhead

%firsthead
\caption{PHP Filesystem 配置选项}\\
\hline
名称	&默认	&描述	&可改变
\endfirsthead
%endfirsthead

%foot
\multicolumn{4}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot

\hline
allow\_url\_fopen	&	``1"	&本选项激活了 URL 形式的 fopen 封装协议使得可以访问 URL 对象例如文件。\newline 默认的封装协议提供用 ftp 和 http 协议来访问远程文件，一些扩展库例如 zlib 可能会注册更多的封装协议。\newline PHP 4.0.4 版以后可用。&PHP\_INI\_SYSTEM\\
\hline
user\_agent			&NULL	&定义 PHP 发送的 User-Agent。\newline PHP 4.3.0 版以后可用。&
PHP\_INI\_ALL		\\
\hline
default\_socket\_timeout&	``60"	&基于 socket 的流的默认超时时间(秒)。\newline PHP 4.3.0 版以后可用。&PHP\_INI\_ALL\\
\hline
from				&``"		&定义匿名 ftp 的密码（email 地址）。	&PHP\_INI\_ALL\\
\hline
auto\_detect\_line\_endings&	``0"	&当设为 On 时，PHP 将检查通过 fgets() 和 file() 取得的数据中的行结束符号是符合 Unix，MS-DOS，还是 Macintosh 的习惯。\newline 这使得 PHP 可以和 Macintosh 系统交互操作，但是默认值是 Off，因为在检测第一行的 EOL 习惯时会有很小的性能损失，而且在 Unix 系统下使用回车符号作为项目分隔符的人们会遭遇向下不兼容的行为。\newline PHP 4.3.0 版以后可用。&PHP\_INI\_ALL\\
\hline

\end{longtable}


当在 Unix 平台上规定路径时，正斜杠 (/) 用作目录分隔符。而在 Windows 平台上，正斜杠 (/) 和反斜杠 (\textbackslash) 均可使用。

\begin{longtable}{|m{120pt}|m{250pt}|m{20pt}|}
%head
\multicolumn{3}{r}{}
\tabularnewline\hline
函数	&描述	&PHP
\endhead
%endhead

%firsthead
\caption{PHP Filesystem 函数}\\
\hline
函数	&描述	&PHP
\endfirsthead
%endfirsthead

%foot
\multicolumn{3}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot

\hline
basename()	&返回路径中的文件名部分。	&3\\
\hline
chgrp()		&改变文件组。	&3\\
\hline
chmod()		&改变文件模式。&	3\\
\hline
chown()		&改变文件所有者。&	3\\
\hline
clearstatcache()	&清除文件状态缓存。&	3\\
\hline
copy()		&复制文件。	&3\\
\hline
delete()		&参见 unlink() 或 unset()。&	 \\
\hline
dirname()	&返回路径中的目录名称部分。	&3\\
\hline
disk\_free\_space()	&返回目录的可用空间。	&4\\
\hline
disk\_total\_space()&	返回一个目录的磁盘总容量。&	4\\
\hline
diskfreespace()	&disk\_free\_space() 的别名。	&3\\
\hline
fclose()	&关闭打开的文件。	&3\\
\hline
feof()	&测试文件指针是否到了文件结束的位置。	&3\\
\hline
fflush()	&向打开的文件输出缓冲内容。	&4\\
\hline
fgetc()	&从打开的文件中返回字符。	&3\\
\hline
fgetcsv()	&从打开的文件中解析一行，校验 CSV 字段。	&3\\
\hline
fgets()	&从打开的文件中返回一行。	&3\\
\hline
fgetss()	&从打开的文件中读取一行并过滤掉 HTML 和 PHP 标记。	&3\\
\hline
file()	&把文件读入一个数组中。	&3\\
\hline
file\_exists()&	检查文件或目录是否存在。	&3\\
\hline
file\_get\_contents()	&将文件读入字符串。	&4\\
\hline
file\_put\_contents()&将字符串写入文件。	&5\\
\hline
fileatime()	&返回文件的上次访问时间。	&3\\
\hline
filectime()	&返回文件的上次改变时间。	&3\\
\hline
filegroup()	&返回文件的组 ID。	&3\\
\hline
fileinode()	&返回文件的 inode 编号。	&3\\
\hline
filemtime()	&返回文件的上次修改时间。	&3\\
\hline
fileowner()	&文件的 user ID （所有者）。&	3\\
\hline
fileperms()	&返回文件的权限。	&3\\
\hline
filesize()	&返回文件大小。	&3\\
\hline
filetype()	&返回文件类型。	&3\\
\hline
flock()	&锁定或释放文件。	&3\\
\hline
fnmatch()	&根据指定的模式来匹配文件名或字符串。	&4\\
\hline
fopen()	&打开一个文件或 URL。	&3\\
\hline
fpassthru()&	从打开的文件中读数据，直到 EOF，并向输出缓冲写结果。	&3\\
\hline
fputcsv()	&将行格式化为 CSV 并写入一个打开的文件中。	&5\\
\hline
fputs()	&fwrite() 的别名。	&3\\
\hline
fread()	&读取打开的文件。	&3\\
\hline
fscanf()	&根据指定的格式对输入进行解析。	&4\\
\hline
fseek()	&在打开的文件中定位。	&3\\
\hline
fstat()	&返回关于一个打开的文件的信息。	&4\\
\hline
ftell()	&返回文件指针的读/写位置	&3\\
\hline
ftruncate()	&将文件截断到指定的长度。&	4\\
\hline
fwrite()	&写入文件。	&3\\
\hline
glob()	&返回一个包含匹配指定模式的文件名/目录的数组。	&4\\
\hline
is\_dir()	&判断指定的文件名是否是一个目录。	&3\\
\hline
is\_executable()	&判断文件是否可执行。	&3\\
\hline
is\_file()	&判断指定文件是否为常规的文件。&	3\\
\hline
is\_link()	&判断指定的文件是否是连接。&	3\\
\hline
is\_readable()	&判断文件是否可读。	&3\\
\hline
is\_uploaded\_file()	&判断文件是否是通过 HTTP POST 上传的。	&3\\
\hline
is\_writable()	&判断文件是否可写。	&4\\
\hline
is\_writeable()	&is\_writable() 的别名。	&3\\
\hline
link()	&创建一个硬连接。	&3\\
\hline
linkinfo()	&返回有关一个硬连接的信息。	&3\\
\hline
lstat()	&返回关于文件或符号连接的信息。	&3\\
\hline
mkdir()	&创建目录。	&3\\
\hline
move\_uploaded\_file()	&将上传的文件移动到新位置。	&4\\
\hline
parse\_ini\_file()	&解析一个配置文件。	&4\\
\hline
pathinfo()	&返回关于文件路径的信息。	&4\\
\hline
pclose()	&关闭有 popen() 打开的进程。	&3\\
\hline
popen()	&打开一个进程。	&3\\
\hline
readfile()	&读取一个文件，并输出到输出缓冲。	&3\\
\hline
readlink()	&返回符号连接的目标。	&3\\
\hline
realpath()	&返回绝对路径名。	&4\\
\hline
rename()	&重名名文件或目录。	&3\\
\hline
rewind()	&倒回文件指针的位置。	&3\\
\hline
rmdir()	&删除空的目录。	&3\\
\hline
set\_file\_buffer()	&设置已打开文件的缓冲大小。	&3\\
\hline
stat()	&返回关于文件的信息。	&3\\
\hline
symlink()	&创建符号连接。	&3\\
\hline
tempnam()	&创建唯一的临时文件。&	3\\
\hline
tmpfile()	&建立临时文件。	&3\\
\hline
touch()	&设置文件的访问和修改时间。	&3\\
\hline
umask()	&改变文件的文件权限。	&3\\
\hline
unlink()	&删除文件。	&3\\
\hline
\end{longtable}


\section{PHP Filesystem Constants}


\begin{longtable}{|m{125pt}|m{245pt}|m{20pt}|}
%head
\multicolumn{3}{r}{}
\tabularnewline\hline
常量	&描述	&PHP
\endhead
%endhead

%firsthead
\caption{PHP Filesystem 常量}\\
\hline
常量	&描述	&PHP
\endfirsthead
%endfirsthead

%foot
\multicolumn{3}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot

\hline
GLOB\_BRACE	 	 &&\\
\hline
GLOB\_ONLYDIR	 &	 &\\
\hline
GLOB\_MARK	 	 &&\\
\hline
GLOB\_NOSORT	 &	 &\\
\hline
GLOB\_NOCHECK	 &	 &\\
\hline
GLOB\_NOESCAPE	 &	 &\\
\hline
PATHINFO\_DIRNAME&	 	 &\\
\hline
PATHINFO\_BASENAME&	 &\\
\hline	 
PATHINFO\_EXTENSION&	 &\\
\hline	 
FILE\_USE\_INCLUDE\_PATH&&	 	 \\
\hline
FILE\_APPEND	 	 &&\\
\hline
FILE\_IGNORE\_NEW\_LINES&	 	& \\
\hline
FILE\_SKIP\_EMPTY\_LINES	&& 	 \\
\hline
\end{longtable}



\chapter{PHP Cookie}

cookie 是服务器存储在用户计算机中的小文件，cookie用来识别用户。每当相同的计算机通过浏览器请求页面时，它同时会发送这个 cookie，通过 PHP能够创建并取回 cookie 的值。



\section{setcookie()}


setcookie() 函数用于设置 cookie。使用时，setcookie() 函数必须位于 <html> 标签之前。


\begin{lstlisting}[language=PHP]
setcookie(name, value, expire, path, domain);
\end{lstlisting}


在下面的例子中，我们将创建名为 "user" 的 cookie，把为它赋值 "Alex Porter"，同时也规定了此 cookie 在一小时后过期：

\begin{lstlisting}[language=HTML]
<?php 
setcookie("user", "Alex Porter", time()+3600);
?>
<!DOCTYPE html>
<html>
<body>

</body>
</html>
\end{lstlisting}

在发送 cookie 时，cookie 的值会自动进行 URL 编码，在取回时进行自动解码（为防止 URL 编码，要使用 setrawcookie() 取而代之）。


\section{PHP \$\_COOKIE}


PHP 的 \texttt{\$\_COOKIE}变量用于取回 cookie 的值。在下面的例子中取回了名为 "user" 的 cookie 的值，并把它显示在了页面上：

\begin{lstlisting}[language=PHP]
<?php
// Print a cookie
echo $_COOKIE["user"];

// A way to view all cookies
print_r($_COOKIE);
?>
\end{lstlisting}


使用 isset() 函数来确认是否已设置了 cookie，示例如下：


\begin{lstlisting}[language=HTML]
<!DOCTYPE html>
<html>
<body>

<?php
if (isset($_COOKIE["user"]))
  echo "Welcome " . $_COOKIE["user"] . "!<br />";
else
  echo "Welcome guest!<br />";
?>

</body>
</html>
\end{lstlisting}



当删除 cookie 时，应当使过期日期变更为过去的时间点。


\begin{lstlisting}[language=PHP]
<?php 
// set the expiration date to one hour ago
setcookie("user", "", time()-3600);
?>
\end{lstlisting}

如果应用程序涉及不支持 cookie 的浏览器，那么开发者就不得不采取其他方法在应用程序中从一张页面向另一张页面传递信息。一种方式是从表单传递数据，下面的表单在用户单击提交按钮时向 "welcome.php" 提交了用户输入：


\begin{lstlisting}[language=PHP]
<!DOCTYPE html>
<html>
<head>
  <title>PHP Example</title>
</head>
<body>

<form action="welcome.php" method="post">
Name: <input type="text" name="name" />
Age: <input type="text" name="age" />
<input type="submit" />
</form>

</body>
</html>
\end{lstlisting}





\chapter{PHP Session}

当我们在本地运行一个应用程序时，可能会打开它，做些更改，然后关闭它，这个过程很像一次会话，而且在这个过程中计算机清楚当前用户是谁，而且它知道我们何时启动应用程序，并在何时终止。但是在因特网上存在一个问题：服务器不知道当前用户是谁以及用户做什么，这是由于 HTTP 地址不能维持状态（stateless）。

PHP Session解决了这个问题，Session指的是一个用户在一段时间内对某一个站点的一次访问。通过在服务器上存储用户信息（比如用户名称、购买商品等）来供随后使用。不过，会话信息是临时的，在用户离开网站后将被删除。如果需要永久储存信息，可以把数据存储在数据库中。

Session即会话，Session可以保存变量，该变量只能供一个用户使用，也就是说，每一个网页浏览者都有自己的Session对象变量，即Session对象具有唯一性，因此对于一个Web应用程序而言，所有用户访问到的Application对象的内容是完全一样的，但是不同用户会话访问到的Session对象的内容却各不相同，而且存储于Session 对象中的变量持有单一用户的信息，并且对于一个应用程序中的所有页面都是可用的。




PHP为每位用户创建一个唯一的 cookie，cookie 被传送至客户端，它含有可识别用户的信息，这种接口被称作 Session 对象。PHP Session\footnote{Session对象在.NET中对应HttpSessionState类，表示“会话状态”，可以保存与当前用户会话相关的信息。}变量用于存储有关用户会话的信息，或更改用户会话的设置。Session变量保存的信息是单一用户的，并且可供应用程序中的所有页面使用。







Session的工作机制是为每个访问者创建一个唯一的 id (UID)，并基于这个 UID 来存储变量。UID 存储在 cookie 中，亦或通过 URL 进行传导，因此用户在应用程序的页面切换时，Session对象的变量不会被清除。这样，Session就可以存储从一个用户开始访问某个特定的PHP页面起，到用户离开为止，特定的用户会话相关的信息。 

存储于 Session 对象中的信息通常是 name、id 以及参数。服务器会为每个新的用户创建一个新的 Session，并在 Session 到期时撤销掉这个 Session 对象。

Session 开始于：

\begin{compactitem}
\item 当某个新用户请求了一个 PHP 文件，并且PHP文件中引用了\texttt{sesstion\_start()}函数时；
\item 当某个值存储在 Session 变量中时；
\end{compactitem}

使用 session 时主要的问题是它们该在何时结束。我们不会知道用户最近的请求是否是最后的请求。因此我们不清楚该让 session“ 存活”多久。为某个空闲的 session 等待太久会耗尽服务器的资源。然而假如 session 被过早地删除，那么用户就不得不一遍又一遍地重新开始，这是因为服务器已经删除了所有的信息。寻找合适的超时间隔时间是很困难的，因此如果正在使用 session 变量，尽量不要在其中存储大量的数据。


\section{PHP Session Lifecycle}


One of the most vast misconceptions in the PHP world is how sessions really do work\cite{php_session_lifecycle}. I'm fairly confident most of us know how to start sessions, terminate sessions, regenerate session IDs and easily pass data from 1 page to another. But do you really know how they work inside out?

Storing crucial information in a session is what sessions are all about. They strive on being able to provide the information without leaving it open to tampering or interception. Giving a session some important information is like giving a Jack Russell a bone - it's not letting go of it anytime soon and if any other sod tries to take the bone.

Anything can be unsafe in PHP if the programming is not up to par. Generally speaking, however, sessions are 1 section of the PHP language that is difficult to mess up.

Sessions are conveniently stored server-side. There is no exception to this rule. Many people become confused because sessions use cookies, and cookies, rightfully so, are stored client-side. Sessions, however, are not cookies in the truest form. Cookies are just 1 of the methods of delivering the unique session ID to retrieve the session data.

Remember the times when you used to crack open the cereal boxes to retrieve the free plastic toy from inside? Well, sessions are not quite as exciting as that. In fact, sessions are pretty uneventful on the inside.

\begin{lstlisting}[language=PHP]
<?php
  session_start();
  $_SESSION['myWebsite'] = 'http://www.theqiong.com/';
  $_SESSION['mySessionId'] = session_id();
?>
\end{lstlisting}

Request Header:

\begin{lstlisting}[language=bash]
GET /test.php HTTP/1.1
Host: localhost
Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.57 Safari/537.36
Accept-Encoding: gzip,deflate,sdch
Accept-Language: en-US,en;q=0.8,ja;q=0.6,zh-CN;q=0.4,zh-TW;q=0.2
\end{lstlisting}

Request Header:

\begin{lstlisting}[language=bash]
HTTP/1.1 200 OK
Date: Thu, 28 Nov 2013 14:13:31 GMT
Server: Apache/2.4.6 (Fedora) PHP/5.5.5 SVN/1.7.13
X-Powered-By: PHP/5.5.5
Set-Cookie: PHPSESSID=h589n8vacg3jlrjm82ia11mff3; path=/
Expires: Thu, 19 Nov 1981 08:52:00 GMT
Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0
Pragma: no-cache
Content-Length: 0
Keep-Alive: timeout=5, max=100
Connection: Keep-Alive
Content-Type: text/html; charset=UTF-8
\end{lstlisting}

As simple as it may be, it does the job. It creates us a session file which contains our session information. The file is stored as the following filename which is made up of 2 parts: it has prefixed us the word sess\_ which is then followed by our unique session ID.

\verb|sess_h589n8vacg3jlrjm82ia11mff3|

If you open up this file it contains the following information which is simply my array which has been serialized (see \href{http://www.php.net/serialize}{serialize} for further information) and stored.

\verb|myWebsite|s:24:"http://www.theqiong.com/";myId|s:26:"h589n8vacg3jlrjm82ia11mff3";|

This is nothing more than my array broken down into a string. When I execute my file again the session ID will be used to retrieve the above data from the relevant session file and unserialized (see \href{http://www.php.net/unserialize}{unserialize} for further information).

That's all there really is to a session file. Remember that the session file is stored server-side so there is absolutely no need to transfer any information you do not publish in the HTML over the insecure medium we like to call the Internet.



\section{session\_start()}


在用户把用户信息存储到 PHP session 中之前，首先必须通过session\_start() 函数启动会话，而且session\_start() 函数必须位于 <html> 标签之前。

\begin{lstlisting}[language=PHP]
<?php session_start(); ?>
<!DOCTYPE html>
<html>
<head>
  <title>PHP Session Example</title>
</head>
<body>

</body>
</html>
\end{lstlisting}

上面的代码会向服务器注册用户的会话，以便可以开始保存用户信息，同时会为用户会话分配一个 UID。一旦值被存入 session 变量，它就能被 PHP 应用程序中的任何页面使用，Session 对象最大的优点是可在其中存储变量，以供后续的网页读取，其应用范围是很广的。



\section{Session ID}


Cookies are the most frequently used due to the extra security they add (not much, but just enough to be the favoured method). The other possible methods are GET (which is sometimes used) and POST.

Unlike GET and POST which can be used in such attacks as \href{http://www.talkphp.com/advanced-php-programming/1063-cross-site-request-forgeries.html}{CSRF} and passed around to potential victims with far too much ease, cookies are just that little more difficult to install on a victim's computer.

You could quite easily send a link to someone and have him either hijack a session on my behalf, or the most common reason would be to fixate session ID (\href{http://www.talkphp.com/tips-tricks/1024-tips-php-security-post1813.html#post1813}{see the following post for more information about session fixation}).

Well, there is an important setting that is set to 1 by default (and should always be set to 1 unless you wish to also support users who do not have cookies enabled - which is not recommended) that prevents the session IDs from being transferred via a GET and to use only cookies - the safest delivery method. That setting is:

\begin{lstlisting}[language=bash]
session.use_only_cookies
\end{lstlisting}


From the earlier example let's take a look at the cookie that has been created on local computer:

\verb|h589n8vacg3jlrjm82ia11mff3|

The cookie's name is \texttt{PHPSESSID} which is the default name given to a session cookie that is stored client-side. The number you see above is the session ID which will stay with me for the lifetime of my session or until it is regenerated for security purposes.

Upon loading the website where my session ID was created, the cookie is sent to the website and parsed by PHP. The session ID is correctly linked to the session file stored server-side and is then unserialized and placed into the pre-populated PHP array, \texttt{\$\_SESSION}. 

Once issued the \texttt{session\_start()} command to begin session, then we're able to access all the information - even crucial and highly sensitive information, from the \texttt{\$\_SESSION} array.


Although you may store highly insensitive information in sessions, be aware that displaying it on your website will mean that crucial information is being sent over the pipes of the Internet. Without using SSL this would be a very insecure method of delivery which would be crying out to be intercepted by Harry the hacker.




\section{PHP \$\_SESSION}


存储和取回 session 变量的正确方法是使用 PHP \$\_SESSION 变量：


\begin{lstlisting}[language=PHP]
<?php
session_start();
// store session data
$_SESSION['views']=1;
?>
<!DOCTYPE html>
<html>
<head>
  <title>PHP Session Example</title>
</head>
<body>

<?php
//retrieve session data
echo "Pageviews=". $_SESSION['views'];
?>

</body>
</html>
\end{lstlisting}



在下面的例子中，我们创建了一个简单的 page-view 计数器。isset() 函数检测是否已设置 ``views" 变量。如果已设置``views" 变量，我们累加计数器。如果``views" 不存在，则我们创建``views" 变量，并把它设置为 1：

\begin{lstlisting}[language=PHP]
<?php
session_start();

if(isset($_SESSION['views']))
  $_SESSION['views']=$_SESSION['views']+1;

else
  $_SESSION['views']=1;
echo "Views=". $_SESSION['views'];
?>
\end{lstlisting}

\texttt{\$\_SESSION}变量与\texttt{\$\_POST}、\texttt{\$\_GET}变量相比，\texttt{\$\_SESSION}变量要在\texttt{session\_start()}函数执行后才初始化，而后两者是在PHP页面请求时就已经初始化了。


Assume that banking system has absolutely no extra security implemented, and some customer have logged in and been issued a cookie containing their session ID, banking system also erroneously accepts the GET method of delivery though to ensure everybody can use their system. 

Harry decides to go down the route of session fixation and thus sends you the following crafty link:

\verb|http://www.myOnlineBank.com/index.php?sess_id=5aff2|

If you click on it and login. Harry, already knowing your session ID is 5aff2, clicks on the link himself and is able to withdraw your entire life savings of 67 pence.

Nonetheless, the browser name, version, language, etc. are all sent by the end user's browser during the HTTP call. This means that this data may not even be sent at all. It is optional. As long as you know it is optional you can check for if the intended array even exists before using it. This is important because a blank string will always produce the same MD5 or SHA1 (etcetera...) hash. A null string MD5'd will always be d41d8cd98f00b204e9800998ecf8427e no matter how many times you use MD5. Whilst SHA1 will be different to the MD5 string, it will still be the same for every single time you hash the null string using SHA1.

Now that you fully understand the following:

\verb|[Session File] (Server) -> [Cookie File] (Client)|

A session file can simply be opened by anybody who has access to file system. For instance, sessions are stored in the following directory as plain files:

\verb|C:\wamp\www|

Anybody who has access to that directory can read session files and read the session IDs from the filenames. This is why shared hosts can be bad. Typically everybody on a shared hosts shares the same temp folder. This is the most common place where session files are stored. 

Luckily the directory can be moved elsewhere or you can even use a table inside a database to store all your session data. The latter is best saved for another article to keep this 1 short and sweet. The following setting can be changed to alter the destination of session files:

\verb|session.save_path|

\section{unset()}

如果希望删除某些 session 数据，可以使用 unset() 或 session\_destroy() 函数，其中unset() 函数用于释放指定的 session 变量：


\begin{lstlisting}[language=PHP]
<?php
unset($_SESSION['views']);
?>
\end{lstlisting}



\section{session\_distroy()}




通过 session\_destroy() 函数可以彻底终结 session，session\_destroy() 将重置 session，因此将失去所有已存储的 session 数据。


\begin{lstlisting}[language=PHP]
<?php
session_destroy();
?>
\end{lstlisting}














\chapter{PHP Forms}

\vspace{-30pt}

表单是Web应用程序和用户交互时重要的手段，Web设计中常见的表单示例如下：

\begin{lstlisting}[language=HTML]
<!DOCTYPE html>
<html>
<head>
<title>PHP POST Example</title>
</head>
<body>

<form action="welcome.php" method="post">
Name: <input type="text" name="name" />
Age: <input type="text" name="age" />
<input type="submit" />
</form>
</body>
</html>
\end{lstlisting}




上面的 HTML 页面实例包含了两个输入框和一个提交按钮。当用户填写了该表单并单击了提交按钮后，页面 welcome.php 将被调用。表单的数据会被送往 "welcome.php" 这个文件，而``welcome.php" 文件类似这样：

\begin{lstlisting}[language=PHP]
<!DOCTYPE html>
<html>
<head>
<title>Welcome</title>
</head>
<body>

Welcome <?php echo $_POST["name"]; ?>. You are <?php echo $_POST["age"]; ?> years old.
</body>
</html>
\end{lstlisting}

PHP 的 \textcolor{Blue}{\texttt{\$\_GET}} 变量和 \textcolor{Blue}{\texttt{\$\_POST}} 变量用于检索表单中的值，比如用户输入等。

\begin{compactitem}
\item \textcolor{Blue}{\texttt{\$\_GET}} 变量用于收集来自 method=``get" 的表单中的值。
\item \textcolor{Blue}{\texttt{\$\_POST}}变量用于收集来自 method=``post" 的表单中的值。
\end{compactitem}

更严格的PHP脚本如下：

\begin{lstlisting}[language=PHP]
Welcome <?php echo htmlspecialchars($_POST['name']); ?>.<br />
You are <?php echo (int)$_POST["age"]; ?> years old.
\end{lstlisting}


\texttt{htmlspecialchars()} 使得 HTML 之中的特殊字符被正确的编码，从而不会被使用者在页面注入 HTML 标签或者 Javascript 代码。



我们明确知道age字段是一个数值，因此将它转换为一个整形值\texttt{(integer)}来自动的消除任何不必要的字符。也可以使用 PHP 的 \texttt{filter} 扩展来自动完成该工作。

除了 \texttt{htmlspecialchars()} 和 \texttt{(int)} 部分，这段程序做什么用显而易见。

PHP 一个很有用的特点体现在它处理 PHP 表单的方式。当一个表单提交给 PHP 脚本时，表单的任何元素都在 PHP 脚本中自动生效，因此PHP 将自动设置 \texttt{\$\_POST['name']} 和 \texttt{\$\_POST['age']} 变量。在这之前我们使用了超全局变量 \texttt{\$\_SERVER}，现在引入超全局变量是 \texttt{\$\_POST}，它包含了所有的 \texttt{POST} 数据。

如果表单提交数据的方法（method）使用的是 \texttt{GET}方法，那么表单中的信息将被储存到超全局变量 \texttt{\$\_GET} 中。

\begin{compactitem}
\item GET\footnote{对于GET方式，服务器端用Request.QueryString获取变量的值。}

通过HTTP GET机制，把参数数据队列加到提交表单的action属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到，因此GET安全性非常低，建议用POST方式传输机密信息\footnote{具体来说，在做数据查询时，建议用GET方式，而在做数据添加、修改或删除时，建议用POST方式。}。

通过HTTP GET机制传送的数据量较小，不能大于2KB，因此GET执行效率比POST方法好。

\item POST\footnote{对于POST方式，服务器端用Request.Form获取提交的数据。}

通过HTTP POST机制，将表单内各个字段与其内容放置在HTML header内一起传送到action属性所指的URL地址，用户是看不到这个过程的，因此POST安全性较高。

通过HTTP POST机制传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。
\end{compactitem}

也可以在 PHP 中处理 XForms 的输入，尽管用户可能更喜欢使用长久以来支持良好的 HTML 表单。


如果并不关心请求数据的来源，也可以用超全局变量 \texttt{\$\_REQUEST}，它包含了所有 \texttt{GET}、\texttt{POST}、\texttt{COOKIE}和 \texttt{FILE}的数据\footnote{超全局数组例如 \texttt{\$\_POST} 和 \texttt{\$\_GET}，自 PHP 4.1.0 起可用。}。

通常，PHP 不会改变传递给脚本中的变量名，但是应该注意到点（句号）不是 PHP 变量名中的合法字符，因此变量名中的点和空格会被转换成下划线。例如 \texttt{<input name="a.b" />} 变成了 \texttt{\$\_REQUEST["a\_b"]}。

\begin{lstlisting}[language=PHP]
<?php
$varname.ext;  /* 非法变量名 */
?>
\end{lstlisting}

这时，解析器看到是一个名为 \$varname 的变量，后面跟着一个字符串连接运算符，后面跟着一个裸字符串（即没有加引号的字符串，且不匹配任何已知的健名或保留字）\texttt{'ext'}。很明显这不是想要的结果，因此出于此原因，要注意 PHP 将会自动将变量名中的点替换成下划线。

当提交表单时，可以用一幅图像代替标准的提交按钮，用类似这样的标记：
\begin{lstlisting}[language=HTML]
<input type="image" src="image.gif" name="sub" />
\end{lstlisting}

当用户点击到图像中的某处时，相应的表单会被传送到服务器，并加上两个变量 sub\_x 和 sub\_y。它们包含了用户点击图像的坐标。有经验的用户可能会注意到被浏览器发送的实际变量名包含的是一个点而不是下划线（即 sub.x 和 sub.y），但 PHP 自动将点转换成了下划线。




根据特定的设置和个人的喜好，有很多种方法访问 HTML 表单中的数据。例如：

\begin{verbatim}
<?php
// 自 PHP 4.1.0 起可用
   echo $_POST['username'];
   echo $_REQUEST['username'];
   
   import_request_variables('p', 'p_');
   echo $p_username;

// 自 PHP 5.0.0 起，这些长格式的预定义变量
// 可用 register_long_arrays 指令关闭。

   echo $HTTP_POST_VARS['username'];

// 如果 PHP 指令 register_globals = on 时可用。不过自
// PHP 4.2.0 起默认值为 register_globals = off。
// 不提倡使用/依赖此种方法。

   echo $username;
?>
\end{verbatim}

使用 GET 表单也类似，只不过要用适当的 GET 预定义变量。在 PHP 4.2.0 之前 register\_globals 的默认值是 on。PHP 社区不鼓励依赖此指令，建议在编码时假定其为 off。


GET 也适用于 \texttt{QUERY\_STRING}（URL 中在“?”之后的信息）。因此，举例说，http://www.example.com/test.php?id=3 包含有可用 \texttt{\$\_GET['id']} 来访问的 GET 数据。

另外，magic\_quotes\_gpc 配置指令影响到 GET，POST 和 COOKIE 的值。如果打开，值 \texttt{(It's "PHP!")} 会自动转换成 \texttt{(It\textbackslash 's \textbackslash "PHP!\textbackslash ")}。十多年前对数据库的插入需要如此转义，如今已经过时了，应该关闭。


PHP 也懂得表单变量上下文中的数组，例如可以将相关的变量编成组，或者用此特性从多选输入框中取得值。例如，将一个表单 POST 给自己并在提交时显示数据：

\begin{lstlisting}[language=PHP]
<?php
if (isset($_POST['action']) && $_POST['action'] == 'submitted') {
    echo '<pre>';

    print_r($_POST);
    echo '<a href="'. $_SERVER['PHP_SELF'] .'">Please try again</a>';

    echo '</pre>';
} else {
?>
<form action="<?php echo $_SERVER['PHP_SELF']; ?>" method="post">
    Name:  <input type="text" name="personal[name]"><br />
    Email: <input type="text" name="personal[email]"><br />
    Beer: <br>
    <select multiple name="beer[]">
        <option value="warthog">Warthog</option>
        <option value="guinness">Guinness</option>
        <option value="stuttgarter">Stuttgarter Schwabenbr</option>
    </select><br />
    <input type="hidden" name="action" value="submitted" />
    <input type="submit" name="submit" value="submit me!" />
</form>
<?php
}
?>
\end{lstlisting}






应该在任何可能的时候对用户输入进行验证，客户端验证的优势在于速度更快，从而可以减轻服务器的负载。


不过，任何流量很高以至于不得不担心服务器资源的站点，也有必要担心站点的安全性。如果表单访问的是数据库，就非常有必要采用服务器端的验证。

在服务器验证表单的一种好的方式是，把表单传给它自己，而不是跳转到不同的页面。这样用户就可以在同一张表单页面得到错误信息，也就更容易发现错误了。



\chapter{PHP \$\_GET}

\textcolor{Blue}{\texttt{\$\_GET}} 变量是一个数组，内容是由 HTTP GET 方法\footnote{HTTP GET 方法不适合大型的变量值，不能超过 100 个字符。}发送的变量名称和值。


\textcolor{Blue}{\texttt{\$\_GET}} 变量用于收集来自 method="get" 的表单中的值。从带有 GET 方法的表单发送的信息，对任何人都是可见的（会显示在浏览器的地址栏），并且对发送的信息量也有限制（最多 100 个字符）。

\begin{lstlisting}[language=HTML]
<form action="welcome.php" method="get">
Name: <input type="text" name="name" />
Age: <input type="text" name="age" />
<input type="submit" />
</form>
\end{lstlisting}

当用户点击提交按钮时，发送的 URL 会类似这样：

\begin{lstlisting}[language=bash]
http://www.domain.com.cn/welcome.php?name=Jim&age=30
\end{lstlisting}

``welcome.php" 文件通过\textcolor{Blue}{\texttt{\$\_GET}} 变量来获取表单数据时，表单域的名称会自动成为\textcolor{Blue}{\texttt{\$\_GET}}数组中的 ID 键：

\begin{lstlisting}[language=HTML]
Welcome <?php echo $_GET["name"]; ?>.<br />
You are <?php echo $_GET["age"]; ?> years old!
\end{lstlisting}

在使用\textcolor{Blue}{\texttt{\$\_GET}}变量时，所有的变量名和值都会显示在 URL 中。所以在发送密码或其他敏感信息时，不应该使用这个方法。不过，正因为变量显示在 URL 中，因此可以在收藏夹中收藏该页面。在某些情况下，这是很有用的。


\chapter{PHP \$\_POST}

\textcolor{Blue}{\texttt{\$\_POST}}变量是一个数组，内容是由 HTTP POST 方法发送的变量名称和值。



\textcolor{Blue}{\texttt{\$\_POST}}变量用于收集来自 method="post" 的表单中的值。从带有 POST 方法的表单发送的信息，对任何人都是不可见的（不会显示在浏览器的地址栏），并且对发送信息的量也没有限制。

\begin{lstlisting}[language=HTML]
<form action="welcome.php" method="post">
Enter your name: <input type="text" name="name" />
Enter your age: <input type="text" name="age" />
<input type="submit" />
</form>
\end{lstlisting}

当用户点击提交按钮，URL 不会含有任何表单数据，看上去类似这样：


\begin{lstlisting}[language=bash]
http://www.domain.com.cn/welcome.php
\end{lstlisting}

``welcome.php" 文件现在可以通过\textcolor{Blue}{\texttt{\$\_POST}}变量来获取表单数据时，表单域的名称会自动成为\textcolor{Blue}{\texttt{\$\_POST}}数组中的 ID 键。

\begin{lstlisting}[language=HTML]
Welcome <?php echo $_POST["name"]; ?>.<br />
You are <?php echo $_POST["age"]; ?> years old!
\end{lstlisting}


使用\textcolor{Blue}{\texttt{\$\_POST}}，通过 HTTP POST 发送的变量不会显示在 URL 中，而且变量没有长度限制。不过，由于变量不显示在 URL 中，所以无法把页面加入书签。







\chapter{PHP \$\_REQUEST}


PHP 的\textcolor{Blue}{\texttt{\$\_REQUEST}}变量包含了\textcolor{Blue}{\texttt{\$\_GET}}, \textcolor{Blue}{\texttt{\$\_POST}}以及\textcolor{Blue}{\texttt{\$\_COOKIE}}的内容。

PHP 的\textcolor{Blue}{\texttt{\$\_REQUEST}}变量可用来取得通过\textcolor{Blue}{\texttt{GET}}和\textcolor{Blue}{\texttt{POST}}等方法发送的表单数据的结果。



\begin{lstlisting}[language=HTML]
Welcome <?php echo $_REQUEST["name"]; ?>.<br />
You are <?php echo $_REQUEST["age"]; ?> years old!
\end{lstlisting}


\chapter{PHP Image}

除了处理字符串等文本数据之外，PHP也可以使用GD库等来处理图像（例如文字按钮、计数器数字、股票走势图形、数据拼图等静态或动态图形）。

基本的图像文件操作包括对点、线和基本几何图形的实现，以及书写动态文字、使用调色板、填充图形区域等。



PHP在使用图形库来创建图像时，首先在内存中建立图像，然后输出并下载到用户的浏览器中。

\begin{compactenum}
\item 创建画布来开始绘图设计，画布实际上就是在内存中开辟的一块用于存储图像信息的临时区域；
\item 设置图像颜色来开始使用图像处理函数进行具体绘图；
\item 图像绘制完成后转交给Web服务器，并发送（或下载）到浏览器来进行显示；
\item 图像发送完成后就会被及时清理内存中的虚拟“画布”。
\end{compactenum}


\section{Pixel}


像素（pixel）是构成数字图像的最小单位，若干个像素点以矩阵的方式排列后就形成了图像。

\section{Palette}

调色板（palette）是一个包含颜色值的数组，像素的颜色由它们在调色板中的位置确定。

调色板中的每一项都是由3个独立的颜色值（红、绿、蓝）混合而成，它们的范围都可以从0～255.

0代表不显示颜色，255代表颜色的浓度最深，因此每个像素最多可以有16777216（即256x256x256）种可能的颜色。

图像以像素和调色板作为数据，并按照一定的算法存储为文件，因此不同的图像文件格式有不同的存储算法。

通常情况下，GIF、JPEG和PNG等图像文件格式都是压缩的，可以减小文件的体积。

\section{Bit}

颜色也可以理解为由数字（位，Bit）表示的，并且颜色数=$2^n$，其中n就是所占的位数。

\begin{compactitem}
\item 高彩色指16位显示模式，支持65536（64K）种颜色；
\[2^{16}=65536\]
\item 真彩色指24位显示模式，支持1677万（16M）种颜色。
\[2^{24}=16777216\]
\end{compactitem}

\section{Index}


图像指数可以评价图像整体的感观和效果，并通过对比度、亮度、色调和饱和度等参数进行量化表达。

\begin{compactitem}
\item 对比度是画面最亮的部分和最暗的部分的比值，其值越大则明暗对比越强；
\item 亮度是画面总体的明亮程度，其值越大则画面越明亮；
\item 色调是色偏，可以分为冷色调和暖色调等；
\item 饱和度是色调的光度或暗度以及色调的纯度。
\end{compactitem}

饱和度表示图像的彩色深浅度或鲜艳度，取决于彩色种的白色光含量。白色光含量越高，则彩色光含量越低，色彩饱和度就越低。


\section{Transparency}

透明度控制背景是否可以透过图像，以及以多大的恶透明度透过图像。

PNG等支持Alpha通道，这样每一个ie像素都有一个额外的值来表示其透明度，其他图像只是简单地指定调色板中的选项值来指定透明度。







\section{GD}


GD库本身是一个PHP动态链接扩展库，可以使PHP处理GIF、JPEG、PNG、WBMP、XBM等格式的图像文件操作，并且支持额外的字体库（例如FreeType和Type 1字体等）。



在Windows自动捆绑了GD库，但是默认不开启，因此需要在php.ini中通过“extension=php\_gd2.dll”选项来手动打开对GD扩展库的支持。

在UNIX/Linux中需要在编译PHP时使用“\texttt{--with-gd}”选项打开，而且需要安装相关的图片格式和字体。


默认情况下，GD库的功能有限，需要配合其他的函数库进行使用。


\subsection{gd\_info()}


gd\_info()取得当前安装的 GD 库的信息，并返回一个关联数组描述了安装的 GD 库的版本和性能。



\section{Canvas}


\subsection{imageCreate)}


\begin{lstlisting}[language=PHP]

\end{lstlisting}




\begin{lstlisting}[language=PHP]

\end{lstlisting}





\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{imageCreateTrueColor()}








\begin{lstlisting}[language=PHP]

\end{lstlisting}


\section{Color}


\subsection{imageColorAllocate()}



\begin{lstlisting}[language=PHP]

\end{lstlisting}

\section{Image}




PHP可以直接生成GIF、JPEG、PNG和WBMP四种图像格式的文件，也可以从不同的源（例如本地或网络图像文件）新建图像。


在直接输出图像到浏览器之前，需要使用header()发送标头信息来设置正确的MIME文件类型。

\begin{compactitem}
\item Content-type: image/gif
\item Content-type: image/jpeg
\item Content-type: image/png
\item Content-type: image/vnd.wap.wbmp
\end{compactitem}

在保存图像到服务器上时，不需要使用header()发送标头信息。





\subsection{imageGIF()}






\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{imageJPEG()}


\begin{lstlisting}[language=PHP]

\end{lstlisting}

\subsection{imagePNG()}


\begin{lstlisting}[language=PHP]

\end{lstlisting}

\subsection{imageWBMP()}


\begin{lstlisting}[language=PHP]

\end{lstlisting}




\subsection{imageCreateFromGIF()}





\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{imageCreateFromJPEG()}


\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{imageCreateFromPNG()}


\begin{lstlisting}[language=PHP]

\end{lstlisting}



\subsection{imageCreateFromWBMP()}




\begin{lstlisting}[language=PHP]

\end{lstlisting}

\subsection{imageCreateFromString()}



\subsection{imageDestroy()}


\section{Graph}



在使用图形库进行点、线和面的绘制时，图形在画布中的位置通过坐标进行确定。


\begin{compactitem}
\item 坐标原点在画布左上角的起始位置，以像素大小为单位。
\item X轴正方向向右延伸；
\item Y轴正方向向下延伸。
\end{compactitem}

\subsection{imageSetPixel()}


\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{imageLine()}


\begin{lstlisting}[language=PHP]

\end{lstlisting}



\subsection{imageDashedLine()}



\begin{lstlisting}[language=PHP]
<?php
	//创建图像
	$img = imageCreate (300, 200);
	$background = ImageColorAllocate($img, 255, 255, 255);			//背景设为白色
	$black = ImageColorAllocate ($img, 0, 0, 0);		  			//设定黑色
	$white = $background;									//设定白色

	//发送标头信息
	header("Content-type: image/png");

	//绘制矩形
	imageRectangle($img, 30, 30, 180, 120, $black);
	imageRectangle($img, 60, 60, 210, 150, $black);

	//填充颜色
	imageFill ($img, 100, 100,$black);

	//输出文字
	imageString ($img, 5, 75, 81, "Hello, PHP", $white);

	//输出PNG图像
	imagePNG($img);

	//销毁图像
	imageDestroy($img);
?>
\end{lstlisting}







\subsection{imageRectangle()}




\begin{lstlisting}[language=PHP]

\end{lstlisting}



\subsection{imagePolygon()}



\subsection{imageArc()}




\subsection{imageSetThickness()}



\begin{lstlisting}[language=PHP]

\end{lstlisting}




\begin{lstlisting}[language=PHP]
<?php
	//定义PNG图片的高和宽
	$widht =501;
	$height=201;

	//创建图片
	$image=imageCreate($widht, $height);

	//定义颜色
	$colorWhite=imageColorAllocate($image, 255, 255, 255);
	$colorGrey=imageColorAllocate($image, 192, 192, 192);
	$colorBlue=imageColorAllocate($image, 0, 0, 255);
	$colorRed =imageColorAllocate($image, 255, 0, 0);
	
	//创建包围在图片周围的线
	for ($i=0; $i<=30; $i++)
	{
		imageline($image, 0, $i*20, 500, $i*20, $colorGrey);
		imageline($image, $i*20, 0, $i*20, 200, $colorGrey);
	}

	//绘制多边形
	$graphValues=array(1,142,45,190,80,181,120,105,23,13,150,55);
	imagePolygon($image, $graphValues, 6, $colorBlue);

	//绘制弧形
	imageArc($image, 250, 100, 200, 150, 40, 320, $colorRed);

	//绘制圆形
	imageEllipse($image, 400, 100, 179, 179, $colorBlue);

	//设定图形的线宽，并绘制矩形
	imageSetThickness($image, 3);
	imageRectangle($image, 250, 52, 400, 146, $colorRed);

	//输出PNG图形
	header("Content-type: image/png");
	imagePNG($image);

	//销毁资源
	imageDestroy($image);
?>
\end{lstlisting}




\begin{lstlisting}[language=PHP]

\end{lstlisting}



\subsection{getImageSize()}


在对图像文件进行操作之前，可以使用getImageSize()函数获得图片的尺寸等相关信息。




\subsection{imageCopy()}





\subsection{imageCopyMerge()}



\subsection{imageCopyMergeGray()}



\subsection{imageCopyResampled()}




\subsection{imageCopyResized()}


\subsection{imageRotate()}







\section{Fill}



\subsection{imageFill()}




\subsection{imageFillToBorder()}



\subsection{imageFilledRectangle()}





\subsection{imageFilledPolygon()}




\subsection{imageFilledArc()}



\subsection{imageFilledEllipse()}



\section{String}





\subsection{imageString()}


\begin{lstlisting}[language=PHP]

\end{lstlisting}

\subsection{imageStringUp()}


\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{imageChar()}


\begin{lstlisting}[language=PHP]

\end{lstlisting}


\subsection{imageCharUp()}


\begin{lstlisting}[language=PHP]

\end{lstlisting}

\subsection{imageLoadFont()}


除了使用内置的字体之外，PHP还可以使用imageLoadFont()函数加载用户自定义字体文件，并返回对应字体的标识符。

字体文件的格式是二进制的，并且和平台有关，因此不同类型的CPU的机器生成的字体是不同的。

\subsection{imageTtfText()}


TrueType是一种可以缩放的，与设备无关的字体，并且可以按轮廓存储TrueType字体，因此它们可以任意调整高度，打印TrueType字体时可以与屏幕上显示的完全相同。


\subsection{imageTtfbBox()}




\begin{lstlisting}[language=PHP]

\end{lstlisting}



\section{Filter}


PHP提供的图像过滤器函数可以对图形进行修饰，这些内置的过滤器类似于Photoshop中的“滤镜”功能。


\subsection{imageFilter()}



\begin{lstlisting}[language=PHP]

\end{lstlisting}

下面的说明如何对图像进行灰度处理。


\begin{lstlisting}[language=PHP]
<?php
	//打开图像
	$im = imageCreateFromPNG('dave.png');

	if ($im && imageFilter($im, IMG_FILTER_GRAYSCALE)) 
	{
    		echo '灰度处理成功！';
	    imagePNG($im, 'dave.png');
	} else {
    		echo '灰度处理失败！';
	}

	//消除内存图像
	imageDestroy($im);
?>
\end{lstlisting}


下面的说明如何对图像进行模糊处理。



\begin{lstlisting}[language=PHP]
<?php
	//打开图像
	$im = imageCreateFromPNG('sean.png');

	if ($im && imageFilter($im, IMG_FILTER_GAUSSIAN_BLUR)) 
	{
	    echo '亮度改变成功！';
	    imagePNG($im, 'sean.png');
	}else{
	    echo '亮度改变失败！';
	}

	//消除内存图像
	imageDestroy($im);
?>
\end{lstlisting}





\begin{lstlisting}[language=PHP]

\end{lstlisting}





\begin{lstlisting}[language=PHP]

\end{lstlisting}




\begin{lstlisting}[language=PHP]

\end{lstlisting}




\begin{lstlisting}[language=PHP]

\end{lstlisting}




\begin{lstlisting}[language=PHP]

\end{lstlisting}




\begin{lstlisting}[language=PHP]

\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}




\begin{lstlisting}[language=PHP]

\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}




\begin{lstlisting}[language=PHP]

\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}



\begin{lstlisting}[language=PHP]

\end{lstlisting}




\begin{lstlisting}[language=PHP]

\end{lstlisting}






\begin{lstlisting}[language=PHP]

\end{lstlisting}





\begin{lstlisting}[language=PHP]

\end{lstlisting}









\chapter{PHP Mail}





绝大多数邮件服务器都支持SMTP、POP3和IMAP协议，PHP可以基于邮件协议来实现邮件的收取、发送等服务。




\section{mail()}


PHP 允许从脚本直接发送电子邮件，基本语法如下：

\begin{lstlisting}[language=PHP]
mail(to,subject,message,headers,parameters)
\end{lstlisting}




通过 PHP 发送电子邮件的最简单的方式是发送一封文本 email。在下面的例子中，我们首先声明变量(\$to, \$subject, \$message, \$from, \$headers)，然后我们在 mail() 函数中使用这些变量来发送了一封E-mail：

\begin{lstlisting}[language=PHP]
<?php

$to = "someone@example.com";
$subject = "Test mail";
$message = "Hello! This is a simple email message.";
$from = "someonelse@example.com";
$headers = "From: $from";
mail($to,$subject,$message,$headers);
echo "Mail Sent.";

?>
\end{lstlisting}


\begin{longtable}{|m{60pt}|m{45pt}|m{190pt}|m{80pt}|}
%head
\multicolumn{4}{r}{}
\tabularnewline\hline
名称	&默认	&描述	&可改变
\endhead
%endhead

%firsthead
\caption{PHP Mail 配置选项}\\
\hline
名称	&默认	&描述	&可改变
\endfirsthead
%endfirsthead

%foot
\multicolumn{4}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot

\hline
SMTP			&``localhost"	&Windows 专用：SMTP 服务器的 DNS 名称或 IP 地址。	&PHP\_INI\_ALL\\
\hline
smtp\_port		&``25"			&Windows 专用：SMTP 段口号。自 PHP 4.3 起可用。&PHP\_INI\_ALL\\
\hline
sendmail\_from	&NULL			&Windows 专用：规定从 PHP 发送的邮件中使用的 "from" 地址。&PHP\_INI\_ALL\\
\hline
sendmail\_path	&	NULL		&Unix 系统专用：规定sendmail 程序的路径（通常 /usr/sbin/sendmail 或 /usr/lib/sendmail）	&PHP\_INI\_SYSTEM\\
\hline
\end{longtable}


\section{PHP Mail Functions}

邮件函数是 PHP 核心的组成部分，无需安装即可使用这些函数。

\begin{longtable}{|m{120pt}|m{250pt}|m{20pt}|}
%head
\multicolumn{3}{r}{}
\tabularnewline\hline
函数	&描述	&PHP
\endhead
%endhead

%firsthead
\caption{PHP Mail 函数}\\
\hline
函数	&描述	&PHP
\endfirsthead
%endfirsthead

%foot
\multicolumn{3}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot

\hline
ezmlm\_hash()	&计算 EZMLM 邮件列表系统所需的散列值。	&3\\
\hline
mail()			&允许从脚本中直接发送电子邮件。	&3\\
\hline
\end{longtable}

PHP 需要一个已安装且正在运行的邮件系统，以便使邮件函数可用。所用的程序通过在 php.ini 文件中的配置设置进行定义，也就是说，邮件函数的行为受 php.ini 的影响。





\begin{longtable}{|m{100pt}|m{280pt}|}
%head
\multicolumn{2}{r}{}
\tabularnewline\hline
参数	&描述
\endhead
%endhead

%firsthead
\caption{PHP mail() 函数参数}\\
\hline
参数	&描述
\endfirsthead
%endfirsthead

%foot
\multicolumn{2}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot
\hline
to			&必需。规定 email 接收者。\\
\hline
subject\footnote{注释：该参数不能包含任何新行字符。}		&必需。规定 email 的主题。\\
\hline
message	&必需。定义要发送的消息。应使用 LF ({\textbackslash}n) 来分隔各行。\\
\hline
headers		&可选。规定附加的标题，比如 From、Cc 以及 Bcc。
			\newline 应当使用 CRLF ({\textbackslash}r{\textbackslash}n) 分隔附加的标题。\\
\hline
parameters	&可选。对邮件发送程序规定额外的参数。\\
\hline
\end{longtable}
















\section{PHP Mail Form}


通过PHP可以在自己的站点制作一个反馈表单。下面的例子向指定的 e-mail 地址发送了一条文本消息：

\begin{lstlisting}[language=PHP]
<!DOCTYPE html>
<html>
<body>

<?php
if (isset($_REQUEST['email']))
//if "email" is filled out, send email
  {
  //send email
  $email = $_REQUEST['email'] ; 
  $subject = $_REQUEST['subject'] ;
  $message = $_REQUEST['message'] ;
  mail( "someone@example.com", "Subject: $subject",
  $message, "From: $email" );
  echo "Thank you for using our mail form";
  }
else
//if "email" is not filled out, display the form
  {
  echo "<form method='post' action='mailform.php'>
  Email: <input name='email' type='text' /><br />
  Subject: <input name='subject' type='text' /><br />
  Message:<br />
  <textarea name='message' rows='15' cols='40'>
  </textarea><br />
  <input type='submit' />
  </form>";
  }
?>

</body>
</html>
\end{lstlisting}


\begin{compactenum}
\item 首先，检查是否填写了邮件输入框
\item 如果未填写（比如在页面被首次访问时），输出 HTML 表单
\item 如果已填写（在表单被填写后），从表单发送邮件
\item 当点击提交按钮后，重新载入页面，显示邮件发送成功的消息
\end{compactenum}




\section{PHP Mail Injection}

在上述PHP e-mail 脚本中，存在着一个漏洞，导致未经授权的用户可通过输入表单在邮件头部插入数据。

假如用户在表单中的输入框内加入这些文本，会出现什么情况呢？

\begin{lstlisting}[language=PHP]
someone@example.com%0ACc:person2@example.com
%0ABcc:person3@example.com,person3@example.com,
anotherperson4@example.com,person5@example.com
%0ABTo:person6@example.com
\end{lstlisting}

与往常一样，mail() 函数把上面的文本放入邮件头部，那么现在头部有了额外的 Cc:, Bcc: 以及 To: 字段。当用户点击提交按钮时，这封 e-mail 会被发送到上面所有的地址！


\section{PHP Mail Validation}


防止 e-mail 注入的最好方法是对输入进行验证。


下面的代码与上一节类似，不过已经增加了检测表单中 email 字段的输入验证程序：

\begin{lstlisting}[language=PHP]
<!DCOTYPE html>
<html>
<body>
<?php
function spamcheck($field)
  {
  //filter_var() sanitizes the e-mail 
  //address using FILTER_SANITIZE_EMAIL
  $field=filter_var($field, FILTER_SANITIZE_EMAIL);
  
  //filter_var() validates the e-mail
  //address using FILTER_VALIDATE_EMAIL
  if(filter_var($field, FILTER_VALIDATE_EMAIL))
    {
    return TRUE;
    }
  else
    {
    return FALSE;
    }
  }

if (isset($_REQUEST['email']))
  {//if "email" is filled out, proceed

  //check if the email address is invalid
  $mailcheck = spamcheck($_REQUEST['email']);
  if ($mailcheck==FALSE)
    {
    echo "Invalid input";
    }
  else
    {//send email
    $email = $_REQUEST['email'] ; 
    $subject = $_REQUEST['subject'] ;
    $message = $_REQUEST['message'] ;
    mail("someone@example.com", "Subject: $subject",
    $message, "From: $email" );
    echo "Thank you for using our mail form";
    }
  }
else
  {//if "email" is not filled out, display the form
  echo "<form method='post' action='mailform.php'>
  Email: <input name='email' type='text' /><br />
  Subject: <input name='subject' type='text' /><br />
  Message:<br />
  <textarea name='message' rows='15' cols='40'>
  </textarea><br />
  <input type='submit' />
  </form>";
  }
?>

</body>
</html>
\end{lstlisting}

在上面的代码中，我们使用了 PHP 过滤器来对输入进行验证：

\begin{compactitem}
\item FILTER\_SANITIZE\_EMAIL 从字符串中删除电子邮件的非法字符
\item FILTER\_VALIDATE\_EMAIL 验证电子邮件地址
\end{compactitem}





\chapter{PHP Filter}



几乎所有Web应用程序都依赖外部的输入，这些外部数据通常来自用户或其他应用程序（比如Web服务等），通常包括：

\begin{compactitem}
\item 来自表单的输入数据
\item Cookies
\item 服务器变量
\item 数据库查询结果
\end{compactitem}








PHP 过滤器可以用于验证和过滤来自非安全来源的数据，比如用户的输入。设计PHP的过滤器扩展的目的是使数据过滤更轻松快捷。

如需过滤变量，可以使用下面的过滤器函数之一：

\begin{compactitem}
\item filter\_var() - 通过一个指定的过滤器来过滤单一的变量
\item filter\_var\_array() - 通过相同的或不同的过滤器来过滤多个变量
\item filter\_input - 获取一个输入变量，并对它进行过滤
\item filter\_input\_array - 获取多个输入变量，并通过相同的或不同的过滤器对它们进行过滤
\end{compactitem}


在下面的例子中，我们用 filter\_var() 函数验证了一个整数：

\begin{lstlisting}[language=PHP]
<?php
$int = 123;

if(!filter_var($int, FILTER_VALIDATE_INT))
 {
 echo("Integer is not valid");
 }
else
 {
 echo("Integer is valid");
 }
?>
\end{lstlisting}

上面的代码使用了FILTER\_VALIDATE\_INT过滤器来过滤变量。由于这个整数是合法的，因此代码的输出是：Integer is valid。假如尝试使用一个非整数的变量，则输出是：Integer is not valid。


\section{PHP Filter Functions}


filter 函数是 PHP 核心的组成部分，无需安装即可使用这些函数。


\begin{longtable}{|m{120pt}|m{250pt}|m{20pt}|}
%head
\multicolumn{3}{r}{}
\tabularnewline\hline
函数	&描述	&PHP
\endhead
%endhead

%firsthead
\caption{PHP Filter 函数}\\
\hline
函数	&描述	&PHP
\endfirsthead
%endfirsthead

%foot
\multicolumn{3}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot

\hline
filter\_has\_var()	&检查是否存在指定输入类型的变量。	&5\\
\hline
filter\_id()			&返回指定过滤器的 ID 号。	&5\\
\hline
filter\_input()		&从脚本外部获取输入，并进行过滤。	&5\\
\hline
filter\_input\_array()&从脚本外部获取多项输入，并进行过滤。	&5\\
\hline
filter\_list()			&返回包含所有得到支持的过滤器的一个数组。	&5\\
\hline
filter\_var\_array()	&获取多项变量，并进行过滤。	&5\\
\hline
filter\_var()			&获取一个变量，并进行过滤。	&5\\
\hline
\end{longtable}


\section{Validating and Sanitizing}

有两种过滤器：

\begin{compactitem}
\item Validating 过滤器：

\begin{compactitem}
\item 用于验证用户输入
\item 严格的格式规则（比如 URL 或 E-Mail 验证）
\item 如果成功则返回预期的类型，如果失败则返回 FALSE
\end{compactitem}

\item Sanitizing 过滤器：

\begin{compactitem}
\item 用于允许或禁止字符串中指定的字符
\item 无数据格式规则
\item 始终返回字符串
\end{compactitem}


\end{compactitem}


\section{Options and Flags}


选项和标志用于向指定的过滤器添加额外的过滤选项。不同的过滤器有不同的选项和标志。


在下面的例子中，我们用 filter\_var() 和``min\_range" 以及``max\_range" 选项验证了一个整数：

\begin{lstlisting}[language=PHP]
<?php
$var=300;

$int_options = array(
"options"=>array
 (
 "min_range"=>0,
 "max_range"=>256
 )
);

if(!filter_var($var, FILTER_VALIDATE_INT, $int_options))
 {
 echo("Integer is not valid");
 }
else
 {
 echo("Integer is valid");
 }
?>
\end{lstlisting}

就像上面的代码一样，选项必须放入一个名为``options" 的相关数组中。如果使用标志，则不需在数组内。这里，由于整数是 "300"，它不在指定的范围内，以上代码的输出将是``Integer is not valid"。






\begin{longtable}{|m{170pt}|m{220pt}|}
%head
\multicolumn{2}{r}{}
\tabularnewline\hline
ID 名称	&描述
\endhead
%endhead

%firsthead
\caption{PHP Filters}\\
\hline
ID 名称	&描述
\endfirsthead
%endfirsthead

%foot
\multicolumn{2}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot
\hline

FILTER\_CALLBACK				&调用用户自定义函数来过滤数据。\\
\hline
FILTER\_SANITIZE\_STRING		&去除标签，去除或编码特殊字符。\\
\hline
FILTER\_SANITIZE\_STRIPPED	&``string" 过滤器的别名。\\
\hline
FILTER\_SANITIZE\_ENCODED	&URL-encode 字符串，去除或编码特殊字符。\\
\hline
FILTER\_SANITIZE\_SPECIAL\_CHARS&HTML 转义字符\verb|'"<>&|以及ASCII值小于32的字符。\\
\hline
FILTER\_SANITIZE\_EMAIL		&删除所有字符，除了字母、数字以及\newline \verb|!#$%&'*+-/=?^_`{||\verb|}~@.[]| 
\\
\hline
FILTER\_SANITIZE\_URL			&删除所有字符，除了字母、数字以及
\newline \verb|$-_.+!*'(),{}||\verb|\\^~[]`<>#%";/?:@\&=|
\\
\hline
FILTER\_SANITIZE\_NUMBER\_INT&删除所有字符，除了数字和 \verb|+-|\\
\hline
FILTER\_SANITIZE\_NUMBER\_FLOAT&删除所有字符，除了数字、\verb|+-| 以及 .,eE。\\
\hline
FILTER\_SANITIZE\_MAGIC\_QUOTES&应用 addslashes()。\\
\hline
FILTER\_UNSAFE\_RAW			&不进行任何过滤，去除或编码特殊字符。\\
\hline
FILTER\_VALIDATE\_INT			&在指定的范围以整数验证值。\\
\hline
FILTER\_VALIDATE\_BOOLEAN	&如果是``1", ``true", ``on" 以及``yes"，则返回 true，如果是``0", ``false", ``off",``no" 以及``"，则返回 false。否则返回 NULL。\\
\hline
FILTER\_VALIDATE\_FLOAT		&以浮点数验证值。\\
\hline
FILTER\_VALIDATE\_REGEXP		&根据 regexp，兼容 Perl 的正则表达式来验证值。\\
\hline
FILTER\_VALIDATE\_URL			&把值作为 URL 来验证。\\
\hline
FILTER\_VALIDATE\_EMAIL		&把值作为 e-mail 来验证。\\
\hline
FILTER\_VALIDATE\_IP			&把值作为 IP 地址来验证。\\
\hline
\end{longtable}


\section{Validate Input}


验证和过滤用户输入或自定义数据是任何 Web 应用程序的重要组成部分，其中输入过滤是最重要的应用程序安全课题之一。




通过使用过滤器，能够确保应用程序获得正确的输入类型，而且应该始终对外部数据进行过滤。

在下面的验证来自表单的输入的示例中，输入变量``email" 被传到 PHP 页面，我们需要作的第一件事情是确认是否存在我们正在查找的输入数据，然后我们用 filter\_input() 函数过滤输入的数据。


\begin{lstlisting}[language=PHP]
<?php
if(!filter_has_var(INPUT_GET, "email"))
 {
 echo("Input type does not exist");
 }
else
 {
 if (!filter_input(INPUT_GET, "email", FILTER_VALIDATE_EMAIL))
  {
  echo "E-Mail is not valid";
  }
 else
  {
  echo "E-Mail is valid";
  }
 }
?>
\end{lstlisting}

上面的例子有一个通过 "GET" 方法传送的输入变量 (email)：

\begin{compactenum}
\item 检测是否存在``GET" 类型的 "email" 输入变量
\item 如果存在输入变量，检测它是否是有效的邮件地址
\end{compactenum}


\section{Sanitize Input}


在下面的清理从表单传来的URL的例子中，输入变量``url" 被传到 PHP 页面，接下来，我们首先要确认是否存在我们正在查找的输入数据，然后用 filter\_input() 函数来净化输入数据。

\begin{lstlisting}[language=PHP]
<?php
if(!filter_has_var(INPUT_POST, "url"))
 {
 echo("Input type does not exist");
 }
else
 {
 $url = filter_input(INPUT_POST, "url", FILTER_SANITIZE_URL);
 }
?>
\end{lstlisting}


上面的例子有一个通过 "POST" 方法传送的输入变量 (url)：

\begin{compactenum}
\item 检测是否存在 "POST" 类型的 "url" 输入变量
\item 如果存在此输入变量，对其进行净化（删除非法字符），并将其存储在 \$url 变量中
\end{compactenum}

假如输入变量类似这样：``http://www.th非e法qiong.com/"，则净化后的 \$url 变量应该是这样的：\verb|http://www.theqiong.com/|


\section{Filter Multiple Inputs}


表单通常由多个输入字段组成。为了避免对 filter\_var 或 filter\_input 重复调用，我们可以使用 filter\_var\_array 或 the filter\_input\_array 函数。

在下面的示例中，我们使用 filter\_input\_array() 函数来过滤三个 GET 变量。接收到的 GET 变量是一个名字、一个年龄以及一个邮件地址：


\begin{lstlisting}[language=PHP]
<?php
$filters = array
 (
 "name" => array
  (
  "filter"=>FILTER_SANITIZE_STRING
  ),
 "age" => array
  (
  "filter"=>FILTER_VALIDATE_INT,
  "options"=>array
   (
   "min_range"=>1,
   "max_range"=>120
   )
  ),
 "email"=> FILTER_VALIDATE_EMAIL,
 );

$result = filter_input_array(INPUT_GET, $filters);

if (!$result["age"])
 {
 echo("Age must be a number between 1 and 120.<br />");
 }
elseif(!$result["email"])
 {
 echo("E-Mail is not valid.<br />");
 }
else
 {
 echo("User input is valid");
 }
?>
\end{lstlisting}


上面的例子有三个通过 "GET" 方法传送的输入变量 (name, age and email)

\begin{compactenum}
\item 设置一个数组，其中包含了输入变量的名称，以及用于指定的输入变量的过滤器
\item 调用 filter\_input\_array 函数，参数包括 GET 输入变量及刚才设置的数组
\item 检测 \$result 变量中的``age" 和``email" 变量是否有非法的输入。（如果存在非法输入）
\end{compactenum}

filter\_input\_array() 函数的第二个参数可以是数组或单一过滤器的 ID。如果该参数是单一过滤器的 ID，那么这个指定的过滤器会过滤输入数组中所有的值。

如果该参数是一个数组，那么此数组必须遵循下面的规则：

\begin{compactitem}
\item 必须是一个关联数组，其中包含的输入变量是数组的键（比如``age" 输入变量）
\item 此数组的值必须是过滤器的 ID ，或者是规定了过滤器、标志以及选项的数组
\end{compactitem}


\section{Filter Callback}


通过使用 FILTER\_CALLBACK 过滤器，可以调用自定义的函数，把它作为一个过滤器来使用。这样，我们就拥有了数据过滤的完全控制权。

可以创建自己的自定义函数，也可以使用已有的 PHP 函数，而且规定准备用到过滤器函数的方法，与规定选项的方法相同。

在下面的例子中，我们使用了一个自定义的函数把所有 "\_" 转换为空格：

\begin{lstlisting}[language=PHP]
<?php
function convertSpace($string)
{
return str_replace("_", " ", $string);
}

$string = "Peter_is_a_great_guy!";

echo filter_var($string, FILTER_CALLBACK, array("options"=>"convertSpace"));
?>
\end{lstlisting}


上面的例子把所有``\_" 转换成空格：

\begin{compactenum}
\item 创建一个把``\_" 替换为空格的函数
\item 调用 filter\_var() 函数，它的参数是 FILTER\_CALLBACK 过滤器以及包含我们的函数的数组
\end{compactenum}



\chapter{PHP Error Handling}

在创建脚本和 web 应用程序时，错误处理是一个重要的部分。如果代码缺少错误检测编码，那么程序看上去很不专业，也为安全风险敞开了大门。

在 PHP 中，默认的错误处理很简单。一条消息会被发送到浏览器，这条消息带有文件名、行号以及一条描述错误的消息。

PHP中不同的错误处理方法包括：

\begin{compactitem}
\item 简单的``die()" 语句
\item 自定义错误和错误触发器
\item 错误报告
\end{compactitem}






\section{Basic Error Handling}



在操作文本文件的脚本中，如果文件不存在，会产生错误。为了避免用户获得错误消息，我们在访问文件之前检测该文件是否存在：


\begin{lstlisting}[language=PHP]
<?php
if(!file_exists("welcome.txt"))
 {
 die("File not found");
 }
else
 {
 $file=fopen("welcome.txt","r");
 }
?>
\end{lstlisting}

die()采用了一个简单的错误处理机制在错误之后终止了脚本。不过，简单地终止脚本并不总是恰当的方式。





\section{Custom errors and error triggers}

error 和 logging 函数允许开发者对错误进行处理和记录，从而使得创建一个自定义的错误处理器非常简单，其中：

\begin{compactitem}
\item error 函数允许用户定义错误处理规则，并修改记录错误的方式。
\item logging 函数允许用户对应用程序进行日志记录，并把日志消息发送到电子邮件、系统日志或其他的机器。
\end{compactitem}


下面我们很简单地创建了一个专用函数，可以在 PHP 中发生错误时调用该函数。

该函数必须有能力处理至少两个参数 (error level 和 error message)，但是可以接受最多五个参数（可选的：file, line-number 以及 error context）：

\begin{lstlisting}[language=PHP]
error_function(error_level,error_message,
error_file,error_line,error_context)
\end{lstlisting}

\begin{longtable}{|m{80pt}|m{300pt}|}
%head
\multicolumn{2}{r}{}
\tabularnewline\hline
参数	&描述
\endhead
%endhead

%firsthead
\caption{PHP 自定义错误处理器}\\
\hline
参数	&描述
\endfirsthead
%endfirsthead

%foot
\multicolumn{2}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot
\hline
error\_level	&必需。为用户定义的错误规定错误报告级别。必须是一个值数。\\
\hline
error\_message	&必需。为用户定义的错误规定错误消息。\\
\hline
error\_file	&可选。规定错误在其中发生的文件名。\\
\hline
error\_line	&可选。规定错误发生的行号。\\
\hline
error\_context	&可选。规定一个数组，包含了当错误发生时在用的每个变量以及它们的值。\\
\hline
\end{longtable}








\section{Error Reporting}

下面这些错误报告级别是错误处理程序旨在处理的错误的不同的类型：

\begin{longtable}{|m{20pt}|m{120pt}|m{240pt}|}
%head
\multicolumn{3}{r}{}
\tabularnewline\hline
值	&常量	&描述
\endhead
%endhead

%firsthead
\caption{PHP 错误报告级别}\\
\hline
值	&常量	&描述
\endfirsthead
%endfirsthead

%foot
\multicolumn{3}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot
\hline
2	&E\_WARNING			&非致命的 run-time 错误。不暂停脚本执行。\\
\hline
8	&E\_NOTICE			&Run-time 通知。脚本发现可能有错误发生，但也可能在脚本正常运行时发生。\\
\hline
256&E\_USER\_ERROR		&致命的用户生成的错误。这类似于程序员使用 PHP 函数 trigger\_error() 设置的 E\_ERROR。\\
\hline
512&E\_USER\_WARNING	&非致命的用户生成的警告。这类似于程序员使用 PHP 函数 trigger\_error() 设置的 E\_WARNING。\\
\hline
1024&E\_USER\_NOTICE	&用户生成的通知。这类似于程序员使用 PHP 函数 trigger\_error() 设置的 E\_NOTICE。\\
\hline
4096&E\_RECOVERABLE\_ERROR&可捕获的致命错误。类似 E\_ERROR，但可被用户定义的处理程序捕获。(参见 set\_error\_handler())\\
\hline
8191&E\_ALL\footnote{在 PHP 6.0，E\_STRICT 是 E\_ALL 的一部分。}&所有错误和警告，除级别 E\_STRICT 以外。\\
\hline
\end{longtable}


下面的代码创建一个处理错误的函数：

\begin{lstlisting}[language=PHP]
function customError($errno, $errstr)
 { 
 echo "<b>Error:</b> [$errno] $errstr<br />";
 echo "Ending Script";
 die();
 }
\end{lstlisting}


当这个错误处理函数被触发时，它会取得错误级别和错误消息。然后它会输出错误级别和消息，并终止脚本。


创建了一个错误处理函数之后，下一步我们需要确定的是在何时触发该函数。



\section{Error Handler}
\label{error_handler}


PHP 的默认错误处理程序是内建的错误处理程序，而且PHP允许将自定义错误处理函数改造为脚本运行期间的默认错误处理程序。


还可以修改错误处理程序，使其仅应用到某些错误，这样脚本就可以不同的方式来处理不同的错误。不过，下面将针对所有错误来使用我们的自定义错误处理程序：


\begin{lstlisting}[language=PHP]
set_error_handler("customError");
\end{lstlisting}

由于我们希望自定义函数来处理所有错误，于是set\_error\_handler() 仅使用一个参数，可以添加第二个参数来规定错误级别。下面通过尝试输出不存在的变量，来测试这个错误处理程序：

\begin{lstlisting}[language=PHP]
<?php
//error handler function
function customError($errno, $errstr)
 { 
 echo "<b>Error:</b> [$errno] $errstr";
 }

//set error handler
set_error_handler("customError");

//trigger error
echo($test);
?>
\end{lstlisting}

以上代码的输出应该类似这样：\verb|Error: [8] Undefined variable: test|


\section{Error Trigger}


在脚本中用户输入数据的位置，当用户的输入无效时触发错误的很有用的。在 PHP 中，这个任务由 trigger\_error() 完成。

在下面的示例中，如果``test" 变量大于``1"，就会发生错误：

\begin{lstlisting}[language=PHP]
<?php
$test=2;
if ($test>1)
{
trigger_error("Value must be 1 or below");
}
?>
\end{lstlisting}

可以在脚本中任何位置触发错误，通过添加的第二个参数，能够规定所触发的错误级别。

可能的错误类型包括：

\begin{compactitem}
\item E\_USER\_ERROR - 致命的用户生成的 run-time 错误。错误无法恢复。脚本执行被中断。
\item E\_USER\_WARNING - 非致命的用户生成的 run-time 警告。脚本执行不被中断。
\item E\_USER\_NOTICE - 默认。用户生成的 run-time 通知。脚本发现了可能的错误，也有可能在脚本运行正常时发生。
\end{compactitem}


在接下来的例子中，如果``test" 变量大于``1"，则发生 E\_USER\_WARNING 错误。如果发生了 E\_USER\_WARNING，我们将使用我们的自定义错误处理程序并结束脚本：


\begin{lstlisting}[language=PHP]
<?php
//error handler function
function customError($errno, $errstr)
 { 
 echo "<b>Error:</b> [$errno] $errstr<br />";
 echo "Ending Script";
 die();
 }

//set error handler
set_error_handler("customError",E_USER_WARNING);

//trigger error
$test=2;
if ($test>1)
 {
 trigger_error("Value must be 1 or below",E_USER_WARNING);
 }
?>
\end{lstlisting}

\section{Error Logging}


默认地，根据在 php.ini 中的 error\_log 配置，PHP 向服务器的错误记录系统或文件发送错误记录。通过使用 error\_log() 函数，可以向指定的文件或远程目的地发送错误记录，其中通过电子邮件向自己发送错误消息，是一种获得指定错误的通知的好办法。


在下面的例子中，如果特定的错误发生，我们将发送带有错误消息的电子邮件，并结束脚本：

\begin{lstlisting}[language=PHP]
<?php
//error handler function
function customError($errno, $errstr)
 { 
 echo "<b>Error:</b> [$errno] $errstr<br />";
 echo "Webmaster has been notified";
 error_log("Error: [$errno] $errstr",1,
 "someone@example.com","From: webmaster@example.com");
}

//set error handler
set_error_handler("customError",E_USER_WARNING);

//trigger error
$test=2;
if ($test>1)
 {
 trigger_error("Value must be 1 or below",E_USER_WARNING);
 }
?>
\end{lstlisting}

以上代码的输出应该类似这样：

\begin{lstlisting}[language=PHP]
Error: [512] Value must be 1 or below
Webmaster has been notified
\end{lstlisting}


接收自以上代码的邮件类似这样：

\begin{lstlisting}[language=PHP]
Error: [512] Value must be 1 or below
\end{lstlisting}


但是这个方法不适合所有的错误，常规错误还是应当通过使用默认的 PHP 记录系统在服务器上进行记录。



\section{PHP Error and Logging Functions}

error 和 logging 函数是 PHP 核心的组成部分，无需安装即可使用这些函数。



\begin{longtable}{|m{120pt}|m{250pt}|m{20pt}|}
%head
\multicolumn{3}{r}{}
\tabularnewline\hline
函数	&描述	&PHP
\endhead
%endhead

%firsthead
\caption{PHP Error 和 Logging 函数}\\
\hline
函数	&描述	&PHP
\endfirsthead
%endfirsthead

%foot
\multicolumn{3}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot

\hline
debug\_backtrace()			&生成 backtrace。	&4\\
\hline
debug\_print\_backtrace()	&输出 backtrace。	&5\\
\hline
error\_get\_last()			&获得最后发生的错误。&	5\\
\hline
error\_log()					&向服务器错误记录、文件或远程目标发送一个错误。	&4\\
\hline
error\_reporting()			&规定报告哪个错误。	&4\\
\hline
restore\_error\_handler()	&恢复之前的错误处理程序。	&4\\
\hline
restore\_exception\_handler()&	恢复之前的异常处理程序。	&5\\
\hline
set\_error\_handler()		&设置用户自定义的错误处理函数。	&4\\
\hline
set\_exception\_handler()	&设置用户自定义的异常处理函数。	&5\\
\hline
trigger\_error()				&创建用户自定义的错误消息。	&4\\
\hline
user\_error()				&trigger\_error() 的别名。	&4\\
\hline
\end{longtable}


\section{PHP Error and Logging Constants}


\begin{longtable}{|m{20pt}|m{125pt}|m{200pt}|m{20pt}|}
%head
\multicolumn{4}{r}{}
\tabularnewline\hline
值&常量	&描述	&PHP
\endhead
%endhead

%firsthead
\caption{PHP Error 和 Logging 常量}\\
\hline
值&常量	&描述	&PHP
\endfirsthead
%endfirsthead

%foot
\multicolumn{4}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot

\hline
1	&E\_ERROR		&致命的运行时错误。错误无法恢复。脚本的执行被中断。	& \\
\hline
2	&E\_WARNING	&非致命的运行时错误。脚本的执行不会中断。	 &\\
\hline
4	&E\_PARSE		&编译时语法解析错误。解析错误只应该由解析器生成。	 &\\
\hline
8	&E\_NOTICE	&运行时提示。可能是错误，也可能在正常运行脚本时发生。	&\\
\hline 
16	&E\_CORE\_ERROR	&由 PHP 内部生成的错误。	&4\\
\hline
32	&E\_CORE\_WARNING	&由 PHP 内部生成的警告。	&4\\
\hline
64	&E\_COMPILE\_ERROR	&由 Zend 脚本引擎内部生成的错误。	&4\\
\hline
128&	E\_COMPILE\_WARNING	&由 Zend 脚本引擎内部生成的警告。	&4\\
\hline
256&	E\_USER\_ERROR	&由于调用 trigger\_error() 函数生成的运行时错误。&	4\\
\hline
512&	E\_USER\_WARNING&由于调用 trigger\_error() 函数生成的运行时警告。&	4\\
\hline
1024&	E\_USER\_NOTICE	&由于调用 trigger\_error() 函数生成的运行时提示。&	4\\
\hline
2048&	E\_STRICT			&运行时提示。对增强代码的互用性和兼容性有益。	&5\\
\hline
4096&	E\_RECOVERABLE\_ERROR\footnote{参阅 \hyperref[error_handler]{set\_error\_handler()}}&可捕获的致命错误。&	5\\
\hline
8191&	E\_ALL	&所有的错误和警告，除了 E\_STRICT。	&5\\
\hline
\end{longtable}










\clearpage
\bibliographystyle{plainnat}
\bibliography{phpnotes}












































































